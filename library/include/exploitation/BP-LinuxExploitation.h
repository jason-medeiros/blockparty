#ifndef BP_LINUX_EXPLOITATION_H
#define BP_LINUX_EXPLOITATION_H

#if USE_BLOCKPARTY_DEBUGGING == 1

#if BLOCKPARTY_DEBUGGING_TARGET_32BIT == 1

// this file is used to describe linux specific exploitation routines

// holds a copy of an exploit buffer set for writing
typedef struct _EXPLOIT_SET {
	char * buffer;
	int size;
} EXPLOIT_SET, *P_EXPLOIT_SET;


// List structure used to record controllable registers found during exploitation
// NOT 100% reliable, perhaps 80% reliable, only use if cannot find a call * %esp;
// such as in the occasion of a ret2eax or ret2ebx or such.

// ONE list structure, per register that appears to be controllable
typedef struct _REGISTER_ANALYSIS_LIST {

	// registers, zero if uncontrolable
	size_t eax;
	size_t ebx;
	size_t ecx;
	size_t edx;
	
	size_t esp;
	size_t ebp;
	size_t esi;
	size_t eip;
	
	// Tells us whether the register is controlled via the heap
	// or controlled via the stack.
	int valueInHeap;
	int valueInStack;
	
	// if our register points into the payload we're controlling
	// it is possible to use alternate ret2condition functionality
	int registerPointsIntoPayload;
	
	// This is the value found in the base of the memory
	// segment that appears to be controlling the register
	// at this point. This is the actual value there aka (0x41414141)
	size_t valueAtBase;
	
	// This tells us the base (offset) to the bytes in the memory
	// segment ( our payload ) that appear to be causing the control
	// condition.  It is at this point, if the exploit is not working
	// properly, that these bytes should be replaced in our exploit with
	// valid pointers to strings or other structure values found in 
	// static portions of memory (such as the heap) to see if we can
	// get the application to return into our eip without segfaulting/etc
	void * occuringMemBase;
	
} REGISTER_ANALYSIS_LIST, *P_REGISTER_ANALYSIS_LIST;


// used to document specifics regarding heap payload exploitation
// This will effectively tell you if your condition is truly heap exploitable,
// given a compare buffer.
typedef struct _HEAP_PAYLOAD_ANALYSIS {

	// controlling heap chunk that we can
	// overwrite from
	P_HEAP_CHUNK controllingHeapChunk;
	
	// the offset to our first buffer occurance
	unsigned controllingHeapOffset;
	
	// flag 1 or 0 determining if the payload has
	// completely been matched in memory.
	int completePayloadMatch;
	
	// flag 1 or 0 determining if the payload has
	// overwritten its next chunk header 
	int controllingHeapNextOverflowed;
	
	// distance in bytes to next chunk header
	int distanceToNextChunk;
	
	// pointer to valid memory of where our
	// next valid arena starts
	void * nextValidArena;
	
	// next valid arena distance from our occurance
	int distanceToNextArena;

	// number of 1028 byte chunks that will be used
	// to pad up the heap till the next arena
	int padChunksTillArena;
	
	// remainder of the chunk if stored
	int padChunksTillArenaRemainder;
	
	
	
} HEAP_PAYLOAD_ANALYSIS, *P_HEAP_PAYLOAD_ANALYSIS;



// structure to hold the stack analysis data generated
// by proprietatry algorithims run against the data stack
typedef struct _STACK_PAYLOAD_ANALYSIS {
	
	// this stores our payload address in the process
	void *payloadAddr;
	
	// flag 1 or 0 determining if the payload has
	// completely been matched in memory.
	int completePayloadMatch;
	
	// flag 1 or 0 if match is greater then the effective
	// stack being overflowed (esp).  If we have an exact match
	// it should never be less then esp if it is a stack overflow.
	int matchIsLowerThanEsp;
	
	// Tells you the distance of your stack buffers
	// first occurance, to the position of stored eip
	// value.
	size_t distanceToEip;
	
	// identifies if this overflow is a perfect condition
	// from which we can write a perfect overflow.  if this
	// flag is set, its almost guaranteed that we can exploit
	// via stack exploitation.
	int overflowConditionsGood;
	
	// determines the amount of shellcode space we have left
	size_t spaceForShellcode;
	
	// the percentage match used to identify how our payload
	// matched against the existing stack
	int percentageMatch;
	
} STACK_PAYLOAD_ANALYSIS, *P_STACK_PAYLOAD_ANALYSIS;


// list to hold concurrent exploit analysis
// based on various buffers
typedef struct _EXPLOIT_ANALYSIS_LIST {
	char * payloadCompareBuffer;
	
	// flag to tell you if this payload appears to be exploiting anything
	// in memory.
	int exploiting;
	
	// if payload is exploiting something, flag > 0 if the payload is exploiting
	// in the stack.
		int exploitingInStack;
	
	// if payload is exploiting something, flag > 0 if the payload is exploiting
	// the heap.
		int exploitingInHeap;
	
	// stores the complete heap payload analysis
		P_HEAP_PAYLOAD_ANALYSIS heapPayloadAnalysis;
		
	// stores the complete stack payload analysis
		P_STACK_PAYLOAD_ANALYSIS stackPayloadAnalysis;
	
	// stores the complete register analysis
		P_REGISTER_ANALYSIS_LIST registerAnalysis;
	
	// 0 to N count representing what buffer the overflow occurs in 
	P_DATA_LIST occuringBuffer;
		
	// list pointers
	struct _EXPLOIT_ANALYSIS_LIST * first;
	struct _EXPLOIT_ANALYSIS_LIST * prev;
	struct _EXPLOIT_ANALYSIS_LIST * next;
	
} EXPLOIT_ANALYSIS_LIST, *P_EXPLOIT_ANALYSIS_LIST;

// Creates a list of analysis's from a buffer list, basically parsing through the
// data list to create a reasonable picture of exploitability in a process.
P_EXPLOIT_ANALYSIS_LIST DebugGetExploitAnalysisFromDataList(P_DEBUG_HANDLE dbgHandle, P_DATA_LIST inList);



// This creates an accurate exploit analysis, given a debugging handle
// if its signal was fatal, that signal is recorded.  Typically (6) IS
// a heap overflow, and 11 is a stack overflow or access violation.
P_EXPLOIT_ANALYSIS_LIST DebugCreateExploitAnalysis(P_DEBUG_HANDLE dbgHandle, char *payload, int payloadLength);


// ----------------------------------------------------
// creates the structures used in the exploit analysis
// ----------------------------------------------------

// Creates a heap to payload analysis
P_HEAP_PAYLOAD_ANALYSIS DebugCreateHeapPayloadAnalysis(P_DEBUG_HANDLE dbgHandle, char *payload, int payloadLength);

// Creates a stack to payload analysis
P_STACK_PAYLOAD_ANALYSIS DebugCreateStackPayloadAnalysis(P_DEBUG_HANDLE dbgHandle, char *payload, int payloadLength);

// Creates a register analysis list per register
P_REGISTER_ANALYSIS_LIST DebugCreateRegisterAnalysis(P_DEBUG_HANDLE dbgHandle, char *payload, int payloadLength);

// looks at a stack analysis, and returns a likely exploit buffer
// given the stack analysis in the dbgHandle
P_EXPLOIT_SET DebugCreateLikelyStackExploit(P_EXPLOIT_ANALYSIS_LIST exploitAnalysis, char nopChar, char *shellcode, size_t scLen);

// Returns the total space in bytes left over for writing
// in shellcode based upon an exploit analysis, used to write in 
// (think its unused right now ?)
int TotalSpaceForShellcode(P_EXPLOIT_ANALYSIS_LIST exploitAnalysis, int stackOrHeap);

// Creates a C styled exploit buffer given a string and id
char * ExploitCreateBuffer_C(char * name, char *id, int size);

// Creates a Perl styled exploit buffer given a string and id
char * ExploitCreateBuffer_Perl(char * name, char *id, int size);

// Creates a Python styled exploit buffer given a string and id
char * ExploitCreateBuffer_Python(char * name, char *id, int size);

// Creates a Ruby styled exploit buffer given a string and id
char * ExploitCreateBuffer_Ruby(char * name, char *id, int size);


// -----------------------------------------------------------
// Buffer operations from C
char * ExploitCreateFullSource(P_EXPLOIT_ANALYSIS_LIST analysis, P_DATA_LIST dataList, char *host, unsigned short port, int proto);

// Prints out the stack analysis
void DebugPrintStackAnalysis(P_EXPLOIT_ANALYSIS_LIST analysis);

// Prints out the heap analysis
void DebugPrintHeapAnalysis(P_EXPLOIT_ANALYSIS_LIST analysis);

// Prints out the register analysis
void DebugPrintRegisterAnalysis(P_EXPLOIT_ANALYSIS_LIST analysis);

// prints out all analysis
void DebugPrintAllAnalysis(P_EXPLOIT_ANALYSIS_LIST analysis);

#endif // USE_BLOCKPARTY_DEBUGGING == 1

#endif

#endif
