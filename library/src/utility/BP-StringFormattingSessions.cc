/*
 * BP-StringFormattingSessions.cc
 *
 *  Created on: Aug 4, 2014
 *      Author: root
 */

// include the blockparty main include file
#include "../include/BP-Main.h"


// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%% String Formatting Sessions %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

// Creates a new string formatting session
P_BP_SF_SESSION BP_CreateStringFormattingSession( char * name, P_BP_STRING_ROW_BORDER_SET border_set )
{

	// allocate space for the session
	P_BP_SF_SESSION session = (P_BP_SF_SESSION) bpcalloc(sizeof(BP_SF_SESSION), 1);
	if(!session)
		return NULL;

	// create new string formatting session
	session->tq = BP_CreateLinkL("sfs", BP_FALSE);
	if(!session->tq)
	{
		bpfree(session);
		return NULL;
	}

	// set name if one was provided
	if(name)
		session->session_name = tq_strndup(session->tq, name, BP_KILOBYTE, BPLN);



	if(border_set)
	{

		// set left and right borders
		session->border_set.border_left  = tq_strdup(session->tq, border_set->border_left, BPLN);
		session->border_set.border_right = tq_strdup(session->tq, border_set->border_right, BPLN);

		 // border top items
		session->border_set.border_top_enabled           = border_set->border_top_enabled;
		session->border_set.border_top_char              = tq_strdup(session->tq, border_set->border_top_char,   BPLN);
		session->border_set.border_top_left_corner       = tq_strdup(session->tq, border_set->border_top_left_corner, BPLN);
		session->border_set.border_top_right_corner      = tq_strdup(session->tq, border_set->border_top_right_corner, BPLN);

		 // border bottom items
		session->border_set.border_bottom_enabled        = border_set->border_bottom_enabled;
		session->border_set.border_bottom_char           = tq_strdup(session->tq, border_set->border_bottom_char,         BPLN);
		session->border_set.border_bottom_left_corner    = tq_strdup(session->tq, border_set->border_bottom_left_corner,  BPLN);
		session->border_set.border_bottom_right_corner   = tq_strdup(session->tq, border_set->border_bottom_right_corner, BPLN);

	}
	else
	{

		// default border is just spaces/padding

		// set left and right borders
		session->border_set.border_left  = tq_strdup(session->tq, " ", BPLN);
		session->border_set.border_right = tq_strdup(session->tq, " ", BPLN);

		 // border top items
		session->border_set.border_top_enabled           = BP_FALSE;
		session->border_set.border_top_char              = tq_strdup(session->tq, " ",   BPLN);
		session->border_set.border_top_left_corner       = tq_strdup(session->tq, "   ", BPLN);
		session->border_set.border_top_right_corner      = tq_strdup(session->tq, "   ", BPLN);

		 // border bottom items
		session->border_set.border_bottom_enabled        = BP_FALSE;
		session->border_set.border_bottom_char           = tq_strdup(session->tq, " ",   BPLN);
		session->border_set.border_bottom_left_corner    = tq_strdup(session->tq, "   ", BPLN);
		session->border_set.border_bottom_right_corner   = tq_strdup(session->tq, "   ", BPLN);

	}



	// return the allocated session
	return session;

}

// destroy the string formatting session
BP_ERROR_T BP_DestroyStringFormattingSession(P_BP_SF_SESSION formatting_session)
{

	// ensure we have a formatting session
	if(!formatting_session)
		return ERR_FAILURE;

	if(formatting_session)
		BP_DestroyAllStringEntryColumnizedDataSFSession(formatting_session);

	if(formatting_session->tq)
		BP_DestroyLinkL(formatting_session->tq, BP_TRUE);

	// destroy the formatting session itself
	bpfree(formatting_session);

	// return indicating success
	return ERR_SUCCESS;

}

// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%% Colorizations for Entries %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

// Repaint an existing string entry with a provided (NULL TERMINATED) paint set array.  This array can be
// generated by using the BP_GenerateAlternatingColorStack() routine found in BP-StringUtilities.cc (near the bottom.)
// Just use one color entry as an argument to that routine to generate solid colors.
BP_ERROR_T BP_RepaintExistingStringEntry(P_BP_SFS_STRING_ENTRY entry, P_BP_COLOR_CODE_SET_T * paint_set)
{

	// ensure we have an entry
	if(!entry)
		return ERR_FAILURE;
	// ensure we have a paint set to paint with
	if(!paint_set)
		return ERR_FAILURE;
	// ensure we have at least one entry
	if(!paint_set[0])
		return ERR_FAILURE;

	// paint iter, used for alternating in the case of a short list
	size_t paint_iter = 0;

	// walk the string
	size_t n = 0;
	for(; n < entry->string_length; n++, paint_iter++)
	{

		// reset paint iterator if necessary
		if(!paint_set[paint_iter])
			paint_iter = 0;

		// set colors directly
		entry->string[n].color_info.bg = paint_set[paint_iter]->bg;
		entry->string[n].color_info.fg = paint_set[paint_iter]->fg;

	}


	// return indicating success
	return ERR_SUCCESS;

}



// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%% Session Row Add-ers %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

// attempt to add a row group to a string formatting session
BP_ERROR_T BP_AddRowGroupToSFSession
(
	P_BP_SF_SESSION sfs,
	char * new_row_group_identifier,
	P_BP_STRING_ROW_BORDER_SET border_set
)
{

	// ensure we have a session
	if(!sfs)
		return ERR_FAILURE;

	// ensure we have a tail queue allocator
	if(!sfs->tq)
		return ERR_FAILURE;


	// create new row structure
	P_BP_SFS_STRING_ROW_GROUP new_row_group = (P_BP_SFS_STRING_ROW_GROUP) tq_calloc
	(
			sfs->tq,
			sizeof(BP_SFS_STRING_ROW_GROUP),
			1,
			BPLN
	);

	// ensure we can create a new row group
	if(!new_row_group)
		return ERR_FAILURE;


	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	// %%% Add Border Info %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


	if(border_set)
	{

		// set left and right borders
		new_row_group->border_set.border_left  = tq_strdup(sfs->tq, border_set->border_left, BPLN);
		new_row_group->border_set.border_right = tq_strdup(sfs->tq, border_set->border_right, BPLN);

		 // border top items
		new_row_group->border_set.border_top_enabled           = border_set->border_top_enabled;
		new_row_group->border_set.border_top_char              = tq_strdup(sfs->tq, border_set->border_top_char,   BPLN);
		new_row_group->border_set.border_top_left_corner       = tq_strdup(sfs->tq, border_set->border_top_left_corner, BPLN);
		new_row_group->border_set.border_top_right_corner      = tq_strdup(sfs->tq, border_set->border_top_right_corner, BPLN);

		 // border bottom items
		new_row_group->border_set.border_bottom_enabled        = border_set->border_bottom_enabled;
		new_row_group->border_set.border_bottom_char           = tq_strdup(sfs->tq, border_set->border_bottom_char,         BPLN);
		new_row_group->border_set.border_bottom_left_corner    = tq_strdup(sfs->tq, border_set->border_bottom_left_corner,  BPLN);
		new_row_group->border_set.border_bottom_right_corner   = tq_strdup(sfs->tq, border_set->border_bottom_right_corner, BPLN);

	}
	else
	{

		// default border is just spaces/padding

		// set left and right borders
		new_row_group->border_set.border_left  = tq_strdup(sfs->tq, "", BPLN);
		new_row_group->border_set.border_right = tq_strdup(sfs->tq, "", BPLN);

		 // border top items (disabled by default)
		new_row_group->border_set.border_top_enabled           = BP_FALSE;
		new_row_group->border_set.border_top_char              = tq_strdup(sfs->tq, " ",   BPLN);
		new_row_group->border_set.border_top_left_corner       = tq_strdup(sfs->tq, "   ", BPLN);
		new_row_group->border_set.border_top_right_corner      = tq_strdup(sfs->tq, "   ", BPLN);

		 // border bottom items (disabled by default)
		new_row_group->border_set.border_bottom_enabled        = BP_FALSE;
		new_row_group->border_set.border_bottom_char           = tq_strdup(sfs->tq, " ",   BPLN);
		new_row_group->border_set.border_bottom_left_corner    = tq_strdup(sfs->tq, "   ", BPLN);
		new_row_group->border_set.border_bottom_right_corner   = tq_strdup(sfs->tq, "   ", BPLN);

	}

	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	// %%% Add Row Group Items in Place %%%%%%%%%%%%%%%%%%%
	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	// increment row count
	sfs->row_group_n++;

	// now add memory for the new pointer
	sfs->row_groups = (P_BP_SFS_STRING_ROW_GROUP *) tq_realloc
	(
			sfs->tq,
			(void *) sfs->row_groups,
			sizeof(P_BP_SFS_STRING_ROW_GROUP) * (sfs->row_group_n+1),
			BPLN
	);

	// if we couldn't create space for the new group pointer,
	// return indicating failure.
	if(!sfs->row_groups)
	{
		sfs->row_group_n--;
		return ERR_FAILURE;
	}

	// set the group as the new row group
	sfs->row_groups[sfs->row_group_n-1] = new_row_group;

	// set session
	new_row_group->session = sfs;

	// only set identifier if the user has indicated they want to set one
	if(new_row_group_identifier)
	{
		// add identifier
		new_row_group->row_group_identifier = tq_strdup(sfs->tq, new_row_group_identifier, BPLN);
		if(!new_row_group->row_group_identifier)
			return ERR_FAILURE;

		// set row group identifier length
		new_row_group->row_group_identifier_len = strnlen(new_row_group->row_group_identifier, BP_KILOBYTE);

	}


	// return indicating success
	return ERR_SUCCESS;

}

// attempt to add a row group to a string formatting session
BP_ERROR_T BP_AddRowToRowGroupSFSession
(
	P_BP_SF_SESSION sfs,
	char * row_group_identifier,
	char * new_row_identifier,
	P_BP_STRING_ROW_BORDER_SET border_set
)
{


	// ensure we have parameters
	if(!sfs || !row_group_identifier || !new_row_identifier)
		return ERR_FAILURE;

	// ensure we have a tail queue allocator
	if(!sfs->tq)
		return ERR_FAILURE;


	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	// %%% Search for Row Group %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	// create/zero out search query
	BP_SFS_SEARCH_QUERY search_query;
	BP_ZERO_STACK(search_query);

	// set row group id
	search_query.row_group_id = row_group_identifier;

	// attempt to search for the row
	P_BP_SFS_SEARCH_RESULTS sfs_search_results = BP_SearchStringFormattingSession
	(
			sfs,
			&search_query
	);

	// ensure the stars line up
	if(!sfs_search_results)
		return ERR_FAILURE;
	if(!sfs_search_results->result_n || !sfs_search_results->results)
		return ERR_FAILURE;

	// ensure that we have found our row group
	if(!sfs_search_results->results[0].row_group)
		return ERR_FAILURE;


	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	// %%% Add Row to Row Group %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	// create reference for added readability
	P_BP_SFS_STRING_ROW_GROUP row_group = sfs_search_results->results[0].row_group;

	// increment the row count
	row_group->row_n++;

	// attempt to reallocate the row to
	// contain space for the new pointer.
	row_group->rows = (P_BP_SFS_STRING_ROW *) tq_realloc
	(
			sfs->tq,
			row_group->rows,
			sizeof(P_BP_SFS_STRING_ROW) * (row_group->row_n + 1),
			BPLN
	);

	if(!row_group->rows)
		return ERR_FAILURE;

	// add new row
	row_group->rows[row_group->row_n-1] = (P_BP_SFS_STRING_ROW) tq_calloc
	(
			sfs->tq,
			sizeof(BP_SFS_STRING_ROW),
			1,
			BPLN
	);

	// create row reference for readability
	P_BP_SFS_STRING_ROW new_row = row_group->rows[row_group->row_n-1];



	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	// %%% Add Border Info %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


	if(border_set)
	{

		// set left and right borders
		new_row->border_set.border_left  = tq_strdup(sfs->tq, border_set->border_left, BPLN);
		new_row->border_set.border_right = tq_strdup(sfs->tq, border_set->border_right, BPLN);

		 // border top items
		new_row->border_set.border_top_enabled           = border_set->border_top_enabled;
		new_row->border_set.border_top_char              = tq_strdup(sfs->tq, border_set->border_top_char,   BPLN);
		new_row->border_set.border_top_left_corner       = tq_strdup(sfs->tq, border_set->border_top_left_corner, BPLN);
		new_row->border_set.border_top_right_corner      = tq_strdup(sfs->tq, border_set->border_top_right_corner, BPLN);

		 // border bottom items
		new_row->border_set.border_bottom_enabled        = border_set->border_bottom_enabled;
		new_row->border_set.border_bottom_char           = tq_strdup(sfs->tq, border_set->border_bottom_char,         BPLN);
		new_row->border_set.border_bottom_left_corner    = tq_strdup(sfs->tq, border_set->border_bottom_left_corner,  BPLN);
		new_row->border_set.border_bottom_right_corner   = tq_strdup(sfs->tq, border_set->border_bottom_right_corner, BPLN);

	}
	else
	{

		// default border is just spaces/padding

		// set left and right borders
		new_row->border_set.border_left  = tq_strdup(sfs->tq, "", BPLN);
		new_row->border_set.border_right = tq_strdup(sfs->tq, "", BPLN);

		 // border top items
		new_row->border_set.border_top_enabled           = BP_FALSE;
		new_row->border_set.border_top_char              = tq_strdup(sfs->tq, " ",   BPLN);
		new_row->border_set.border_top_left_corner       = tq_strdup(sfs->tq, "   ", BPLN);
		new_row->border_set.border_top_right_corner      = tq_strdup(sfs->tq, "   ", BPLN);

		 // border bottom items
		new_row->border_set.border_bottom_enabled        = BP_FALSE;
		new_row->border_set.border_bottom_char           = tq_strdup(sfs->tq, " ",   BPLN);
		new_row->border_set.border_bottom_left_corner    = tq_strdup(sfs->tq, "   ", BPLN);
		new_row->border_set.border_bottom_right_corner   = tq_strdup(sfs->tq, "   ", BPLN);

	}




	// set the row identifier
	new_row->row_identifier = tq_strdup(sfs->tq, new_row_identifier, BPLN);

	// set identifier length
	new_row->row_identifier_len = bpstrlen(new_row_identifier);

	// now set the row group
	new_row->row_group = row_group;

	// return indicating success
	return ERR_SUCCESS;

}


// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%% Session Column Add-ers %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



// attempt to add a column to a row group
BP_ERROR_T BP_AddColumnGroupToRowSFSession
(
	P_BP_SF_SESSION sfs,
	char *row_group_identifier,
	char *row_identifier,
	char *new_column_group_identifier,
	P_BP_STRING_ROW_BORDER_SET border_set
)
{

	if(!sfs)
		return ERR_FAILURE;
	if(!sfs->tq)
		return ERR_FAILURE;
	if(!row_group_identifier || !row_identifier || !new_column_group_identifier)
		return ERR_FAILURE;




	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	// %%% Search for Row %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	// create/zero out search query
	BP_SFS_SEARCH_QUERY search_query;
	BP_ZERO_STACK(search_query);

	// set row group id
	search_query.row_group_id = row_group_identifier;
	search_query.row_id       = row_identifier;

	// attempt to search for the row
	P_BP_SFS_SEARCH_RESULTS sfs_search_results = BP_SearchStringFormattingSession
	(
			sfs,
			&search_query
	);

	// ensure the stars line up
	if(!sfs_search_results)
		return ERR_FAILURE;
	if(!sfs_search_results->result_n || !sfs_search_results->results)
		return ERR_FAILURE;

	// ensure that we have found our row group/row
	if(!sfs_search_results->results[0].row_group)
		return ERR_FAILURE;
	if(!sfs_search_results->results[0].row)
		return ERR_FAILURE;



	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	// %%% Add Column Group to Row %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


	// create reference for added readability
	P_BP_SFS_STRING_ROW row = sfs_search_results->results[0].row;

	// increment the row count
	row->col_group_n++;

	// attempt to reallocate the row to
	// contain space for the new pointer.
	row->col_groups = (P_BP_SFS_STRING_COLUMN_GROUP *) tq_realloc
	(
			sfs->tq,
			row->col_groups,
			sizeof(P_BP_SFS_STRING_COLUMN_GROUP) * (row->col_group_n + 1),
			BPLN
	);

	if(!row->col_groups)
		return ERR_FAILURE;

	// add new row
	row->col_groups[row->col_group_n-1] = (P_BP_SFS_STRING_COLUMN_GROUP) tq_calloc
	(
			sfs->tq,
			sizeof(BP_SFS_STRING_COLUMN_GROUP),
			1,
			BPLN
	);

	// create row reference for readability
	P_BP_SFS_STRING_COLUMN_GROUP new_column_group = row->col_groups[row->col_group_n-1];


	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	// %%% Add Border Info %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


	if(border_set)
	{

		// set left and right borders
		new_column_group->border_set.border_left  = tq_strdup(sfs->tq, border_set->border_left, BPLN);
		new_column_group->border_set.border_right = tq_strdup(sfs->tq, border_set->border_right, BPLN);

		 // border top items
		new_column_group->border_set.border_top_enabled           = border_set->border_top_enabled;
		new_column_group->border_set.border_top_char              = tq_strdup(sfs->tq, border_set->border_top_char,   BPLN);
		new_column_group->border_set.border_top_left_corner       = tq_strdup(sfs->tq, border_set->border_top_left_corner, BPLN);
		new_column_group->border_set.border_top_right_corner      = tq_strdup(sfs->tq, border_set->border_top_right_corner, BPLN);

		 // border bottom items
		new_column_group->border_set.border_bottom_enabled        = border_set->border_bottom_enabled;
		new_column_group->border_set.border_bottom_char           = tq_strdup(sfs->tq, border_set->border_bottom_char,         BPLN);
		new_column_group->border_set.border_bottom_left_corner    = tq_strdup(sfs->tq, border_set->border_bottom_left_corner,  BPLN);
		new_column_group->border_set.border_bottom_right_corner   = tq_strdup(sfs->tq, border_set->border_bottom_right_corner, BPLN);

	}
	else
	{

		// default border is just spaces/padding

		// set left and right borders
		new_column_group->border_set.border_left  = tq_strdup(sfs->tq, "", BPLN);
		new_column_group->border_set.border_right = tq_strdup(sfs->tq, "", BPLN);

		 // border top items
		new_column_group->border_set.border_top_enabled           = BP_FALSE;
		new_column_group->border_set.border_top_char              = tq_strdup(sfs->tq, " ",   BPLN);
		new_column_group->border_set.border_top_left_corner       = tq_strdup(sfs->tq, "   ", BPLN);
		new_column_group->border_set.border_top_right_corner      = tq_strdup(sfs->tq, "   ", BPLN);

		 // border bottom items
		new_column_group->border_set.border_bottom_enabled        = BP_FALSE;
		new_column_group->border_set.border_bottom_char           = tq_strdup(sfs->tq, " ",   BPLN);
		new_column_group->border_set.border_bottom_left_corner    = tq_strdup(sfs->tq, "   ", BPLN);
		new_column_group->border_set.border_bottom_right_corner   = tq_strdup(sfs->tq, "   ", BPLN);

	}


	// set the row identifier
	new_column_group->column_group_identifier = tq_strdup(sfs->tq, new_column_group_identifier, BPLN);

	// set identifier length
	new_column_group->column_group_identifier_len = bpstrlen(new_column_group_identifier);

	// now set the row group
	new_column_group->row = row;

	// set the session
	new_column_group->session = sfs;


	// return indicating success
	return ERR_SUCCESS;

}

// attempt to add a column to a row group
BP_ERROR_T BP_AddColumnToColumnGroupSFSession
(
	P_BP_SF_SESSION sfs,
	char *row_group_identifier,
	char *row_identifier,
	char *column_group_identifier,
	char *new_column_identifier,
	P_BP_STRING_ROW_BORDER_SET border_set
)
{

	if(!sfs)
		return ERR_FAILURE;
	if(!sfs->tq)
		return ERR_FAILURE;
	if(!row_group_identifier || !row_identifier || !column_group_identifier || !new_column_identifier)
		return ERR_FAILURE;


	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	// %%% Search for Row %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	// create/zero out search query
	BP_SFS_SEARCH_QUERY search_query;
	BP_ZERO_STACK(search_query);

	// set row group id
	search_query.row_group_id    = row_group_identifier;
	search_query.row_id          = row_identifier;
	search_query.column_group_id = column_group_identifier;

	// attempt to search for the row
	P_BP_SFS_SEARCH_RESULTS sfs_search_results = BP_SearchStringFormattingSession
	(
			sfs,
			&search_query
	);

	// ensure the stars line up
	if(!sfs_search_results)
		return ERR_FAILURE;
	if(!sfs_search_results->result_n || !sfs_search_results->results)
		return ERR_FAILURE;

	// ensure that we have found our row group/row
	if(!sfs_search_results->results[0].row_group)
		return ERR_FAILURE;
	if(!sfs_search_results->results[0].row)
		return ERR_FAILURE;
	if(!sfs_search_results->results[0].column_group)
		return ERR_FAILURE;


	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	// %%% Add Column to Column Group %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


	// create reference for added readability
	P_BP_SFS_STRING_COLUMN_GROUP column_group = sfs_search_results->results[0].column_group;

	// increment the row count
	column_group->columns_n++;

	// attempt to reallocate the row to
	// contain space for the new pointer.
	column_group->columns = (P_BP_SFS_STRING_COLUMN *) tq_realloc
	(
			sfs->tq,
			column_group->columns,
			sizeof(P_BP_SFS_STRING_COLUMN) * (column_group->columns_n + 1),
			BPLN
	);

	if(!column_group->columns)
		return ERR_FAILURE;

	// add new new column
	column_group->columns[column_group->columns_n-1] = (P_BP_SFS_STRING_COLUMN) tq_calloc
	(
			sfs->tq,
			sizeof(BP_SFS_STRING_COLUMN),
			1,
			BPLN
	);

	// create column reference for readability
	P_BP_SFS_STRING_COLUMN new_column = column_group->columns[column_group->columns_n-1];



	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	// %%% Add Border Info %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


	if(border_set)
	{

		// set left and right borders
		new_column->border_set.border_left  = tq_strdup(sfs->tq, border_set->border_left, BPLN);
		new_column->border_set.border_right = tq_strdup(sfs->tq, border_set->border_right, BPLN);

		 // border top items
		new_column->border_set.border_top_enabled           = border_set->border_top_enabled;
		new_column->border_set.border_top_char              = tq_strdup(sfs->tq, border_set->border_top_char,   BPLN);
		new_column->border_set.border_top_left_corner       = tq_strdup(sfs->tq, border_set->border_top_left_corner, BPLN);
		new_column->border_set.border_top_right_corner      = tq_strdup(sfs->tq, border_set->border_top_right_corner, BPLN);

		 // border bottom items
		new_column->border_set.border_bottom_enabled        = border_set->border_bottom_enabled;
		new_column->border_set.border_bottom_char           = tq_strdup(sfs->tq, border_set->border_bottom_char,         BPLN);
		new_column->border_set.border_bottom_left_corner    = tq_strdup(sfs->tq, border_set->border_bottom_left_corner,  BPLN);
		new_column->border_set.border_bottom_right_corner   = tq_strdup(sfs->tq, border_set->border_bottom_right_corner, BPLN);

	}
	else
	{

		// default border is just spaces/padding

		// set left and right borders
		new_column->border_set.border_left  = tq_strdup(sfs->tq, "", BPLN);
		new_column->border_set.border_right = tq_strdup(sfs->tq, "", BPLN);

		 // border top items
		new_column->border_set.border_top_enabled           = BP_FALSE;
		new_column->border_set.border_top_char              = tq_strdup(sfs->tq, " ",   BPLN);
		new_column->border_set.border_top_left_corner       = tq_strdup(sfs->tq, "   ", BPLN);
		new_column->border_set.border_top_right_corner      = tq_strdup(sfs->tq, "   ", BPLN);

		 // border bottom items
		new_column->border_set.border_bottom_enabled        = BP_FALSE;
		new_column->border_set.border_bottom_char           = tq_strdup(sfs->tq, " ",   BPLN);
		new_column->border_set.border_bottom_left_corner    = tq_strdup(sfs->tq, "   ", BPLN);
		new_column->border_set.border_bottom_right_corner   = tq_strdup(sfs->tq, "   ", BPLN);

	}



	// set the row identifier
	new_column->column_identifier = tq_strdup(sfs->tq, new_column_identifier, BPLN);

	// set identifier length
	new_column->column_identifier_len = bpstrlen(new_column_identifier);

	// now set the column group
	new_column->column_group = column_group;

	// set the session
	new_column->session = sfs;


	// return indicating success
	return ERR_SUCCESS;

}


// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%% Session String Entry Add-ers %%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

// Add string entry to a column using raw character string data.  This
// routine performs an auto-conversion to a P_BP_SFS_STRING_ENTRY.  This
// is more of a utility routine than anything else, as it just frontends
// into BP_AddStringEntryToColumn (found below).
BP_ERROR_T BP_AddStringEntryToColumnUsingASCIIDataSFSession
(
	P_BP_SF_SESSION sfs,
	char *row_group_identifier,
	char *row_identifier,
	char *column_group_identifier,
	char *column_identifier,
	char *new_string_identifier,
	char *new_string_data,
	size_t new_string_len,
	size_t new_display_width,
	P_BP_COLOR_CODE_SET_T new_initial_colors,
	P_BP_STRING_ROW_BORDER_SET border_set
)
{

	// ensure we have a sfs entry
	if(!sfs)
		return ERR_FAILURE;
	if(!row_group_identifier || !row_identifier || !column_group_identifier || !column_identifier)
		return ERR_FAILURE;

	// ensure we have new elements to add
	if(!new_string_identifier || !new_string_data || !new_string_len || !new_initial_colors)
		return ERR_FAILURE;

	// attempt to generate the string entry first
	P_BP_SFS_STRING_ENTRY string_entry = BP_GenerateStringEntryFromCharString
	(
			sfs,
			new_string_identifier,
			new_string_data,
			new_string_len,
			new_display_width,
			new_initial_colors,
			0,
			0,
			border_set
	);

	// ensure we can create entry, or exit
	if(!string_entry)
		return ERR_FAILURE;

	// return the addition return code
	return BP_AddStringEntryToColumnSFSession
	(
		sfs,
		row_group_identifier,
		row_identifier,
		column_group_identifier,
		column_identifier,
		string_entry,
		border_set
	);

}


// add a string entry to a column using a string entry pointer.  This is not a
// copy oriented routine.  This routine simply stores the string entry pointer
// within the column.  Again, the string_entry and related data is NOT duplicated,
// only a reference is stored.
BP_ERROR_T BP_AddStringEntryToColumnSFSession
(
	P_BP_SF_SESSION sfs,
	char * row_group_identifier,
	char * row_identifier,
	char * column_group_identifier,
	char * column_identifier,
	P_BP_SFS_STRING_ENTRY string_entry,
	P_BP_STRING_ROW_BORDER_SET border_set
)
{

	if(!sfs)
		return ERR_FAILURE;
	if(!sfs->tq)
		return ERR_FAILURE;
	if(!row_group_identifier || !row_identifier || !column_group_identifier || !column_identifier)
		return ERR_FAILURE;


	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	// %%% Search for Row %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	// create/zero out search query
	BP_SFS_SEARCH_QUERY search_query;
	BP_ZERO_STACK(search_query);

	// set row group id
	search_query.row_group_id    = row_group_identifier;
	search_query.row_id          = row_identifier;
	search_query.column_group_id = column_group_identifier;
	search_query.column_id       = column_identifier;

	// attempt to search for the row
	P_BP_SFS_SEARCH_RESULTS sfs_search_results = BP_SearchStringFormattingSession
	(
			sfs,
			&search_query
	);

	// ensure the stars line up
	if(!sfs_search_results)
		return ERR_FAILURE;

	// printf("\n Getting here when adding ENTRIES!: %s - %s - %s - %s", row_group_identifier, row_identifier, column_group_identifier, column_group_identifier);
	// BP_DisplaySFSSearchResults(sfs_search_results);

	// ensure we have results
	if(!sfs_search_results->result_n || !sfs_search_results->results)
		return ERR_FAILURE;



	if(!sfs_search_results->results[0].row_group)
	if(!sfs_search_results->results[0].row)
	if(!sfs_search_results->results[0].column_group)
	if(!sfs_search_results->results[0].column)
	{
		tq_free(sfs->tq, sfs_search_results);
		return ERR_FAILURE;
	}


	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	// %%% Add Column to Column Group %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


	// create reference for added readability
	P_BP_SFS_STRING_COLUMN column = sfs_search_results->results[0].column;

	// increment the row count
	column->entries++;

	// attempt to reallocate the row to
	// contain space for the new pointer.
	column->col_data = (P_BP_SFS_STRING_ENTRY *) tq_realloc
	(
			sfs->tq,
			column->col_data,
			sizeof(P_BP_SFS_STRING_ENTRY) * (column->entries + 1),
			BPLN
	);

	if(!column->col_data)
	{
		tq_free(sfs->tq, column);
		return ERR_FAILURE;
	}

	// set the string entry here
	column->col_data[column->entries-1] = string_entry;

	if(column->widest_column < string_entry->string_length)
		column->widest_column = string_entry->string_length;

	// destroy the search results
	tq_free(sfs->tq, sfs_search_results);

	// return indicating success
	return ERR_SUCCESS;

}



// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%% String Entry Generators %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


// Generates a string entry from an ascii character string
P_BP_SFS_STRING_ENTRY BP_GenerateStringEntryFromCharString
(
		P_BP_SF_SESSION sfs,
		char * string_entry_identifier,
		char * string,
		size_t string_len,
		size_t display_width,
		P_BP_COLOR_CODE_SET_T initial_colors,
		size_t pad_lines_below,
		size_t pad_lines_above,
		P_BP_STRING_ROW_BORDER_SET border_set
)
{

	// ensure we have a session to allocate from
	if(!sfs)
		return NULL;
	if(!sfs->tq)
		return NULL;

	// ensure we have a string with a length (colors are optional)
	if(!string || !string_len || !string_entry_identifier)
		return NULL;

	// allocate space for the individual entries
	P_BP_SFS_CHAR_ENTRY char_entries = (P_BP_SFS_CHAR_ENTRY) tq_calloc
	(
		sfs->tq,
		sizeof(BP_SFS_CHAR_ENTRY) * string_len,
		1,
		BPLN
	);

	// ensure we have allocated space for the entries
	if(!char_entries)
		return NULL;


	// now create string entry
	P_BP_SFS_STRING_ENTRY str_entry = (P_BP_SFS_STRING_ENTRY) tq_calloc
	(
		sfs->tq,
		sizeof(BP_SFS_STRING_ENTRY),
		1,
		BPLN
	);

	// if we couldn't create the string entry, free character entry
	// and return.
	if(!str_entry)
	{
		tq_free(sfs->tq, char_entries);
		return NULL;
	}

	// allocate space for the identifier
	str_entry->string_entry_identifier = tq_strdup(sfs->tq, string_entry_identifier, BPLN);

	// ensure we could allocate the entry
	if(!str_entry->string_entry_identifier)
	{
		tq_free(sfs->tq, char_entries);
		tq_free(sfs->tq, str_entry);
		return NULL;
	}

	// set the length directly
	str_entry->string_entry_identifier_len = bpstrlen(str_entry->string_entry_identifier);

	// Now that all allocations have completed, we can start
	// copying in data.

	// walk the string length and add entries
	size_t n = 0;
	for(; n < string_len; n++)
	{

		// add character entry
		char_entries[n].character = (char) string[n];

		// set initial characters if necessary
		if(initial_colors)
		{
			char_entries[n].color_info.bg = initial_colors->bg;
			char_entries[n].color_info.fg = initial_colors->fg;
		}

	}

	// set string member
	str_entry->string        = char_entries;
	str_entry->string_length = string_len;

	// set marked for display to default
	str_entry->marked_display_disabled = BP_FALSE;

	// set the display width
	str_entry->display_max_width = display_width;

	// set pad lines
	str_entry->pad_lines_above = pad_lines_above;
	str_entry->pad_lines_below = pad_lines_below;


	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	// %%% Add Border Info %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


	if(border_set)
	{

		// set left and right borders
		str_entry->border_set.border_left  = tq_strdup(sfs->tq, border_set->border_left, BPLN);
		str_entry->border_set.border_right = tq_strdup(sfs->tq, border_set->border_right, BPLN);

		 // border top items
		str_entry->border_set.border_top_enabled           = border_set->border_top_enabled;
		str_entry->border_set.border_top_char              = tq_strdup(sfs->tq, border_set->border_top_char,   BPLN);
		str_entry->border_set.border_top_left_corner       = tq_strdup(sfs->tq, border_set->border_top_left_corner, BPLN);
		str_entry->border_set.border_top_right_corner      = tq_strdup(sfs->tq, border_set->border_top_right_corner, BPLN);

		 // border bottom items
		str_entry->border_set.border_bottom_enabled        = border_set->border_bottom_enabled;
		str_entry->border_set.border_bottom_char           = tq_strdup(sfs->tq, border_set->border_bottom_char,         BPLN);
		str_entry->border_set.border_bottom_left_corner    = tq_strdup(sfs->tq, border_set->border_bottom_left_corner,  BPLN);
		str_entry->border_set.border_bottom_right_corner   = tq_strdup(sfs->tq, border_set->border_bottom_right_corner, BPLN);

	}
	else
	{

		// default border is just spaces/padding

		// set left and right borders
		str_entry->border_set.border_left  = tq_strdup(sfs->tq, "", BPLN);
		str_entry->border_set.border_right = tq_strdup(sfs->tq, "", BPLN);

		 // border top items
		str_entry->border_set.border_top_enabled           = BP_FALSE;
		str_entry->border_set.border_top_char              = tq_strdup(sfs->tq, " ",   BPLN);
		str_entry->border_set.border_top_left_corner       = tq_strdup(sfs->tq, "   ", BPLN);
		str_entry->border_set.border_top_right_corner      = tq_strdup(sfs->tq, "   ", BPLN);

		 // border bottom items
		str_entry->border_set.border_bottom_enabled        = BP_FALSE;
		str_entry->border_set.border_bottom_char           = tq_strdup(sfs->tq, " ",   BPLN);
		str_entry->border_set.border_bottom_left_corner    = tq_strdup(sfs->tq, "   ", BPLN);
		str_entry->border_set.border_bottom_right_corner   = tq_strdup(sfs->tq, "   ", BPLN);

	}




	// return the filled in string entry
	return str_entry;

}


// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%% Search Routines %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

// Utility routine for adding entries to a search results structure.  Entries
// are tied to the tail queue allocator within the session parameter.
BP_ERROR_T BP_AddStringResultEntryToSFSSearchResults
(
		P_BP_SFS_SEARCH_RESULTS            sfs_search_results,
		P_BP_SF_SESSION                    session,
		P_BP_SFS_STRING_ROW_GROUP          row_group,
		P_BP_SFS_STRING_ROW                row,
		P_BP_SFS_STRING_COLUMN_GROUP       column_group,
		P_BP_SFS_STRING_COLUMN             column,
		P_BP_SFS_STRING_ENTRY              string_entry
)
{

	// ensure we have search results and a session to
	// attribute them to.
	if(!sfs_search_results || !session)
		return ERR_FAILURE;

	// ensure we have a tailqueue allocator to work with
	if(!session->tq)
		return ERR_FAILURE;

	// allocate new space for results
	sfs_search_results->results = (P_BP_SFS_SEARCH_RESULT) tq_realloc
	(
		session->tq,
		sfs_search_results->results,
		sizeof(BP_SFS_SEARCH_RESULT) * (sfs_search_results->result_n + 1),
		BPLN
	);

	// ensure the results were reallocated ok
	if(!sfs_search_results->results)
		return ERR_FAILURE;

	// create index for readability
	size_t idx = sfs_search_results->result_n;

	// create an iter for readability
	P_BP_SFS_SEARCH_RESULT iter = &sfs_search_results->results[idx];

	// set items directly (no checks required as NULL values are OK)
	iter->session       = session;
	iter->row_group     = row_group;
	iter->row           = row;
	iter->column_group  = column_group;
	iter->column        = column;
	iter->string_entry  = string_entry;

	// since all allocations and assignments were ok, increment the result
	// counter.
	sfs_search_results->result_n++;

	// return indicating success
	return ERR_SUCCESS;

}

// Search through a string formatting session for all entries matching parameters set within
// query structure.
P_BP_SFS_SEARCH_RESULTS BP_SearchStringFormattingSession(P_BP_SF_SESSION session, P_BP_SFS_SEARCH_QUERY query)
{

	// ensure we have a query
	if(!session || !query)
		return NULL;

	// ensure we have a tail queue allocator
	if(!session->tq)
		return NULL;

	// allocate space for results
	P_BP_SFS_SEARCH_RESULTS results = (P_BP_SFS_SEARCH_RESULTS) tq_calloc
	(
			session->tq,
			sizeof(BP_SFS_SEARCH_RESULTS),
			1,
			BPLN
	);

	// set the session
	results->session = session;

	// first search for row group
	// next search for row
	// next search for column group
	// next search for column
	// next search for string entry

	// set search value length indicators
	size_t row_group_id_len    = 0;
	size_t row_id_len          = 0;
	size_t column_group_id_len = 0;
	size_t column_id_len       = 0;
	size_t string_entry_len    = 0;


	// set row group id length (if necessary)
	if(query->row_group_id)
		row_group_id_len = bpstrlen(query->row_group_id);

	// set row id length (if necessary)
	if(query->row_id)
		row_id_len = bpstrlen(query->row_id);

	// set column group id length (if necessary)
	if(query->column_group_id)
		column_group_id_len = bpstrlen(query->column_group_id);

	// set column id (if necessary)
	if(query->column_id)
		column_id_len = bpstrlen(query->column_id);

	// set string entry length if necessary
	if(query->string_entry_id)
		string_entry_len = bpstrlen(query->string_entry_id);

	// row iterators
	size_t row_group_n    = 0;
	size_t row_n          = 0;
	size_t column_group_n = 0;
	size_t column_n       = 0;
	size_t string_entry_n = 0;

	// we must at least have a row group id for searching
	if(!row_group_id_len || !query->row_group_id)
		return NULL;

	// search result candidates
	P_BP_SF_SESSION               session_candidate = NULL;
	P_BP_SFS_STRING_ROW_GROUP     row_group_candidate = NULL;
	P_BP_SFS_STRING_ROW           row_candidate = NULL;
	P_BP_SFS_STRING_COLUMN_GROUP  column_group_candidate = NULL;
	P_BP_SFS_STRING_COLUMN        column_candidate = NULL;
	P_BP_SFS_STRING_ENTRY         string_entry_candidate = NULL;


	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	// %%% Cascading Search Entry Point %%%%%%%%%%%%%%%%%%%%%%%%%%
	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	// walk row groups
	if(session->row_group_n)
	for(; row_group_n < session->row_group_n; row_group_n++)
	{

		// reset all candidates on loop
		session_candidate      = NULL;
		row_group_candidate    = NULL;
		row_candidate          = NULL;
		column_group_candidate = NULL;
		column_candidate       = NULL;
		string_entry_candidate = NULL;

		// cascade and set candidates
		session_candidate = session;




		// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		// 1) Run exclusionary group checks %%%%%%%%%%%%%%%%%%%%%%%%
		// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		// printf("\n Got Row Group Id Len?: %u - %u", row_group_id_len, row_group_candidate->row_group_identifier_len);


		// set row group candidate
		row_group_candidate = session_candidate->row_groups[row_group_n];

		// ensure lengths match up
		if(row_group_id_len != row_group_candidate->row_group_identifier_len)
		{
			row_group_candidate = NULL;
			continue;
		}

		// if the length check passed, run memory compare check
		if
		(
			memcmp
			(
				row_group_candidate->row_group_identifier,
				query->row_group_id,
				row_group_id_len
			) != 0
		)
		{
			row_group_candidate = NULL;
			continue;
		}

		if(!row_group_candidate)
			continue;



		// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		// 2) Row Cascading Checks %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

		// walk rows and search
		if(row_group_candidate->row_n && row_id_len)
		{

			for
			(
					row_n = 0;
					row_n < row_group_candidate->row_n;
					row_n++
			)
			{

				// set row candidate as current row
				row_candidate = row_group_candidate->rows[row_n];

				// run candidate checks
				if(row_candidate->row_identifier_len == row_id_len)
				if
				(
					memcmp
					(
						row_candidate->row_identifier,
						query->row_id,
						row_id_len
					) != 0
				)
				{
					row_candidate = NULL;
					continue;
				}


				// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
				// 2) Column Group Cascading Checks %%%%%%%%%%%%%%%%%%%%%%%%%
				// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

				if(row_candidate->col_group_n && column_group_id_len)
				{


					for
					(
						column_group_n = 0;
						column_group_n < row_candidate->col_group_n;
						column_group_n++
					)
					{


						// set row candidate as current row
						column_group_candidate = row_candidate->col_groups[column_group_n];

						// run candidate checks
						if(column_group_candidate->column_group_identifier_len == column_group_id_len)
						if
						(
							memcmp
							(
								column_group_candidate->column_group_identifier,
								query->column_group_id,
								column_group_id_len
							) != 0
						)
						{
							column_group_candidate = NULL;
							continue;
						}


					}

					// ensure we have a column group candidate
					if(!column_group_candidate)
						continue;

					// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
					// 4) Column Group Cascading Checks %%%%%%%%%%%%%%%%%%%%%%%%%
					// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

					if(column_group_candidate->columns && column_id_len)
					{


						for
						(
							column_n = 0;
							column_n < column_group_candidate->columns_n;
							column_n++
						)
						{


							// set row candidate as current row
							column_candidate = column_group_candidate->columns[column_n];

							// run candidate checks
							if(column_candidate->column_identifier_len == column_id_len)
							if
							(
								memcmp
								(
									column_candidate->column_identifier,
									query->column_id,
									column_id_len
								) != 0
							)
							{
								column_candidate = NULL;
								continue;
							}

							// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
							// 5) String Entry Cascading Checks %%%%%%%%%%%%%%%%%%%%%%%%%
							// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


							if(column_candidate->col_data && string_entry_len)
							{

								for
								(
									string_entry_n = 0;
									string_entry_n < column_candidate->entries;
									string_entry_n++
								)
								{


									// set string entry candidate
									string_entry_candidate = column_candidate->col_data[string_entry_n];

									// run candidate checks
									if(string_entry_candidate->string_entry_identifier_len == string_entry_len)
									{
										if
										(
											memcmp
											(
												string_entry_candidate->string_entry_identifier,
												query->string_entry_id,
												string_entry_len
											) != 0
										)
										{
											string_entry_candidate = NULL;
											continue;
										}
										else
										{

											if(string_entry_candidate)
											BP_AddStringResultEntryToSFSSearchResults
											(
												results,
												session_candidate,
												row_group_candidate,
												row_candidate,
												column_group_candidate,
												column_candidate,
												string_entry_candidate
											);

										}
									}
								}
							}
							else
							{


								// add result if we have a match and no row_id to match
								if(!string_entry_len)
								if(column_id_len == column_candidate->column_identifier_len)
								{

									// ensure that we have a memory wise match
									if
									(
										memcmp
										(
											column_candidate->column_identifier,
											query->column_id,
											column_candidate->column_identifier_len
										) == 0
									)
									{

										BP_AddStringResultEntryToSFSSearchResults
										(
											results,
											session_candidate,
											row_group_candidate,
											row_candidate,
											column_group_candidate,
											column_candidate,
											string_entry_candidate
										);

									}

								}

							}

						}

					}
					else
					{

						// add result if we have a match and no row_id to match
						if(!column_id_len)
						if(column_group_id_len == column_group_candidate->column_group_identifier_len)
						{

							// ensure that we have a memory wise match
							if
							(
								memcmp
								(
									column_group_candidate->column_group_identifier,
									query->column_group_id,
									column_group_candidate->column_group_identifier_len
								) == 0
							)
							{

								BP_AddStringResultEntryToSFSSearchResults
								(
									results,
									session_candidate,
									row_group_candidate,
									row_candidate,
									column_group_candidate,
									column_candidate,
									string_entry_candidate
								);

							}

						}

					} // end cascading row search for() column group

				}
				else
				{


					// add result if we have a match and no row_id to match
					if(!column_group_id_len)
					if(row_id_len == row_candidate->row_identifier_len)
					{

						// ensure that we have a memory wise match
						if
						(
								memcmp
								(
									row_candidate->row_identifier,
									query->row_id,
									row_candidate->row_identifier_len
								) == 0
						)
						{

							BP_AddStringResultEntryToSFSSearchResults
							(
								results,
								session_candidate,
								row_group_candidate,
								row_candidate,
								column_group_candidate,
								column_candidate,
								string_entry_candidate
							);

						}

					}

				}

			} // end cascading row search for() column group


		}
		else
		{





			// add result if we have a match and no row_id to match
			if(!row_id_len)
			if(row_group_id_len == row_group_candidate->row_group_identifier_len)
			{

				// ensure that we have a memory wise match
				if
				(
						memcmp
						(
							row_group_candidate->row_group_identifier,
							query->row_group_id,
							row_group_candidate->row_group_identifier_len
						) == 0
				)
				{

					BP_AddStringResultEntryToSFSSearchResults
					(
						results,
						session_candidate,
						row_group_candidate,
						row_candidate,
						column_group_candidate,
						column_candidate,
						string_entry_candidate
					);

				}

			}


		} // end cascading row search for() row group

	}

	// return the pointer
	return results;

}

// Destroy search results
BP_ERROR_T BP_DestroySearchResultsSFSession(P_BP_SF_SESSION session, P_BP_SFS_SEARCH_RESULTS sfs_search_results)
{

	// ensure we have a sfs session
	if(!session)
		return ERR_FAILURE;
	if(!session->tq)
		return ERR_FAILURE;

	// ensure we have results
	if(!sfs_search_results)
		return ERR_FAILURE;

	// destroy the results if they exist
	if(sfs_search_results->results)
	{

		// free the session results if they exist
		tq_free(session->tq, sfs_search_results->results);

	}

	// now free the session itself
	tq_free(session->tq, sfs_search_results);

	// return indicating success
	return ERR_SUCCESS;

}

// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%% Search Display Routines %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


// Display single result entry.
BP_ERROR_T BP_DisplaySFSSearchResult(P_BP_SFS_SEARCH_RESULT result)
{

	if(!result)
		return ERR_FAILURE;

	printf("\n\t [-] Result (%p)", result);

	if(result->session)
		printf("   (session: %p - %s)", result->session, result->session->session_name);


	if(result->row_group)
		printf("\n\t   row_group:    %p - %s", result->row_group, result->row_group->row_group_identifier);

	if(result->row)
		printf("\n\t   row:          %p - %s", result->row, result->row->row_identifier);

	if(result->column_group)
		printf("\n\t   column group: %p - %s", result->column_group, result->column_group->column_group_identifier);

	if(result->column)
		printf("\n\t   column:       %p - %s", result->column, result->column->column_identifier);

	if(result->string_entry)
		printf("\n\t   string_entry: %p - (char entry: %p) : %s", result->string_entry, result->string_entry->string, result->string_entry->string_entry_identifier);

	printf("\n");

	// return indicating success
	return ERR_SUCCESS;

}


// Display RESULTS. Calls BP_DisplaySFSSearchResult on each result in the results
// structure.
BP_ERROR_T BP_DisplaySFSSearchResults(P_BP_SFS_SEARCH_RESULTS results)
{

	if(!results)
		return ERR_FAILURE;

	// display header
	printf("\n [+] SFS Search Results (%p)", results);
	printf("\n     session:    %p", results->session);
	printf("\n     results:    %p", results->results);
	printf("\n     results_n:  %u", results->result_n);
	printf("\n");

	// walk and display each result
	size_t n = 0;
	for(; n < results->result_n; n++)
		BP_DisplaySFSSearchResult(&results->results[n]);

	// display trailing newline
	printf("\n");

	// return indicating success
	return ERR_SUCCESS;

}



// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%% Standard Display Routines %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

// NOTE:  Display routines are not to be confused with output
//        routines.  Output routines are used for displaying
//        formatted text to the end user whereas display routines
//        are used for displaying relative session structures (program data)
//        which is useful to a developer trying to get things
//        to work as expected.

BP_ERROR_T BP_DisplaySFSIndividualCharacter
(
		BP_SFS_CHAR_ENTRY character,
		P_BP_SFS_INFO_DISPLAY_SETTINGS display_settings
)
{
	// return indicating success
	return ERR_SUCCESS;
}

// Display a string entry
BP_ERROR_T BP_DisplaySFSStringEntry
(
		P_BP_SFS_STRING_ENTRY string_entry,
		P_BP_SFS_INFO_DISPLAY_SETTINGS display_settings
)
{



	// ensure we have a column and a display settings structure
	if(!string_entry || !display_settings)
		return ERR_FAILURE;

	if(display_settings->display_string_entries)
	{

		// create the tab_depth stack buffer and fill it with
		// the appropriate number of tab characters
		BP_SFS_CREATE_TAB_DEPTH_BUFFER;

		printf("\n%s [-] String Entry: (%p)",   tab_depth, string_entry);
		printf("\n%s     identifier:      %s",    tab_depth, string_entry->string_entry_identifier);
		printf("\n%s     string:          %p",    tab_depth, string_entry->string);
		printf("\n%s     string_length:   %u",    tab_depth, string_entry->string_length);
		printf("\n%s     final_columnization:           %p", tab_depth, string_entry->final_columnization);
		printf("\n%s     final_columnization_colorized: %p", tab_depth, string_entry->final_columnization_colorized);
		printf("\n");

		// add display depth
		display_settings->current_display_depth++;

	}

	// now display sfs columns (censors based around displays settings)
	size_t n = 0;
	for(; n < string_entry->string_length; n++)
		BP_DisplaySFSIndividualCharacter(string_entry->string[n], display_settings);

	// decrement the display depth on return
	if(display_settings->current_display_depth)
		display_settings->current_display_depth--;



	// return indicating success
	return ERR_SUCCESS;
}

// Display a column
BP_ERROR_T BP_DisplaySFSColumn
(
	P_BP_SFS_STRING_COLUMN column,
	P_BP_SFS_INFO_DISPLAY_SETTINGS display_settings
)
{


	// ensure we have a column and a display settings structure
	if(!column || !display_settings)
		return ERR_FAILURE;

	if(display_settings->display_columns)
	{

		// create the tab_depth stack buffer and fill it with
		// the appropriate number of tab characters
		BP_SFS_CREATE_TAB_DEPTH_BUFFER;

		printf("\n%s [-] Column: (%p)",   tab_depth, column);
		printf("\n%s     identifier:   %s",    tab_depth, column->column_identifier);
		printf("\n%s     col_data:     %p",    tab_depth, column->col_data);
		printf("\n%s     entries:      %u",    tab_depth, column->entries);
		printf("\n%s     widest col:   %u",    tab_depth, column->widest_column);
		printf("\n%s     widths:       %p",    tab_depth, column->widths);
		printf("\n%s     final_columnization:           %p", tab_depth, column->final_columnization);
		printf("\n%s     final_columnization_colorized: %p", tab_depth, column->final_columnization_colorized);
		printf("\n");

		// add display depth
		display_settings->current_display_depth++;

	}

	// now display sfs columns (censors based around displays settings)
	size_t n = 0;
	for(; n < column->entries; n++)
		BP_DisplaySFSStringEntry(column->col_data[n], display_settings);

	// decrement the display depth on return
	if(display_settings->current_display_depth)
		display_settings->current_display_depth--;

	// return indicating success
	return ERR_SUCCESS;

}

// display a column group
BP_ERROR_T BP_DisplaySFSColumnGroup
(
	P_BP_SFS_STRING_COLUMN_GROUP column_group,
	P_BP_SFS_INFO_DISPLAY_SETTINGS display_settings
)
{


	// ensure we have a column group and a display settings structure
	if(!column_group || !display_settings)
		return ERR_FAILURE;

	if(display_settings->display_column_groups)
	{

		// create the tab_depth stack buffer and fill it with
		// the appropriate number of tab characters
		BP_SFS_CREATE_TAB_DEPTH_BUFFER;

		printf("\n%s [-] Column Group: (%p)",   tab_depth, column_group);
		printf("\n%s     identifier:    %s",    tab_depth, column_group->column_group_identifier);
		printf("\n%s     columns:       %p",    tab_depth, column_group->columns);
		printf("\n%s     column_n:      %u",    tab_depth, column_group->columns_n);
		printf("\n%s     final_columnization:           %p", tab_depth, column_group->final_columnization);
		printf("\n%s     final_columnization_colorized: %p", tab_depth, column_group->final_columnization_colorized);
		printf("\n");

		// add display depth
		display_settings->current_display_depth++;

	}

	// now display sfs columns (censors based around displays settings)
	size_t n = 0;
	for(; n < column_group->columns_n; n++)
		BP_DisplaySFSColumn(column_group->columns[n], display_settings);

	// decrement the display depth on return
	if(display_settings->current_display_depth)
		display_settings->current_display_depth--;

	// return indicating success
	return ERR_SUCCESS;

}

// Display a row
BP_ERROR_T BP_DisplaySFSRow
(
	P_BP_SFS_STRING_ROW row,
	P_BP_SFS_INFO_DISPLAY_SETTINGS display_settings
)
{

	// ensure we could create the settings
	if(!row || !display_settings)
		return ERR_FAILURE;

	if(display_settings->display_row_groups)
	{

		// create the tab_depth stack buffer and fill it with
		// the appropriate number of tab characters
		BP_SFS_CREATE_TAB_DEPTH_BUFFER;

		printf("\n%s [-] Row: (%p) - (group: %p)",        tab_depth, row, row->row_group);
		printf("\n%s     identifier:      %s",              tab_depth, row->row_identifier);
		printf("\n%s     column groups:   %p",              tab_depth, row->col_groups);
		printf("\n%s     column_group_n:  %u",              tab_depth, row->col_group_n);
		printf("\n%s     final_columnization:           %p", tab_depth, row->final_columnization);
		printf("\n%s     final_columnization_colorized: %p", tab_depth, row->final_columnization_colorized);
		printf("\n");

		// add display depth
		display_settings->current_display_depth++;

	}

	// now display sfs rows (censors based around displays settings)
	size_t n = 0;
	for(; n < row->col_group_n; n++)
		BP_DisplaySFSColumnGroup(row->col_groups[n], display_settings);

	// decrement the display depth on return
	if(display_settings->current_display_depth)
		display_settings->current_display_depth--;

	// return indicating success
	return ERR_SUCCESS;

}

// display a row group
BP_ERROR_T BP_DisplaySFSRowGroup
(
	P_BP_SFS_STRING_ROW_GROUP row_group,
	P_BP_SFS_INFO_DISPLAY_SETTINGS display_settings
)
{

	// ensure we have a row group and display settings
	if(!row_group || !display_settings)
		return ERR_FAILURE;

	if(display_settings->display_row_groups)
	{

		// create the tab_depth stack buffer and fill it with
		// the appropriate number of tab characters
		BP_SFS_CREATE_TAB_DEPTH_BUFFER;

		printf("\n%s [-] Row Group: (%p) - (sess: %p)",   tab_depth, row_group, row_group->session);
		printf("\n%s     identifier:    %s",              tab_depth, row_group->row_group_identifier);
		printf("\n%s     rows:          %p",              tab_depth, row_group->rows);
		printf("\n%s     row_n:         %u",              tab_depth, row_group->row_n);
		printf("\n%s     final_columnization:           %p", tab_depth, row_group->final_columnization);
		printf("\n%s     final_columnization_colorized: %p", tab_depth, row_group->final_columnization_colorized);
		printf("\n");

		// add display depth
		display_settings->current_display_depth++;

	}

	// now display sfs rows (censors based around displays settings)
	size_t n = 0;
	for(; n < row_group->row_n; n++)
		BP_DisplaySFSRow(row_group->rows[n], display_settings);


	// decrement the display depth on return
	if(display_settings->current_display_depth)
		display_settings->current_display_depth--;

	// return indicating success
	return ERR_SUCCESS;

}

// display a string formatting session
BP_ERROR_T BP_DisplayStringFormattingSession
(
		P_BP_SF_SESSION session,
		P_BP_SFS_INFO_DISPLAY_SETTINGS display_settings
)
{

	// ensure we have a session and display settings
	if(!session || !display_settings)
		return ERR_FAILURE;

	// if set, display the session header
	if(display_settings->display_session_header)
	{

		// create the tab_depth stack buffer and fill it with
		// the appropriate number of tab characters
		BP_SFS_CREATE_TAB_DEPTH_BUFFER;

		// display the formatting session header
		printf("\n%s [+] String Formatting Session: (%p)", tab_depth, session);
		printf("\n%s     tq:              %p",             tab_depth, session->tq);
		printf("\n%s     session_name:    %s",             tab_depth, session->session_name);
		printf("\n%s     row_groups:      %p",             tab_depth, session->row_groups);
		printf("\n%s     row_group_n:     %u",             tab_depth, session->row_group_n);
		printf("\n");

		// increment the display depth
		display_settings->current_display_depth++;

	}

	// iterator
	size_t n = 0;

	// Cascade into the other SFS display routines.  Subsequent display
	// of structures depends on how the user has decided to display data
	// via the display_settings structure.
	for(; n < session->row_group_n; n++)
		BP_DisplaySFSRowGroup(session->row_groups[n], display_settings);


	// trailing newline
	printf("\n");

	// reset the depth on exit
	display_settings->current_display_depth=0;

	// return indicating success
	return ERR_SUCCESS;

}


// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%% Display Final Output %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


// This routine will display final output generated and display it to the user via
// stdout.
BP_ERROR_T BP_DisplayFinalOutputSFSession(P_BP_SF_SESSION session, BP_BOOL display_colored)
{

	// ensure we have a session to display from
	if(!session)
		return ERR_FAILURE;


	if(session->final_columnization && display_colored == BP_FALSE)
	{
		BP_DisplayGenericColumnization(session->final_columnization, BP_TRUE);
	}

	if(session->final_columnization_colorized && display_colored == BP_TRUE)
	{
		BP_DisplayGenericColumnization(session->final_columnization_colorized, BP_TRUE);
	}

	// return indicating success
	return ERR_SUCCESS;

}

// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%% Formatted Output Routines %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

// These routines are used for displaying a formatted session to
// the end-user.  These routines combine all selected elements
// of a formatted display session, and allow user display.


// Generate the final output.  This output is stored in the session itself
// as:
//
// session->(char **)final_output_rows;
// session->(size_t)final_output_row_n;
//
// You should only ever have to call this routine when trying to generate
// finalized output.
BP_ERROR_T BP_GenerateFinalOutputSFSession(P_BP_SF_SESSION session)
{

	// ensure we have a session to work with
	if(!session)
		return ERR_FAILURE;

	// ensure the session has a tailqueue
	if(!session->tq)
		return ERR_FAILURE;



	if(BP_ColumnizeAllStringEntriesSFSession     (session) != ERR_SUCCESS)
		return ERR_FAILURE;

	if(BP_ColumnizeAllColumnEntriesSFSession     (session) != ERR_SUCCESS)
		return ERR_FAILURE;

	if(BP_ColumnizeAllColumnGroupEntriesSFSession(session) != ERR_SUCCESS)
		return ERR_FAILURE;

	if(BP_ColumnizeAllRowEntriesSFSession        (session) != ERR_SUCCESS)
		return ERR_FAILURE;

	if(BP_ColumnizeAllRowGroupEntriesSFSession   (session) != ERR_SUCCESS)
		return ERR_FAILURE;


	size_t row_group_n = 0;

	// declare merged values
	P_BP_GENERIC_STRING_COLUMNIZATION merged_columnizations         = NULL;
	P_BP_GENERIC_STRING_COLUMNIZATION merged_columnizations_colored = NULL;

	// allocat columnizations
	P_BP_GENERIC_STRING_COLUMNIZATION * columnizations         = (P_BP_GENERIC_STRING_COLUMNIZATION * ) bpcalloc(sizeof(P_BP_GENERIC_STRING_COLUMNIZATION) * (session->row_group_n+1), 1);
	P_BP_GENERIC_STRING_COLUMNIZATION * columnizations_colored = (P_BP_GENERIC_STRING_COLUMNIZATION * ) bpcalloc(sizeof(P_BP_GENERIC_STRING_COLUMNIZATION) * (session->row_group_n+1), 1);

	// declare borderized (final) values
	P_BP_GENERIC_STRING_COLUMNIZATION borderized_merged_columnizations         = NULL;
	P_BP_GENERIC_STRING_COLUMNIZATION borderized_merged_columnizations_colored = NULL;

	// set column index
	size_t col_idx = 0;

	// add columnizations
	for(row_group_n = 0; row_group_n < session->row_group_n; row_group_n++)
	{

		if(!session->row_groups[row_group_n])
			continue;
		if(!session->row_groups[row_group_n]->final_columnization)
			continue;

		// set the columnizations
		columnizations        [col_idx] = session->row_groups[row_group_n]->final_columnization;
		columnizations_colored[col_idx] = session->row_groups[row_group_n]->final_columnization_colorized;

		// increase the col idx
		col_idx++;
	}

	merged_columnizations         = BP_MergeGenericColumnizationsVertically(columnizations,         col_idx);
	merged_columnizations_colored = BP_MergeGenericColumnizationsVertically(columnizations_colored, col_idx);

	// borderize items
	borderized_merged_columnizations         = BP_BorderizeStringColumnization(merged_columnizations,         &session->border_set);
	borderized_merged_columnizations_colored = BP_BorderizeStringColumnization(merged_columnizations_colored, &session->border_set);

	// set merged data
	session->final_columnization           = BP_StoreColumnizationInTailQ(borderized_merged_columnizations,         session->tq, BP_TRUE);
	session->final_columnization_colorized = BP_StoreColumnizationInTailQ(borderized_merged_columnizations_colored, session->tq, BP_TRUE);

	// destroy old data
	BP_DestroyGenericColumnization(merged_columnizations,          BP_TRUE);
	BP_DestroyGenericColumnization(merged_columnizations_colored,  BP_TRUE);



	// destroy columnization stacks here
	if(columnizations)
		bpfree(columnizations);
	if(columnizations_colored)
		bpfree(columnizations_colored);

	// mark indicating that the output was prepared ok
	session->output_prepared_ok = BP_TRUE;

	// return indicating success if we were able to generate data
	return ERR_SUCCESS;

}



// walks all of the string entries, in all the columns and generates columns for
// each of them.
BP_ERROR_T BP_ColumnizeAllStringEntriesSFSession(P_BP_SF_SESSION session)
{

	// ensure we have a session and a tailqueue
	if(!session)
		return ERR_FAILURE;
	if(!session->tq)
		return ERR_FAILURE;

	// declare item iterators
	size_t row_group_n    = 0;
	size_t row_n          = 0;
	size_t column_group_n = 0;
	size_t column_n       = 0;
	size_t string_entry_n = 0;

	// this is used as a placehoder for the current entry
	P_BP_SFS_STRING_ENTRY current_entry = NULL;

	// first destroy session data if necessary
	BP_DestroyAllStringEntryColumnizedDataSFSession(session);

	// set columnizations
	P_BP_GENERIC_STRING_COLUMNIZATION * columnizations         = NULL;
	P_BP_GENERIC_STRING_COLUMNIZATION * columnizations_colored = NULL;

	// declare merged values
	P_BP_GENERIC_STRING_COLUMNIZATION merged_columnizations         = NULL;
	P_BP_GENERIC_STRING_COLUMNIZATION merged_columnizations_colored = NULL;

	// declare borderized (final) values
	P_BP_GENERIC_STRING_COLUMNIZATION borderized_merged_columnizations         = NULL;
	P_BP_GENERIC_STRING_COLUMNIZATION borderized_merged_columnizations_colored = NULL;

	// this seemingly complex logic simply iterates through each string entry recursively.  It's
	// not as complex as it looks, it's just self-indexing recursion.
	for(row_group_n = 0;    row_group_n    < session->row_group_n; row_group_n++)
	for(row_n = 0;          row_n          < session->row_groups[row_group_n]->row_n; row_n++)
	for(column_group_n = 0; column_group_n < session->row_groups[row_group_n]->rows[row_n]->col_group_n; column_group_n++)
	for(column_n = 0;       column_n       < session->row_groups[row_group_n]->rows[row_n]->col_groups[column_group_n]->columns_n; column_n++)
	for
	(
			string_entry_n = 0;
			string_entry_n < session->row_groups[row_group_n]->rows[row_n]->col_groups[column_group_n]->columns[column_n]->entries;
			string_entry_n++
	)
	{

		// set the current entry
		current_entry = session->row_groups[row_group_n]->rows[row_n]->col_groups[column_group_n]->columns[column_n]->col_data[string_entry_n];

		// ensure we have a current entry to work with (should always be the case, if not
		// things were corrupted somewhere.)
		if(!current_entry)
			break;

		// only convert items marked for display
		if(current_entry->marked_display_disabled == BP_TRUE)
			continue;

		// attempt to generate string entry columnized data (only time it's ever required)
		if(BP_GenerateOutputStringArrayFromStringEntrySFSession(session, current_entry, BP_TRUE) == ERR_FAILURE)
		{
			printf("\n Failing on: %p", current_entry);
		}

		if(!current_entry->final_columnization)
		{
			printf("\n Failed Generation of Columnization for String Entry (you're probably missing newlines you dummy): %p  - %s  - %u", current_entry, current_entry->string_entry_identifier, current_entry->string_length);

		}

		if(current_entry->final_columnization)
		{
			merged_columnizations = current_entry->final_columnization;
			current_entry->final_columnization = BP_BorderizeStringColumnization(merged_columnizations, &current_entry->border_set);
			BP_DestroyGenericColumnization(merged_columnizations,          BP_TRUE);
		}


		if(current_entry->final_columnization_colorized)
		{
			merged_columnizations_colored = current_entry->final_columnization_colorized;
			current_entry->final_columnization_colorized = BP_BorderizeStringColumnization(merged_columnizations_colored, &current_entry->border_set);
			BP_DestroyGenericColumnization(merged_columnizations_colored,  BP_TRUE);
		}



	}

	// return indicating success
	return ERR_SUCCESS;

}

// Then call this.
BP_ERROR_T BP_ColumnizeAllColumnEntriesSFSession(P_BP_SF_SESSION session)
{


	// ensure we have a session and a tailqueue
	if(!session)
		return ERR_FAILURE;
	if(!session->tq)
		return ERR_FAILURE;

	// row iterator for generating buffers below
	size_t n = 0;

	// secondary row iterator, for adding strings into the column
	// buffer.
	size_t j = 0;

	// secondary iterator for colorized items
	size_t x = 0;

	// declare item iterators
	size_t row_group_n    = 0;
	size_t row_n          = 0;
	size_t column_group_n = 0;
	size_t column_n       = 0;
	size_t string_entry_n = 0;

	// this is used as a placehoder for the current entry
	P_BP_SFS_STRING_ENTRY current_string_entry = NULL;
	P_BP_SFS_STRING_COLUMN current_column      = NULL;

	// widest entry items
	size_t widest_entry_idx = 0;
	size_t widest_entry_len = 0;

	// widest entry colorized items
	size_t widest_entry_colorized_idx = 0;
	size_t widest_entry_colorized_len = 0;

	// this stores how many rows are in all entries for a column
	size_t total_rows           = 0;
	size_t total_rows_colorized = 0;

	// set columnizations
	P_BP_GENERIC_STRING_COLUMNIZATION * columnizations         = NULL;
	P_BP_GENERIC_STRING_COLUMNIZATION * columnizations_colored = NULL;

	// declare merged values
	P_BP_GENERIC_STRING_COLUMNIZATION merged_columnizations         = NULL;
	P_BP_GENERIC_STRING_COLUMNIZATION merged_columnizations_colored = NULL;

	// declare borderized (final) values
	P_BP_GENERIC_STRING_COLUMNIZATION borderized_merged_columnizations         = NULL;
	P_BP_GENERIC_STRING_COLUMNIZATION borderized_merged_columnizations_colored = NULL;
	//fix

	// this seemingly complex logic simply iterates through each string entry recursively.  It's
	// not as complex as it looks, it's just self-indexing recursion.
	for(row_group_n = 0;    row_group_n    < session->row_group_n; row_group_n++)
	for(row_n = 0;          row_n          < session->row_groups[row_group_n]->row_n; row_n++)
	for(column_group_n = 0; column_group_n < session->row_groups[row_group_n]->rows[row_n]->col_group_n; column_group_n++)
	for(column_n = 0;       column_n       < session->row_groups[row_group_n]->rows[row_n]->col_groups[column_group_n]->columns_n; column_n++)
	{



		// set current column
		current_column = session->row_groups[row_group_n]->rows[row_n]->col_groups[column_group_n]->columns[column_n];
		if(!current_column)
			continue;


		// reset string entry pointer on loop
		current_string_entry = NULL;

		// allocate space to store columnizations
		columnizations         = (P_BP_GENERIC_STRING_COLUMNIZATION * ) bpcalloc(sizeof(P_BP_GENERIC_STRING_COLUMNIZATION) * (current_column->entries+1), 1);
		columnizations_colored = (P_BP_GENERIC_STRING_COLUMNIZATION * ) bpcalloc(sizeof(P_BP_GENERIC_STRING_COLUMNIZATION) * (current_column->entries+1), 1);

		// walk strings first to precalculate lengths before copying in data
		for	(string_entry_n = 0;string_entry_n < current_column->entries;string_entry_n++)
		{

			// set current string entry
			current_string_entry = session->row_groups[row_group_n]->rows[row_n]->col_groups[column_group_n]->columns[column_n]->col_data[string_entry_n];
			if(!current_string_entry)
				continue;

			// set entries here
			columnizations        [string_entry_n] = current_string_entry->final_columnization;
			columnizations_colored[string_entry_n] = current_string_entry->final_columnization_colorized;

		}

		// merge values vertically
		merged_columnizations         = BP_MergeGenericColumnizationsVertically(columnizations,         current_column->entries);
		merged_columnizations_colored = BP_MergeGenericColumnizationsVertically(columnizations_colored, current_column->entries);

		// borderize items
		borderized_merged_columnizations         = BP_BorderizeStringColumnization(merged_columnizations,         &current_column->border_set);
		borderized_merged_columnizations_colored = BP_BorderizeStringColumnization(merged_columnizations_colored, &current_column->border_set);

		// set merged data
		current_column->final_columnization           = BP_StoreColumnizationInTailQ(borderized_merged_columnizations, session->tq, BP_TRUE);
		current_column->final_columnization_colorized = BP_StoreColumnizationInTailQ(borderized_merged_columnizations_colored, session->tq,  BP_TRUE);

		// destroy old data
		BP_DestroyGenericColumnization(merged_columnizations,          BP_TRUE);
		BP_DestroyGenericColumnization(merged_columnizations_colored,  BP_TRUE);

		if(columnizations)
			bpfree(columnizations);
		if(columnizations_colored)
			bpfree(columnizations_colored);


		// current_column->final_columnization           = merged_columnizations;
		// current_column->final_columnization_colorized = merged_columnizations_colored;

		// BP_DisplayGenericColumnization(current_column->final_columnization);
		// BP_DisplayGenericColumnization(current_column->final_columnization_colorized);

	}


	// exit here
	return ERR_SUCCESS;

}

// Then call this.
BP_ERROR_T BP_ColumnizeAllColumnGroupEntriesSFSession(P_BP_SF_SESSION session)
{


	// ensure we have a session and a tailqueue
	if(!session)
		return ERR_FAILURE;
	if(!session->tq)
		return ERR_FAILURE;

	// row iterator for generating buffers below
	size_t n = 0;

	// secondary row iterator, for adding strings into the column
	// buffer.
	size_t j = 0;

	// secondary iterator for colorized items
	size_t x = 0;

	// declare item iterators
	size_t row_group_n    = 0;
	size_t row_n          = 0;
	size_t column_group_n = 0;
	size_t column_n       = 0;
	size_t string_entry_n = 0;

	// this is used as a placehoder for the current entry
	P_BP_SFS_STRING_COLUMN_GROUP current_column_group_entry = NULL;
	P_BP_SFS_STRING_COLUMN       current_column_entry      = NULL;


	// set columnizations
	P_BP_GENERIC_STRING_COLUMNIZATION * columnizations         = NULL;
	P_BP_GENERIC_STRING_COLUMNIZATION * columnizations_colored = NULL;

	// declare merged values
	P_BP_GENERIC_STRING_COLUMNIZATION merged_columnizations         = NULL;
	P_BP_GENERIC_STRING_COLUMNIZATION merged_columnizations_colored = NULL;


	// declare borderized (final) values
	P_BP_GENERIC_STRING_COLUMNIZATION borderized_merged_columnizations         = NULL;
	P_BP_GENERIC_STRING_COLUMNIZATION borderized_merged_columnizations_colored = NULL;
	//fix

	// this seemingly complex logic simply iterates through each string entry recursively.  It's
	// not as complex as it looks, it's just self-indexing recursion.
	for(row_group_n = 0;    row_group_n    < session->row_group_n; row_group_n++)
	for(row_n = 0;          row_n          < session->row_groups[row_group_n]->row_n; row_n++)
	for(column_group_n = 0; column_group_n < session->row_groups[row_group_n]->rows[row_n]->col_group_n; column_group_n++)
	{

		// set current column group entry
		current_column_group_entry = session->row_groups[row_group_n]->rows[row_n]->col_groups[column_group_n];
		if(!current_column_group_entry)
			continue;


		// allocate space to store columnizations
		columnizations         = (P_BP_GENERIC_STRING_COLUMNIZATION * ) bpcalloc(sizeof(P_BP_GENERIC_STRING_COLUMNIZATION) * (current_column_group_entry->columns_n+1), 1);
		columnizations_colored = (P_BP_GENERIC_STRING_COLUMNIZATION * ) bpcalloc(sizeof(P_BP_GENERIC_STRING_COLUMNIZATION) * (current_column_group_entry->columns_n+1), 1);

		// the real count for columnizations
		size_t columnization_count = 0;

		// calculate longest line first by looping through each entry
		for(column_n = 0; column_n < current_column_group_entry->columns_n; column_n++)
		{

			// set the column entry from the current index
			current_column_entry = current_column_group_entry->columns[column_n];

			// run checks against current column members
			if(!current_column_entry)
				continue;
			if(!current_column_entry->final_columnization)
				continue;
			if(!current_column_entry->final_columnization_colorized)
				continue;


			// set entries here
			columnizations        [columnization_count] = current_column_entry->final_columnization;
			columnizations_colored[columnization_count] = current_column_entry->final_columnization_colorized;

			columnization_count++;
		}

		if(columnization_count)
		{

			/*
			// merge values vertically
			merged_columnizations         = BP_MergeGenericColumnizationsHorizontally(columnizations,         columnization_count);
			merged_columnizations_colored = BP_MergeGenericColumnizationsHorizontally(columnizations_colored, columnization_count);
			*/


			// merge values vertically
			merged_columnizations         = BP_MergeGenericColumnizationsHorizontally(columnizations,         columnization_count);
			merged_columnizations_colored = BP_MergeGenericColumnizationsHorizontally(columnizations_colored, columnization_count);

			// borderize items
			borderized_merged_columnizations         = BP_BorderizeStringColumnization(merged_columnizations,         &current_column_group_entry->border_set);
			borderized_merged_columnizations_colored = BP_BorderizeStringColumnization(merged_columnizations_colored, &current_column_group_entry->border_set);

			// set merged data
			current_column_group_entry->final_columnization           = BP_StoreColumnizationInTailQ(borderized_merged_columnizations, session->tq, BP_TRUE);
			current_column_group_entry->final_columnization_colorized = BP_StoreColumnizationInTailQ(borderized_merged_columnizations_colored, session->tq,  BP_TRUE);

			// destroy old data
			BP_DestroyGenericColumnization(merged_columnizations,          BP_TRUE);
			BP_DestroyGenericColumnization(merged_columnizations_colored,  BP_TRUE);

			// set merged data
			// current_column_group_entry->final_columnization           = merged_columnizations;
			// current_column_group_entry->final_columnization_colorized = merged_columnizations_colored;

			// BP_DisplayGenericColumnization(current_column_group_entry->final_columnization);
			// BP_DisplayGenericColumnization(current_column_group_entry->final_columnization_colorized);

		}


		if(columnizations)
			bpfree(columnizations);
		if(columnizations_colored)
			bpfree(columnizations_colored);



	}

	// return indicating success
	return ERR_SUCCESS;

}

// Then call this.
BP_ERROR_T BP_ColumnizeAllRowEntriesSFSession(P_BP_SF_SESSION session)
{


	// ensure we have a session and a tailqueue
	if(!session)
		return ERR_FAILURE;
	if(!session->tq)
		return ERR_FAILURE;

	// row iterator for generating buffers below
	size_t n = 0;

	// secondary row iterator, for adding strings into the column
	// buffer.
	size_t j = 0;

	// secondary iterator for colorized items
	size_t x = 0;

	// declare item iterators
	size_t row_group_n    = 0;
	size_t row_n          = 0;
	size_t column_group_n = 0;
	size_t column_n       = 0;
	size_t string_entry_n = 0;

	// this is used as a placehoder for the current entry
	P_BP_SFS_STRING_COLUMN_GROUP current_column_group_entry = NULL;
	P_BP_SFS_STRING_ROW          current_column_row_entry   = NULL;


	// set columnizations
	P_BP_GENERIC_STRING_COLUMNIZATION * columnizations         = NULL;
	P_BP_GENERIC_STRING_COLUMNIZATION * columnizations_colored = NULL;

	// declare merged values
	P_BP_GENERIC_STRING_COLUMNIZATION merged_columnizations         = NULL;
	P_BP_GENERIC_STRING_COLUMNIZATION merged_columnizations_colored = NULL;


	// declare borderized (final) values
	P_BP_GENERIC_STRING_COLUMNIZATION borderized_merged_columnizations         = NULL;
	P_BP_GENERIC_STRING_COLUMNIZATION borderized_merged_columnizations_colored = NULL;
		//fix

	// this seemingly complex logic simply iterates through each string entry recursively.  It's
	// not as complex as it looks, it's just self-indexing recursion.
	for(row_group_n = 0;    row_group_n    < session->row_group_n;                    row_group_n++)
	for(row_n = 0;          row_n          < session->row_groups[row_group_n]->row_n; row_n++)
	{

		// set column row entry
		current_column_row_entry = session->row_groups[row_group_n]->rows[row_n];
		if(!current_column_row_entry)
			continue;

		// allocate space to store columnizations
		columnizations         = (P_BP_GENERIC_STRING_COLUMNIZATION * ) bpcalloc(sizeof(P_BP_GENERIC_STRING_COLUMNIZATION) * (current_column_row_entry->col_group_n+1), 1);
		columnizations_colored = (P_BP_GENERIC_STRING_COLUMNIZATION * ) bpcalloc(sizeof(P_BP_GENERIC_STRING_COLUMNIZATION) * (current_column_row_entry->col_group_n+1), 1);

		// the real count for columnizations
		size_t columnization_count = 0;


		for(column_group_n = 0; column_group_n < current_column_row_entry->col_group_n; column_group_n++)
		{

			// set current column group entry
			current_column_group_entry = current_column_row_entry->col_groups[column_group_n];
			if(!current_column_group_entry)
				break;
			if(!current_column_group_entry->final_columnization)
				break;

			// set entries here
			columnizations        [columnization_count] = current_column_group_entry->final_columnization;
			columnizations_colored[columnization_count] = current_column_group_entry->final_columnization_colorized;

			columnization_count++;
		}

		if(columnization_count)
		{

			// merge values vertically
			merged_columnizations         = BP_MergeGenericColumnizationsHorizontally(columnizations,         columnization_count);
			merged_columnizations_colored = BP_MergeGenericColumnizationsHorizontally(columnizations_colored, columnization_count);

			// borderize items
			borderized_merged_columnizations         = BP_BorderizeStringColumnization(merged_columnizations,         &current_column_row_entry->border_set);
			borderized_merged_columnizations_colored = BP_BorderizeStringColumnization(merged_columnizations_colored, &current_column_row_entry->border_set);


			// set merged data
			current_column_row_entry->final_columnization           = BP_StoreColumnizationInTailQ(borderized_merged_columnizations, session->tq, BP_TRUE);
			current_column_row_entry->final_columnization_colorized = BP_StoreColumnizationInTailQ(borderized_merged_columnizations_colored, session->tq, BP_TRUE);

			// destroy old data
			BP_DestroyGenericColumnization(merged_columnizations,          BP_TRUE);
			BP_DestroyGenericColumnization(merged_columnizations_colored,  BP_TRUE);

			// BP_DisplayGenericColumnization(current_column_row_entry->final_columnization);
			// BP_DisplayGenericColumnization(current_column_row_entry->final_columnization_colorized);

		}


		if(columnizations)
			bpfree(columnizations);
		if(columnizations_colored)
			bpfree(columnizations_colored);


	}


	// return indicating success
	return ERR_SUCCESS;

}

// Then call this.
BP_ERROR_T BP_ColumnizeAllRowGroupEntriesSFSession(P_BP_SF_SESSION session)
{


	// ensure we have a session and a tailqueue
	if(!session)
		return ERR_FAILURE;
	if(!session->tq)
		return ERR_FAILURE;

	// declare item iterators
	size_t row_group_n    = 0;
	size_t row_n          = 0;

	// this is used as a placehoder for the current entry
	P_BP_SFS_STRING_ROW_GROUP    current_column_row_group_entry = NULL;
	P_BP_SFS_STRING_ROW          current_column_row_entry       = NULL;

	// set columnizations
	P_BP_GENERIC_STRING_COLUMNIZATION * columnizations         = NULL;
	P_BP_GENERIC_STRING_COLUMNIZATION * columnizations_colored = NULL;

	// declare merged values
	P_BP_GENERIC_STRING_COLUMNIZATION merged_columnizations         = NULL;
	P_BP_GENERIC_STRING_COLUMNIZATION merged_columnizations_colored = NULL;

	// declare borderized (final) values
	P_BP_GENERIC_STRING_COLUMNIZATION borderized_merged_columnizations         = NULL;
	P_BP_GENERIC_STRING_COLUMNIZATION borderized_merged_columnizations_colored = NULL;


	// this seemingly complex logic simply iterates through each string entry recursively.  It's
	// not as complex as it looks, it's just self-indexing recursion.
	for(row_group_n = 0;    row_group_n    < session->row_group_n;                    row_group_n++)
	{


		// set column row entry
		current_column_row_group_entry = session->row_groups[row_group_n];
		if(!current_column_row_group_entry)
			continue;

		// printf("\n ROW GROUP ROW GROUP ROW GROUP: %s", current_column_row_group_entry->row_group_identifier);

		// allocate space to store columnizations
		columnizations         = (P_BP_GENERIC_STRING_COLUMNIZATION * ) bpcalloc(sizeof(P_BP_GENERIC_STRING_COLUMNIZATION) * (current_column_row_group_entry->row_n+1), 1);
		columnizations_colored = (P_BP_GENERIC_STRING_COLUMNIZATION * ) bpcalloc(sizeof(P_BP_GENERIC_STRING_COLUMNIZATION) * (current_column_row_group_entry->row_n+1), 1);

		// the real count for columnizations
		size_t columnization_count = 0;

		// walk individual rows
		for(row_n = 0; row_n < current_column_row_group_entry->row_n; row_n++)
		{


			// set current column group entry
			current_column_row_entry = current_column_row_group_entry->rows[row_n];
			if(!current_column_row_entry)
				continue;
			if(!current_column_row_entry->final_columnization)
				continue;


			// set entries here
			columnizations        [columnization_count] = current_column_row_entry->final_columnization;
			columnizations_colored[columnization_count] = current_column_row_entry->final_columnization_colorized;

			// set columnization count here
			columnization_count++;

		}


		if(columnization_count)
		{

			// merge values vertically
			merged_columnizations         = BP_MergeGenericColumnizationsVertically(columnizations,         columnization_count);
			merged_columnizations_colored = BP_MergeGenericColumnizationsVertically(columnizations_colored, columnization_count);

			// borderize items
			borderized_merged_columnizations         = BP_BorderizeStringColumnization(merged_columnizations,           &current_column_row_group_entry->border_set);
			borderized_merged_columnizations_colored = BP_BorderizeStringColumnization(merged_columnizations_colored, &current_column_row_group_entry->border_set);

			// set merged data
			current_column_row_group_entry->final_columnization           = BP_StoreColumnizationInTailQ(borderized_merged_columnizations, session->tq, BP_TRUE);
			current_column_row_group_entry->final_columnization_colorized = BP_StoreColumnizationInTailQ(borderized_merged_columnizations_colored, session->tq, BP_TRUE);

			// destroy old data
			BP_DestroyGenericColumnization(merged_columnizations,          BP_TRUE);
			BP_DestroyGenericColumnization(merged_columnizations_colored,  BP_TRUE);

			// BP_DisplayGenericColumnization(current_column_row_group_entry->final_columnization);
			// BP_DisplayGenericColumnization(current_column_row_group_entry->final_columnization_colorized);

		}


		if(columnizations)
			bpfree(columnizations);
		if(columnizations_colored)
			bpfree(columnizations_colored);


	}


	// return indicating success
	return ERR_SUCCESS;

}


// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%% Clean up routines for columization routines %%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


// Simply destroys the data within the non_colorized_final_ouptut and colorized_final_output data
// stored in each individual string entry.  This is mainly a utility routine and probably shouldn't
// be used directly.
BP_ERROR_T BP_DestroyAllStringEntryColumnizedDataSFSession(P_BP_SF_SESSION session)
{

	// ensure we have a session and a tailqueue
	if(!session)
		return ERR_FAILURE;
	if(!session->tq)
		return ERR_FAILURE;

	// this is a generic iterator used for moving through individual
	// lines in the colorized/noncolorized string entry members.
	size_t n = 0;

	// declare item iterators
	size_t row_group_n    = 0;
	size_t row_n          = 0;
	size_t column_group_n = 0;
	size_t column_n       = 0;
	size_t string_entry_n = 0;

	// this is used as a placehoder for the current entry
	P_BP_SFS_STRING_ENTRY current_entry = NULL;

	// this seemingly complex logic simply iterates through each string entry recursively.  It's
	// not as complex as it looks, it's just self-indexing recursion.
	for(row_group_n = 0;    row_group_n    < session->row_group_n; row_group_n++)
	for(row_n = 0;          row_n          < session->row_groups[row_group_n]->row_n; row_n++)
	for(column_group_n = 0; column_group_n < session->row_groups[row_group_n]->rows[row_n]->col_group_n; column_group_n++)
	for(column_n = 0;       column_n       < session->row_groups[row_group_n]->rows[row_n]->col_groups[column_group_n]->columns_n; column_n++)
	for
	(
			string_entry_n = 0;
			string_entry_n < session->row_groups[row_group_n]->rows[row_n]->col_groups[column_group_n]->columns[column_n]->entries;
			string_entry_n++
	)
	{

		current_entry = session->row_groups[row_group_n]->rows[row_n]->col_groups[column_group_n]->columns[column_n]->col_data[string_entry_n];

		if(!current_entry)
			continue;
		if(!current_entry->final_columnization)
			continue;

		// destroy columnizations
		if(current_entry->final_columnization)
			BP_DestroyGenericColumnization(current_entry->final_columnization, BP_TRUE);
		if(current_entry->final_columnization_colorized)
			BP_DestroyGenericColumnization(current_entry->final_columnization_colorized, BP_TRUE);

		// nullify pointers
		current_entry->final_columnization           = NULL;
		current_entry->final_columnization_colorized = NULL;

	}

	// return indicating success
	return ERR_SUCCESS;

}




// Simple routine to display a string entry.  Mostly used for just displaying a simple
// colorized buffer without regard to any column / sfs session data.  Usually done for
// debugging purposes.
BP_ERROR_T BP_OutputStringEntryAsIsWithoutColumnization(P_BP_SFS_STRING_ENTRY entry)
{

	// ensure we have an entry
	if(!entry)
		return ERR_FAILURE;
	if(!entry->string || !entry->string_length)
		return ERR_FAILURE;

	// walk entries and display each character in the color specified
	size_t n = 0;
	for(; n < entry->string_length; n++)
		BP_printfVTColor("%c", entry->string[n].color_info.fg, entry->string[n].color_info.bg, entry->string[n].character);

	// return indicating success
	return ERR_SUCCESS;

}

// Generate an output data from string entry.  The data is stored directly within
// the string entry itself.
BP_ERROR_T BP_GenerateOutputStringArrayFromStringEntrySFSession(P_BP_SF_SESSION sfs, P_BP_SFS_STRING_ENTRY entry, BP_BOOL enable_colorization)
{

	// ensure relevant data portions are set
	if(!sfs)
		return ERR_FAILURE;
	if(!sfs->tq)
		return ERR_FAILURE;
	if(!entry)
		return ERR_FAILURE;
	if(!entry->string || !entry->string_length)
		return ERR_FAILURE;


	// allocate a simple buffer to hold the initial string
	char * initial_string = (char *) NULL;

	// color set to use for painting the buffer
	P_BP_COLOR_CODE_SET_T * colors = NULL;



	// the initial buffer should be the string length, but only in the
	// case that the string length is longer than the specified display length.  If
	// this is not the case, we'll have to padd the entry with spaces to ensure that
	// display buffers line up correctly.
	if(entry->string_length > entry->display_max_width)
	{

		// allocate memory
		initial_string        = (char *) bpcalloc(entry->string_length+1, 1);

		// allocate space for colors REFERENCE array (do not free individual elements,
		// only free the entire array)
		colors = (P_BP_COLOR_CODE_SET_T *) bpcalloc
		(
			sizeof(P_BP_COLOR_CODE_SET_T *) * (entry->string_length + 1),
			1
		);


	}
	else
	{


		// allocate space for initial string
		initial_string        = (char *) bpcalloc(entry->display_max_width+1, 1);

		// set buffer to all spaces except for terminator (allows buffers to become
		// the correct depth with regard to padding)
		memset(initial_string, 0x20, entry->display_max_width);

		// allocate space for colors REFERENCE array (do not free individual elements,
		// only free the entire array)
		colors = (P_BP_COLOR_CODE_SET_T *) bpcalloc
		(
			sizeof(P_BP_COLOR_CODE_SET_T *) * (entry->display_max_width+1),
			1
		);
	}

	// ensure we could create the initial string
	if(!initial_string)
		return ERR_FAILURE;
	if(!colors)
		return ERR_FAILURE;


	// walk the entries in the string to generate a complete buffer
	size_t n = 0;
	for(; n < entry->string_length; n++)
	{
		initial_string[n] =   entry->string[n].character;
		colors[n]         =  &entry->string[n].color_info;
	}


	// colorization index
	size_t j = 0;

	// normalization index
	size_t i = 0;

	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	// %%% Generate Colorized Data %%%%%%%%%%%%%%%%%%%%%%%%%%
	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


	P_BP_GENERIC_STRING_COLUMNIZATION tmp_lines_colorized_columnization = NULL;
	P_BP_GENERIC_STRING_COLUMNIZATION tmp_lines_columnization           = NULL;

	// generate colorized data first
	if(enable_colorization == BP_TRUE)
	{

		// allocate space for the colors
		if(entry->auto_calculate_max_width_by_newlines == BP_TRUE)
		{

			// if we're splitting by newlines, do so here
			tmp_lines_colorized_columnization = BP_SplitStringIntoEqualWidthColumnsByDeliniation
			(
				 initial_string,
				 bpstrlen(initial_string),
				 '\n',
				 0,
				 colors
			 );



			// set entry
			entry->final_columnization_colorized = tmp_lines_colorized_columnization;

		}
		else
		{

			// if we're not splitting by deliniation, split by width (enable hyphenation)
			tmp_lines_colorized_columnization = BP_SplitStringIntoEqualWidthColumns
			(
				initial_string,
				bpstrlen(initial_string),
				entry->display_max_width,
				BP_TRUE,
				entry->pad_lines_below,
				colors
			);

			/* some debug statements if you need them at a later date

			if(tmp_lines_colorized_columnization)
				printf("\n [%s] WATTT", tmp_lines_colorized_columnization->columns[0]);
			else
				printf("\n [%s] FAILED", initial_string);
			*/

			entry->final_columnization_colorized = tmp_lines_colorized_columnization;

		}

	}

	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	// %%% Generate Non-Colorized Data %%%%%%%%%%%%%%%%%%%%%%
	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	if(entry->auto_calculate_max_width_by_newlines == BP_TRUE)
	{

		// if we're splitting by newlines, do so here
		tmp_lines_columnization = BP_SplitStringIntoEqualWidthColumnsByDeliniation
		(
			 initial_string,
			 bpstrlen(initial_string),
			 '\n',
			 0
		 );

		// set uncolored final columnization
		entry->final_columnization = tmp_lines_columnization;


	}
	else
	{

		// if we're not splitting by deliniation, split by width (enable hyphenation)
		tmp_lines_columnization = BP_SplitStringIntoEqualWidthColumns
		(
			initial_string,
			bpstrlen(initial_string),
			entry->display_max_width,
			BP_TRUE,
			entry->pad_lines_below
		);

		// set uncolored final columnization
		entry->final_columnization = tmp_lines_columnization;


	}

	if(initial_string)
		bpfree(initial_string);

	if(colors)
		bpfree(colors);

	// return the filled in array
	return ERR_SUCCESS;

}



// Formatted row.  If output_only is set to BP_TRUE, no formatted
// buffer is returned.  If it is set to BP_TRUE, the formatted value is returned
// as a pointer.  Erroneous conditions are returned as a null value.  The upside
// to outputting directly is that the buffer formatted won't be stored in memory
// except for one row at a time.
char ** BP_FormatRowForOutputSFSSession
(
	P_BP_SF_SESSION session,
	P_BP_SFS_STRING_ROW row,
	BP_BOOL output_only
)
{

	// ensure we have a session
	if(!session)
		return NULL;

	// ensure we have a row
	if(row)
		return NULL;

	// ensure the row has column groups
	if(!row->col_group_n)
		return NULL;

	// ensure we have columns
	if(!row->col_groups[0]->columns_n)
		return NULL;

	if(!row->col_groups[0]->columns[0]->entries)
		return NULL;

	char **output_buffer = NULL;


	// return the output buffer
	return output_buffer;

}


// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%% Utility Routines %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

// counts the number of string entries in the row
size_t BP_CountNumberOfStringEntriesInRowSFSession(P_BP_SFS_STRING_ROW row)
{

	if(!row)
		return ERR_FAILURE;

	// entry count to return
	size_t entry_count = 0;

	// iterators for navigating the row
	size_t column_group_n = 0;
	size_t column_n = 0;

	// calculate entry count
	for(; column_group_n < row->col_group_n; column_group_n++)
		for(column_n = 0; column_n < row->col_groups[column_group_n]->columns_n; column_n++)
			entry_count+=row->col_groups[column_group_n]->columns[column_n]->entries;


	// return the final count
	return entry_count;


}

// Get the max width for a row.  This is primarily utilized to generate lines
// for the output buffer.
size_t BP_GetRowMaxWidthOfAllStringEntriesSFSession(P_BP_SFS_STRING_ROW row)
{

	// this will be returned to the user
	size_t max_width = 0;

	// iterators for navigating the row
	size_t column_group_n = 0;
	size_t column_n       = 0;
	size_t entry_n        = 0;
	size_t max_row_width  = 0;

	// this is used
	char ** deliniated_rows = NULL;

	// reference to add readability to the manipulations below
	P_BP_SFS_STRING_ENTRY current_entry = NULL;

	// calculate entry count
	for(; column_group_n < row->col_group_n; column_group_n++)
	for(column_n = 0; column_n < row->col_groups[column_group_n]->columns_n; column_n++)
	for(entry_n = 0; entry_n < row->col_groups[column_group_n]->columns[column_n]->entries; entry_n++)
	{

		// set current entry
		current_entry = row->col_groups[column_group_n]->columns[column_n]->col_data[entry_n];

		// calculate by newlines
		if(current_entry->auto_calculate_max_width_by_newlines)
		{

		}

	}


	// return the width
	return max_width;

}
