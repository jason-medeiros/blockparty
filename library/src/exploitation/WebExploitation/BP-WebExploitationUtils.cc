/*
 * BP-WebExploitationUtils.cc
 *
 *  Created on: Apr 4, 2009
 *      Author: root
 */

#include "../../../include/BP-Main.h"


// Returns the length from the start of haystack, till the beginning of needle
size_t BP_GetLengthTillMatch(char *haystack, char *needle, size_t needleLen){

	// Null checks
	if(!haystack || !needle)
		return 0;


	size_t haystackLen = bpstrlen(haystack);

	// verify that the needle is actually in the haystack (saftey check)
	if(!memmem(haystack, bpstrlen(haystack), needle, needleLen)){
		return 0;
	}

	// iterator / size var
	size_t x = 0;

	// calculate and return the length
	for(x = 0; memcmp(&haystack[x], needle, needleLen) != 0  && x < haystackLen; x++)
	{}

	return x;
}

// Prints a line till \n is encountered, must be null terminated
void BP_PrintLine(char *buff){

	// iterator
	size_t i;
	for(i = 0; buff[i] != '\0' && buff[i] != '\n' && buff[i] != '\r'; i++)
	{
		printf("%c", buff[i]);
	}
}


// Subtracts heap pointers when used with MemMem (do not use except on local buffers
// or results can be INACCURATE)
size_t BP_SubtractHeapSearches(void *larger, void * smaller){

	if(!larger || !smaller)
		return 0;

	return (size_t) larger - (size_t) smaller;

}



// Transforms a character string %20s in it to a string with ' ' instead.
// must be bpfree'd if unused.
char * BP_GenNonUnicodeSpaceString(char *inStr, size_t len){

	size_t origLen = 0;
	size_t newLen  = 0;

	// replacement will always be shorter, same alloc ok
	char *outStr = (char *) bpcalloc(len+5, 1);
	if(!outStr)
		return NULL;

	// Walk the string
	for(origLen = 0;origLen < len;){
		switch(inStr[origLen]){
			case '%':
				if(memcmp(&inStr[origLen], "%20", 3) == 0){
					outStr[newLen] = ' ';
					// new string grows by 1
					newLen++;

					// orig string grows by 3 (past %20)
					origLen += 3;
				}

				break;
			default:
				outStr[newLen] = inStr[origLen];
				newLen++;
				origLen++;
				break;
		}

	}

	return outStr;
}

// converse of above, returns a newly allocated string with %20s instead of ' ' (used for making requests)
// NOTE: Curl requests dont do well with ' ' in them, in fact, it terminates them.. request must use %20
char * BP_GenUnicodeSpaceString(char *inStr, size_t len){

	size_t origLen = 0;
	size_t newLen  = 0;

	// replacement cant ever be > len*3
	char *outStr = (char *) bpcalloc(len*3+6, 1);
	if(!outStr)
		return NULL;

	// Walk the string
	for(origLen = 0;origLen < len;){

		switch(inStr[origLen]){

			case ' ':

				// copy in replacement characters
				memcpy(&outStr[newLen], "%20", 3);

				// new string grows by 1
				newLen += 3;

				// orig string grows by 3 (past %20)
				origLen += 1;
				break;

			default:
				outStr[newLen] = inStr[origLen];
				newLen++;
				origLen++;
				break;
		}

	}

	return outStr;
}


// Attempts to find the path (without script or parameters) of a given url
// primarily for the purpose of building targets. Returned string is a heap
// duplicate (bpstrdup) which must be bpfreed. The base_specifier parameter should
// be set to one of the following values:

// 0 = absolute base (eg: www.google.com/ from url www.google.com/test/whatever
// 1 = last path     (eg: www.google.com/test/ from url www.google.com/test/whatever

char * BP_ParseURLToPath(char * url, size_t base_specifier)
{

	// check to ensure that the url exists
	if(!url)
		return NULL;

	// duplicate string before modifications are made
	char * reformatted_str = (char *) bpcalloc(bpstrlen(url) + 500, 1);
	if(!reformatted_str)
		return NULL;

	// embed url
	sprintf(reformatted_str, "%s", url);

	// save string length for loop operations
	size_t len = bpstrlen(reformatted_str);

	// loop iterator for moving through char array
	size_t i = 0;

	// switch on the base specifier
	switch(base_specifier)
	{
		// seperate to base path
		case 0:

			// remove parameters first by nulling out ?
			for(i = 0; i < len; i++)
			{
				if(reformatted_str[i] == '?')
					reformatted_str[i] = (char) 0x00;

			}

			// now find the first / in the url that isn't ://
			for(i = 0; i < len; i++)
			{
				// look for base path, and null out +1 in the case that its found
				if(reformatted_str[i]   == '/')
				if(reformatted_str[i+1] != '/')
				if(reformatted_str[i-1] != '/')
				{
					reformatted_str[i+1] = (char) 0x00;
					break;
				}

			}

			// now walk forward down the string
			break;

		// seperate to last path
		case 1:

			// remove parameters first by nulling out ?
			for(i = 0; i < len; i++)
			{
				if(reformatted_str[i] == '?')
					reformatted_str[i] = (char) 0x00;
			}

			// get the revised string length with no parameters
			len = bpstrlen(reformatted_str);

			// now find the first / in the url that isn't ://
			for(i = len; i > 0; i--)
			{
				// look for base path, and null out +1 in the case that its found
				if(reformatted_str[i]   == '/')
				if(reformatted_str[i+1] != '/')
				if(reformatted_str[i-1] != '/')
				{
					reformatted_str[i+1] = (char) 0x00;
					break;
				}

			}

			break;

		// return the unformatted duplicate string on return (idk why, seems reasonable)
		default:
			return reformatted_str;

	}


	// make sure it tails with a / at this point
	if(reformatted_str[bpstrlen(reformatted_str)-1] != '/')
		reformatted_str[bpstrlen(reformatted_str)] = '/';

	// printf("\n WTF GOT REFORMATTED STRING?: %s", reformatted_str);

	// return with the modified string
	return reformatted_str;

}

// Converse to parseurltopath.  Simply parses a url and returns a duplicated
// string that contains the script portion of a url.
//
// Example: path_flag = 0
//    www.google.com/whatever/somethng/blah.txt?1=2&3=4
//    - is returned as-
//    blah.txt?1=2&3=4
//
// Example: path_flah = 1
//    www.google.com/whatever/something/blah.txt?1=2&3=4
//    - is returned as -
//    whatever/something/blah.txt?1=2&3=4
char * BP_ParseURLToScript(char * url, size_t path_flag, size_t remove_params)
{

	// check to ensure that the url exists
	if(!url)
		return NULL;

	// trick to detect if the string being input starts at a
	// parameter marker (aka. ?).  If so, and we are marked to remove
	// those markers, simply return an empty duplicated string.
	if(url && remove_params)
	if(url[0] == '?')
		return bpstrdup("");

	char * front_str = NULL;
	if(path_flag == 1)
	{
		// duplicate string before modifications are made
		front_str = BP_ParseURLToPathPCRE(url);
		if(!front_str)
			return NULL;
	}
	else
	{
		front_str = BP_ParseURLToPathPCRE(url);
		if(!front_str)
			return NULL;
	}

	// get the revised string length with no parameters
	size_t offs_len = bpstrlen(front_str);

	// create return string
	char *ret_str = bpstrdup((char *) &front_str[offs_len]);

	// destroy the front of the string used for gathering an offset
	if(front_str)
	{
		bpfree(front_str);
		front_str = NULL;
	}

	if(remove_params)
	{
		size_t x = 0;
		for(; ret_str[x] != '\0'; x++ )
		{
			if(ret_str[x] == '?')
			{
				ret_str[x] = 0x00;
				break;
			}
		}
	}

	// return correct string
	return ret_str;

}

// Version of BP_BarseURLToScript that operates on
// relative links.  See examples below.
//
// Example: path_flag = 0
//    whatever/somethng/blah.txt?1=2&3=4
//    - is returned as-
//    blah.txt?1=2&3=4
//
// Example: path_flah = 1
//    www.google.com/whatever/something/blah.txt?1=2&3=4
//    - is returned as -
//    whatever/something/blah.txt?1=2&3=4
char * BP_ParseRelativeLinkToScript(char *relative_url, size_t remove_params)
{

	// ensure we have a parameter
	if(!relative_url)
		return NULL;
	if(!BP_StringIsReasonablePrintableString(relative_url, bpstrlen(relative_url), BP_FALSE, BP_FALSE))
		return NULL;

	// assign temporary pointer for string manipulations
	char *tmp_ptr = relative_url;

	// walk string on first pass and move past all / characters
	size_t j = 0;
	size_t question_mark_encountered = 0;
	for
	( ; tmp_ptr[j]; j++ )
	{
		if(tmp_ptr[j] == '?')
			break;
		if(tmp_ptr[j] == '/')
		{
			tmp_ptr = &tmp_ptr[j];
			j=0;
		}
	}

	// duplicate string
	char * script_full = bpstrdup(tmp_ptr);

	// if set to remove parameters, truncate along the ? occurance
	if(remove_params)
	for(j=0; script_full[j]; j++)
	{
		if(script_full[j] == '?')
			script_full[j] = '\0';
	}

	// return script
	return script_full;

}

// Converts a relative link, to a base embedded link. Look at
// the following as an example:
//   base_test_uri = http://localhost/test/
//   relative_uri  = ./blah.php?blah=blah
//   this produces: http://localhost/test/blah.php?blah=blah
char * BP_CreateDirectUrlFromRel(char *base_url, char *rel_url)
{

	// check base/relative urls
	if(!base_url || !rel_url)
		return NULL;
	if(!strnlen(rel_url, 10) || !strnlen(base_url, 10))
		return NULL;

	// path deduction counter
	size_t pdc = 0;

	while(rel_url[pdc] == ' ')
	{
		pdc++;
	}

	// simple logic to skip past / or ./ depending on link type
	if(rel_url[pdc] == '.')
	{
		pdc++;
		if(rel_url[1] == '/')
			pdc++;

	}

	if(rel_url[pdc] == '/')
	{
		pdc++;
	}

	// string to return
	char *ret_str = NULL;

	// relative path information
	char *rel_path = NULL;
	size_t rel_path_len = 0;

	// switch to build string
	switch(pdc)
	{

		// if the counter is at 1, its a /link
		case 1:
			// retrieve url path
			rel_path = (char *) BP_ParseURLToPathPCRE(base_url);
			rel_path_len = strnlen(rel_path, 2048);

			// allocate buffer for return string
			ret_str = (char *) bpcalloc(rel_path_len + strnlen(rel_url, 2048) + 100, 1);

			// fiil new buffer
			snprintf(ret_str, rel_path_len + strnlen(rel_url, 2048), "%s%s", rel_path, (char *) &rel_url[pdc]);
			break;

		// if the counter is at 2, its a ./link
		case 2:
			rel_path = (char *) BP_ParseURLToPathPCRE(base_url);
			rel_path_len = strnlen(rel_path, 2048);

			// allocate buffer for return string
			ret_str = (char *) bpcalloc(rel_path_len + strnlen(rel_url, 2048) + 100, 1);

			// fiil new buffer
			snprintf(ret_str, rel_path_len + strnlen(rel_url, 2048), "%s%s", rel_path, (char *) &rel_url[pdc]);
			break;

		// its neither ./ or / but a empty prefix link instead.
		default:
			rel_path = (char *) BP_ParseURLToPathPCRE(base_url);
			rel_path_len = strnlen(rel_path, 2048);

			// allocate buffer for return string
			ret_str = (char *) bpcalloc(rel_path_len + strnlen(rel_url, 2048) + 100, 1);

			// fill new buffer
			snprintf(ret_str, rel_path_len + strnlen(&rel_url[pdc], 2048)+1, "%s%s", rel_path, (char *) &rel_url[pdc]);
			break;

	}

	// bpfree the relative path if it exists (tmp var created in switch)
	if(rel_path)
	{
		bpfree(rel_path);
	}

	// return correct string
	return ret_str;

}




