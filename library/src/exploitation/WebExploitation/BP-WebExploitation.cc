/*
 * BP-WebExploitation.cc
 *
 *  Created on: Mar 5, 2009
 *      Author: root
 *
 */

// Include main header
#include "../../../include/BP-Main.h"

// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%% UILITY FUNCTIONS %%%%%%%%%%%%%%%%%%%%%%%

// Generates a new anchor structure for performing injections
// on anchors anchors given a replacement variable position, and
// a replacement string.  This function is a primary component of
// the injection facilities of BP.  The returned structure is a
// DUPLICATE, and is not the same as the structure brought in.
// Additionally, its list size is one anchor element long.
P_BP_HTML_ANCHOR_LIST BP_GenerateAnchorString(P_BP_HTML_ANCHOR_LIST anchor, size_t varPos, char *newVal)
{

	// ensure we have an anchor
	if (!anchor || !newVal)
		return NULL;

	// ensure string is reasonable/printable
	if(!BP_StringIsReasonablePrintableString(newVal, bpstrlen(newVal), BP_FALSE, BP_FALSE))
		return NULL;


	// Allocate space for a new anchor, and copy in the old anchor structure
	P_BP_HTML_ANCHOR_LIST newAnchor = (P_BP_HTML_ANCHOR_LIST) bpcalloc(sizeof(BP_HTML_ANCHOR_LIST), 1);

	// Null OOM check
	if (!newAnchor)
		return NULL;

	// copy in structure and reset list pointers
	memcpy(newAnchor, anchor, sizeof(BP_HTML_ANCHOR_LIST));

	// set the first pointer
	newAnchor->first = newAnchor;
	newAnchor->next = NULL;
	newAnchor->prev = NULL;

	// return the new anchor
	return newAnchor;

}


// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%% HTTP Status Code Checks %%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

// All http status codes
BP_WEB_ASSESSMENT_EXCLUSION_CODES httpStatusCodes[] = {

// 100's ---------------------
		{ 100, "100 Continue", "100 Continue", "100 Continue", "100 Continue" },

		{ 101, "101 Switching Protocols", "101 Switching Protocols", "101 Switching Protocols", "101 Switching Protocols" },

		{ 102, "102 Processing", "102 Processing", "102 Processing", "102 Processing" },

		// 200's -------------------------------

		{ 200, "200 OK", "200 OK", "200 OK", "200 OK" },

		{ 201, "201 Created", "201 Created", "201 Created", "201 Created" },

		{ 202, "202 Accepted", "202 Accepted", "202 Accepted", "202 Accepted" },

		{ 203, "203 Non-Authoritative Information", "203 Non-Authoritative Information", "203 Non-Authoritative Information",
				"203 Non-Authoritative Information" },

		{ 204, "204 No Content", "204 No Content", "204 No Content", "204 No Content" },

		{ 205, "205 Reset Content", "205 Reset Content", "205 Reset Content", "205 Reset Content" },

		{ 206, "206 Partial Content", "206 Partial Content", "206 Partial Content", "206 Partial Content" },

		{ 207, "207 Multi-Status", "207 Multi-Status", "207 Multi-Status", "207 Multi-Status" },

		// 300's ------------------

		{ 300, "300 Multiple Choices", "300 Multiple Choices", "300 Multiple Choices", "300 Multiple Choices", },

		{ 301, "301 Moved Permanently", "301 Moved Permanently", "301 Moved Permanently", "301 Moved Permanently", },

		{ 302, "302 Found", "302 Found", "302 Found", "302 Found", },

		{ 303, "303 See Other", "303 See Other", "303 See Other", "303 See Other", },

		{ 304, "304 Not Modified", "304 Not Modified", "304 Not Modified", "304 Not Modified", },

		{ 305, "305 Use Proxy", "305 Use Proxy", "305 Use Proxy", "305 Use Proxy", },

		{ 306, "306 Switch Proxy", "306 Switch Proxy", "306 Switch Proxy", "306 Switch Proxy", },

		{ 307, "307 Temporary Redirect", "307 Temporary Redirect", "307 Temporary Redirect", "307 Temporary Redirect", },

		// 400's ----------------------------------
		{ 400, "400 Bad Request", "400 Bad Request", "400 Bad Request", "400 Bad Request", },

		{ 401, "401 Unauthorized", "401 Unauthorized", "401 Unauthorized", "401 Unauthorized", },

		{ 402, "402 Payment Required", "402 Payment Required", "402 Payment Required", "402 Payment Required", },

		{ 403, "403 Forbidden", "403 Forbidden", "403 Forbidden", "403 Forbidden", },

		{ 404, "404 Not Found", "404 Not Found", "404 Not Found", "404 Not Found", },

		{ 405, "405 Method Not Allowed", "405 Method Not Allowed", "405 Method Not Allowed", "405 Method Not Allowed", },

		{ 406, "406 Not Acceptable", "406 Not Acceptable", "406 Not Acceptable", "406 Not Acceptable", },

		{ 407, "407 Proxy Authentication Required", "407 Proxy Authentication Required", "407 Proxy Authentication Required",
				"407 Proxy Authentication Required", },

		{ 408, "408 Request Timeout", "408 Request Timeout", "408 Request Timeout", "408 Request Timeout", },

		{ 409, "409 Conflict", "409 Conflict", "409 Conflict", "409 Conflict", },

		{ 410, "410 Gone", "410 Gone", "410 Gone", "410 Gone", },

		{ 411, "411 Length Required", "411 Length Required", "411 Length Required", "411 Length Required", },

		{ 412, "412 Precondition Failed", "412 Precondition Failed", "412 Precondition Failed", "412 Precondition Failed", },

		{ 413, "413 Request Entity Too Large", "413 Request Entity Too Large", "413 Request Entity Too Large", "413 Request Entity Too Large", },

		{ 414, "414 Request-URI Too Long", "414 Request-URI Too Long", "414 Request-URI Too Long", "414 Request-URI Too Long", },

		{ 415, "415 Unsupported Media Type", "415 Unsupported Media Type", "415 Unsupported Media Type", "415 Unsupported Media Type", },

		{ 416, "416 Requested Range Not Satisfiable", "416 Requested Range Not Satisfiable", "416 Requested Range Not Satisfiable",
				"416 Requested Range Not Satisfiable", },

		{ 417, "417 Expectation Failed", "417 Expectation Failed", "417 Expectation Failed", "417 Expectation Failed", },

		{ 418, "418 I'm a teapot", "418 I'm a teapot", "418 I'm a teapot", "418 I'm a teapot", },

		{ 422, "422 Unprocessable Entity", "422 Unprocessable Entity", "422 Unprocessable Entity", "422 Unprocessable Entity", },

		{ 423, "423 Locked", "423 Locked", "423 Locked", "423 Locked", },

		{ 424, "424 Failed Dependency", "424 Failed Dependency", "424 Failed Dependency", "424 Failed Dependency", },

		{ 425, "425 Unordered Collection", "425 Unordered Collection", "425 Unordered Collection", "425 Unordered Collection", },

		{ 426, "426 Upgrade Required", "426 Upgrade Required", "426 Upgrade Required", "426 Upgrade Required", },

		{ 449, "449 Retry With", "449 Retry With", "449 Retry With", "449 Retry With", },

		{ 450, "450 Blocked", "450 Blocked", "450 Blocked", "450 Blocked", },

		// 500's ------------------------

		{ 500, "500 Internal Server Error", "500 Internal Server Error", "500 Internal Server Error", "500 Internal Server Error", },

		{ 501, "501 Not Implemented", "501 Not Implemented", "501 Not Implemented", "501 Not Implemented", },

		{ 502, "502 Bad Gateway", "502 Bad Gateway", "502 Bad Gateway", "502 Bad Gateway", },

		{ 503, "503 Service Unavailable", "503 Service Unavailable", "503 Service Unavailable", "503 Service Unavailable", },

		{ 504, "504 Gateway Timeout", "504 Gateway Timeout", "504 Gateway Timeout", "504 Gateway Timeout", },

		{ 505, "505 HTTP Version Not Supported", "505 HTTP Version Not Supported", "505 HTTP Version Not Supported", "505 HTTP Version Not Supported", },

		{ 506, "506 Variant Also Negotiates", "506 Variant Also Negotiates", "506 Variant Also Negotiates", "506 Variant Also Negotiates", },

		{ 507, "507 Insufficient Storage", "507 Insufficient Storage", "507 Insufficient Storage", "507 Insufficient Storage", },

		{ 509, "509 Bandwidth Limit Exceeded", "509 Bandwidth Limit Exceeded", "509 Bandwidth Limit Exceeded", "509 Bandwidth Limit Exceeded", },

		{ 510, "510 Not Extended", "510 Not Extended", "510 Not Extended", "510 Not Extended", } };

// Generates a bpmalloc'd version of the status code array above
P_BP_WEB_ASSESSMENT_EXCLUSION_CODES BP_GenStatusCodeArray()
{

	// set size of the status code array
	size_t allocSize = sizeof(httpStatusCodes);

	// allocate space for newly returned array
	char * retTable = (char *) bpmalloc(allocSize);

	// null check
	if (!retTable)
		return NULL;

	// copy in status codes
	memcpy(retTable, &httpStatusCodes, allocSize);

	// return the new structure
	return (P_BP_WEB_ASSESSMENT_EXCLUSION_CODES) retTable;

}


// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%% Assessment Utility Lookup Functions %%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

// SQLINJ: Checks a web assessment to see if it contains a vulnerabile form input.  If so, it looks up the
// form action (aka target page), and returns the HTML form property structure that contains its value/size.
// Returns null on failure.
P_BP_HTML_FORM_PROPERTY_LIST BP_GetVulnerableFormActionPropertySQL(P_BP_WEB_SQLINJ_TEST_RESULT sqlinj)
{

	if(!sqlinj)
		return NULL;

	// ensure we have a form
	if(!sqlinj->form)
		return NULL;

	// set the form properties
	P_BP_HTML_FORM_PROPERTY_LIST fprops = sqlinj->form->properties;

	// return null if we have no form properties
	if(!fprops)
		return NULL;

	// walk property list and check for action property
	for(fprops = fprops->first;
		fprops;
		fprops=fprops->next)
	{
		if( ! BP_strncasecmp(fprops->name, "action", bpstrlen("action")) )
		{
			return fprops;
		}

	}

	// didn't find an action, return null
	return NULL;

}

// XSS: Checks a web assessment to see if it contains a vulnerabile form input.  If so, it looks up the
// form action (aka target page), and returns the HTML form property structure that contains its value/size.
// Returns null on failure.
P_BP_HTML_FORM_PROPERTY_LIST BP_GetVulnerableFormActionPropertyXSS(P_BP_WEB_XSS_TEST_RESULT xss)
{

	// ensure we have an xss parameter
	if(!xss)
		return NULL;

	// ensure we have a form
	if(!xss->form)
		return NULL;

	// set the form properties
	P_BP_HTML_FORM_PROPERTY_LIST fprops = xss->form->properties;

	// return null if we have no form properties
	if(!fprops)
		return NULL;

	// walk property list and check for action property
	for
	(
		fprops = fprops->first;
		fprops;
		fprops = fprops->next
	)
	{

		if( ! BP_strncasecmp(fprops->name, "action", bpstrlen("action")) )
		{
			return fprops;
		}

	}

	// didn't find an action, exit with null for failure
	return NULL;

}




// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%% PHP Injection Tests %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%% LDAP Injection Tests %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%% ASP Injection Tests %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%% JSP Injection Tests %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%% ASSESSMENT ROUTINES %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


// Creates an new assessment structure (all flags are required)
P_BP_WEB_ASSESSMENT BP_CreateWebAssessment
(
		char *                    baseAssessmentURL,
		P_BP_HTTP_SESSION         session,
		P_BP_HTML_FULL_EXTRACTION extraction,
		bool                      genSqlTables,
		bool                      genAppEngineTables,
		bool                      siteLock
)
{

	// check pointers (session and extraction are unnecessary)
	if (!baseAssessmentURL)
		return NULL;

	// ensure the string is reasonable printable string
	if(!BP_StringIsReasonablePrintableString(baseAssessmentURL, bpstrlen(baseAssessmentURL), BP_FALSE, BP_FALSE))
		return NULL;

	// Create assessment
	P_BP_WEB_ASSESSMENT assessment = (P_BP_WEB_ASSESSMENT) bpcalloc(sizeof(BP_WEB_ASSESSMENT), 1);
	if (!assessment)
		return NULL;

	// Duplicate and store assessment
	assessment->baseAssessmentURL = bpstrdup(baseAssessmentURL);

	// Generate a new status code array
	assessment->statusCodes = BP_GenStatusCodeArray();
	if (!assessment->statusCodes)
		return NULL;

	// Generate a format character table to use when parsing
	// error messages.
	assessment->fmtTable = BP_WebExploitGenFormatTable();
	if (!assessment->fmtTable)
		return NULL;

	// -------------------------------------------------
	// Extraction and Session variables (if non-null pointers are supplied
	// those pointers are used, if not, flags are set so that new extractions
	// are created when the assessment is run.

	// if we already have an extraction, work with that, if not
	// set flag indicating we need to perform the extraction.
	if (extraction)
		assessment->pageExtraction = extraction;
	else
		assessment->performRequiredExtraction = true;

	// if we have a session, set it, if not set flag indicating
	// that we need to create the new session
	if (session)
		assessment->session = session;
	else
		assessment->createNewSession = true;

	// Enable browser string randomization by default
	assessment->randomizeBrowserStrsBetweenRequests = true;

	// set maximum number of request timeouts (default 5)
	assessment->maxRetryRequests = 5;

	// set assessment as non-failed
	assessment->failedAssessment = 0;


	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	// %%% User Agent Settings %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	// set the user agent pool type
	assessment->userAgentPoolType = BP_USER_AGENT_POOL_BROWSERS_ONLY;

	// Use default user agent pool (browsers only)
	assessment->userAgentPool = BP_GenerateBrowserAgentOnlyArray();
	if (!assessment->userAgentPool)
		return NULL;

	// set user agent counts
	assessment->userAgentCount = BP_HTTPUserAgentCount(assessment->userAgentPool);


	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	// %%% XSS Check Settings %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	// Generate Standard XSS Test Array (LIVE AMMO)
	assessment->xssChecks      = BP_XSSGenerateArray();
	assessment->xssChecksCount = BP_GetXSSTestCount();

	// Standard Test Set Identifier
	assessment->xssTestSetId = BP_XSS_TEST_SET_STANDARD;


	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	// %%% SQL Check Settings %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	// Generate Standard SQL Injection Test Array (LIVE AMMO)
	assessment->sqlChecks     = BP_SQLGenerateArray();
	assessment->sqlCheckCount = BP_GetSQLTestCount();

	// Standard Test Set
	assessment->sqlInjTestSetId = BP_SQLINJ_TEST_SET_STANDARD;

	// Set caps within the assessment
	assessment->maxAnchorPossibilities = 65535;
	assessment->maxFormPossibilities   = 65535;

	// Set default xss payload
	assessment->xssPayload = (char *) bpcalloc(bpstrlen("alort(1);") + 5, 1);
	memcpy(assessment->xssPayload, ".", bpstrlen("."));

	// Set default SQL payload
	assessment->sqlInjectPayload = (char *) bpcalloc(bpstrlen("UNION SELECT 1,2,3;") + 100, 1);
	memcpy(assessment->sqlInjectPayload, ".", bpstrlen("."));

	// ------------ SQL TABLE GENERATION ---------------------

	// If we were passed the flag to generate SQL tables, generate them here
	if (genSqlTables)
	{

		// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		// %%% MySQL Checks %%%%%%%%%%%%%%%%%%%%%%%%%%%
		// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

		// set default check value (true)
		assessment->runMysqlChecks = true;

		// Generate a Msql Error Code Array (unmodified)
		assessment->mysqlErrCodes = BP_MysqlGenErrCodeArray();
		if (!assessment->mysqlErrCodes)
			return NULL;

		// Get the test count
		assessment->mysqlErrCheckCount = BP_MysqlErrCount();

		// Generates error tests from the array (parsed for sectional testing aka. formats gone)
		assessment->mysqlErrChecks = BP_MysqlGenErrTestsFromErrCodeArray(assessment->mysqlErrCodes, assessment->mysqlErrCheckCount, assessment->fmtTable);
		if (!assessment->mysqlErrChecks)
			return NULL;

		// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		// %%% MSQL Checks %%%%%%%%%%%%%%%%%%%%%%%%%%%%
		// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

		// set default check value (true)
		assessment->runMsqlChecks = false;

		if(assessment->runMsqlChecks == true)
		{

			// Generate a Msql Error Code Array (unmodified)
			assessment->msqlErrCodes = BP_MsqlGenErrCodeArray();
			if (!assessment->msqlErrCodes)
				return NULL;

			// Get the test count
			assessment->msqlErrCheckCount = BP_MsqlErrCount();

			// Generates error tests from the array (parsed for sectional testing aka. formats gone)
			assessment->msqlErrChecks = BP_MsqlGenErrTestsFromErrCodeArray(assessment->msqlErrCodes, assessment->msqlErrCheckCount, assessment->fmtTable);

		}

		// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		// %%% ODBC Checks %%%%%%%%%%%%%%%%%%%%%%%%%%%%
		// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

		// set default check value (true)
		assessment->runODBCChecks = true;

		// Generate a ODBC Error Code Array (unmodified)
		assessment->odbcErrCodes = BP_ODBCGenErrCodeArray();
		if (!assessment->odbcErrCodes)
			return NULL;

		// Get the test count
		assessment->odbcErrCheckCount = BP_ODBCErrCount();

		// Generates error tests from the array (parsed for sectional testing aka. formats gone)
		assessment->odbcErrChecks = BP_ODBCGenErrTestsFromErrCodeArray(assessment->odbcErrCodes, assessment->odbcErrCheckCount, assessment->fmtTable);


		// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		// %%% Oracle Checks %%%%%%%%%%%%%%%%%%%%%%%%%%
		// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

		// set default check value (true)
		assessment->runOracleChecks = true;

		// Generate a ODBC Error Code Array (unmodified)
		assessment->oracleErrCodes = BP_OracleGenErrCodeArray();
		if (!assessment->oracleErrCodes)
			return NULL;

		// Get the test count
		assessment->oracleErrCheckCount = BP_OracleErrCount();

		// Generates error tests from the array (parsed for sectional testing aka. formats gone)
		assessment->oracleErrChecks = BP_OracleGenErrTestsFromErrCodeArray(assessment->oracleErrCodes, assessment->oracleErrCheckCount, assessment->fmtTable);


		// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		// %%% Postgres Checks %%%%%%%%%%%%%%%%%%%%%%%%
		// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

		// set default check value (true)
		assessment->runPostgresChecks = true;

		// Generate a ODBC Error Code Array (unmodified)
		assessment->postgresErrCodes = BP_PostgresGenErrCodeArray();
		if (!assessment->postgresErrCodes)
			return NULL;

		// Get the test count
		assessment->postgresErrCheckCount = BP_PostgresErrCount();

		// Generates error tests from the array (parsed for sectional testing aka. formats gone)
		assessment->postgresErrChecks = BP_PostgresGenErrTestsFromErrCodeArray
		(
			assessment->postgresErrCodes,
			assessment->postgresErrCheckCount,
			assessment->fmtTable
		);


	}

	// Application Engine Table Generators
	if (genAppEngineTables)
	{

		// Turn on or off the application server checks, the corresponding lower
		// level checks must be on additionally for them to be run.
		assessment->runAppServerChecks = true;

		// ------------------ PHP -----------------------------------

		// flag to indicate to run php app checks
		assessment->runPhpChecks = true;

		// Error Table which contains unmodified/unparsed table of errors
		assessment->phpErrCodes = BP_PHPGenErrCodeArray();
		if (!assessment->phpErrCodes)
			return NULL;

		// number of php error checks which will be performed
		assessment->phpErrCheckCount = BP_PHPErrCount();

		// Error Checks Related to PHP Used for Identifying PHP Errors
		assessment->phpErrChecks = BP_PHPGenErrTestsFromErrCodeArray(assessment->phpErrCodes, assessment->phpErrCheckCount, assessment->fmtTable);


		// ------------------ JSP -----------------------------------

		// flag to indicate to run php app checks
		assessment->runJspChecks = true;

		// Error Table which contains unmodified/unparsed table of errors
		assessment->jspErrCodes = BP_JSPGenErrCodeArray();
		if (!assessment->jspErrCodes)
			return NULL;

		// number of jsp error checks which will be performed
		assessment->jspErrCheckCount = BP_JSPErrCount();

		// Error Checks Related to JSP Used for Identifying PHP Errors
		assessment->jspErrChecks = BP_JSPGenErrTestsFromErrCodeArray(assessment->jspErrCodes, assessment->jspErrCheckCount, assessment->fmtTable);


		// ------------------ ASP -----------------------------------


		// flag to indicate to run asp app checks
		assessment->runAspChecks = true;

		// error code check array
		assessment->aspErrCodes = BP_ASPGenErrCodeArray();
		if (!assessment->aspErrCodes)
			return NULL;

		// number of asp error checks which will be performed
		assessment->aspErrCheckCount = BP_ASPErrCount();

		assessment->aspErrChecks = BP_ASPGenErrTestsFromErrCodeArray(assessment->aspErrCodes, assessment->aspErrCheckCount, assessment->fmtTable);



		// ------------------ CFM -----------------------------------

		// flag to indicate to run asp app checks
		assessment->runCfmChecks = true;

		// error code check array
		assessment->cfmErrCodes = BP_CFMGenErrCodeArray();
		if (!assessment->cfmErrCodes)
			return NULL;

		// number of asp error checks which will be performed
		assessment->cfmErrCheckCount = BP_CFMErrCount();

		// set the checks
		assessment->cfmErrChecks = BP_CFMGenErrTestsFromErrCodeArray(assessment->cfmErrCodes, assessment->cfmErrCheckCount, assessment->fmtTable);


		// ------------------ .NET -----------------------------------

		// flag to indicate to run asp app checks
		assessment->runDnetChecks = true;

		// error code check array
		assessment->dnetErrCodes = BP_DNETGenErrCodeArray();
		if (!assessment->dnetErrCodes)
			return NULL;


		// number of asp error checks which will be performed
		assessment->dnetErrCheckCount = BP_DNETErrCount();
		assessment->dnetErrChecks = BP_DNETGenErrTestsFromErrCodeArray(assessment->dnetErrCodes, assessment->dnetErrCheckCount, assessment->fmtTable);



	}

	// set default max retries
	assessment->http_request_max_retries = 3;

	// set first pointer
	assessment->first = assessment;

	// return the assessment
	return assessment;

}

// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%% Set Basic Request Data %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

BP_ERROR_T BP_WebAssessmentSetBasicRequestData
(
		P_BP_WEB_ASSESSMENT                  assessment,
		P_BP_WEB_ANALYSIS_BASIC_REQUEST_DATA request_data_in, /* this structure is filled */
		P_BP_WEB_EXPLOIT_REQUEST_SET         exploit_request_set,
		P_BP_HTTP_SESSION                    http_session,
		P_BP_HTML_ANCHOR_LIST                anchor,
		size_t                               anchor_index,
		P_BP_HTML_FORM_LIST                  form,
		size_t                               form_index,
		size_t                               request_header_index
)
{

	// ensure that we have an assessment to work with
	if(!assessment)
		return ERR_FAILURE;

	// ensure we have request data
	if(!request_data_in)
		return ERR_FAILURE;

	if(http_session)
	{

		// set request id
		if(assessment->db_log_mysql_session)
		{
			request_data_in->request_id        = assessment->db_http_last_request_made_id;
			request_data_in->result_id         = assessment->db_result_id;
		}

		request_data_in->http_status_code  = http_session->http_status_code;
		request_data_in->http_connect_code = http_session->http_connect_code;



	}

	// if we were provided an exploit request set, we can set the actual get/post/cookie data
	if(exploit_request_set)
	{

		if(exploit_request_set->get_str)
			snprintf((char *)&request_data_in->http_get,    sizeof(request_data_in->http_get)-1,    "%s", exploit_request_set->get_str);
		if(exploit_request_set->post_str)
			snprintf((char *)&request_data_in->http_post,   sizeof(request_data_in->http_post)-1,   "%s", exploit_request_set->post_str);
		if(exploit_request_set->cookie_str)
			snprintf((char *)&request_data_in->http_cookie, sizeof(request_data_in->http_cookie)-1, "%s", exploit_request_set->cookie_str);

	}

	// set anchor information if set
	size_t n = 0;
	if(anchor)
	{

		// create reference for ease of use
		P_BP_HTML_ANCHOR_VAR_LIST anchor_vars = anchor->vars;

		// walk the anchor vars if they exist
		for(; anchor_vars; anchor_vars = anchor_vars->next)
		{

			// exit the loop if we found the index
			if(n == anchor_index)
				break;

			// increment the counter on loop
			n++;

		}

		// if we've found the anchor vars, we can fill in the data
		if(anchor_vars)
		{

			if(anchor_vars->name)
				snprintf((char *) &request_data_in->suspected_get_var, sizeof(request_data_in->suspected_get_var)-1, "%s", anchor_vars->name);

		}

	}

	// set form data if one was provided
	if(form)
	{

		// set inputs for iteration
		P_BP_HTML_INPUT_LIST form_inputs = form->inputs;

		// iterate and find the correct input
		for(n = 0; form_inputs; form_inputs = form_inputs->next)
		{

			// exit the loop if we found the index
			if(n == form_index)
			{
				break;
			}

			// increment the counter on loop
			n++;
		}

		// if we've found the anchor vars, we can fill in the data
		if(form_inputs)
		{

			if(form_inputs->properties)
			{

				// set properties pointer
				P_BP_HTML_INPUT_PROPERTY_LIST prop_list = form_inputs->properties;

				// this will be assigned to the correct property on loop
				P_BP_HTML_INPUT_PROPERTY_LIST prop_name = NULL;

				// holds a property name length
				size_t prop_name_len = 0;

				// walk property list and fill in the blanks
				for
				(
					prop_list = prop_list->first;
					prop_list;
					prop_list = prop_list->next
				)
				{

					// get the length of the property (must be 4)
					prop_name_len = bpstrlen(prop_list->name);
					if(prop_name_len != 4)
						continue;

					// run case insensitve string compare
					if(BP_strncasecmp(prop_list->name, "name", 4) == 0)
					{
						prop_name = prop_list;
						break;
					}

				}

				// now finallys et the property name
				if(prop_name)
					snprintf((char *) &request_data_in->suspected_post_var, sizeof(request_data_in->suspected_post_var)-1, "%s", prop_name->content);

			}

		}

	}

	// request headers are set when a http session is created, all we need is an index
	// in order to fill in these
	if(request_header_index)
	{
		snprintf((char *) &request_data_in->suspected_header_var, sizeof(request_data_in->suspected_header_var) -1, "%s", http_session->request_headers[request_header_index].field_name);
		snprintf((char *) &request_data_in->suspected_header_var, sizeof(request_data_in->http_header)          -1, "%s", http_session->request_headers[request_header_index].value);
	}

	// return indicating success
	return ERR_SUCCESS;

}

// display the basic web analysis request data
BP_ERROR_T BP_DisplayWebAnalysisBasicRequestData(P_BP_WEB_ANALYSIS_BASIC_REQUEST_DATA request_data)
{

	if(!request_data)
		return ERR_FAILURE;

	printf("\n\t [+] Basic Request Data (%p)", request_data);
	printf("\n\t     result_id:             %u", request_data->result_id);
	printf("\n\t     request_id:            %u", request_data->request_id);
	printf("\n\t     http_connect_code:     %u", request_data->http_connect_code);
	printf("\n\t     http_status_code:      %u", request_data->http_status_code);
	printf("\n\t     http_get:              %s", (char *) &request_data->http_get);
	printf("\n\t     http_post:             %s", (char *) &request_data->http_post);
	printf("\n\t     http_cookie:           %s", (char *) &request_data->http_cookie);
	printf("\n\t     http_header:           %s", (char *) &request_data->http_header);
	printf("\n\t     suspected_get_var:     %s", (char *) &request_data->suspected_get_var);
	printf("\n\t     suspected_post_var:    %s", (char *) &request_data->suspected_post_var);
	printf("\n\t     suspected_cookie_var:  %s", (char *) &request_data->suspected_cookie_var);
	printf("\n\t     suspected_header_var:  %s", (char *) &request_data->suspected_header_var);
	printf("\n\t     detection_string_test: %s", (char *) &request_data->detection_string_test);
	printf("\n\t     detection_found_test:  %s", (char *) &request_data->detection_string_found);
	printf("\n\t     detection_string_test: %s", (char *) &request_data->detection_table_index);

	switch(request_data->detection_engine)
	{
	default:
		break;
	}

	switch(request_data->condition)
	{
	default:
		break;
	}




	// return indicating success
	return ERR_SUCCESS;

}

// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%% ASSESSMENT LIST UTILITIES %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

// Append an assessment to an existing list
size_t BP_AppendWebAssessmentList(P_BP_WEB_ASSESSMENT inList, P_BP_WEB_ASSESSMENT appendList)
{

	// ensure we have an inlist, and an append list
	if (!inList || !appendList)
		return ERR_FAILURE;

	// navigate to the last entry
	P_BP_WEB_ASSESSMENT last = BP_WebAssessmentGetLastElement(inList);
	if (!last)
		return ERR_FAILURE;

	// set next pointer
	last->next = appendList;

	// reset all the first pointers in the appending list
	BP_ChangeWebAssessmentListFirstPointers(appendList, inList->first);

	// link up the list
	appendList->prev = last;

	// return indicating success
	return ERR_SUCCESS;

}

// Retrieves the last element from the list
P_BP_WEB_ASSESSMENT BP_WebAssessmentGetLastElement(P_BP_WEB_ASSESSMENT inList)
{

	// ensure we have a list to work with
	if (!inList)
		return NULL;

	// walk the list and get the last element
	for (inList = inList->first; inList->next != NULL; inList = inList->next) {}

	// return the pointer
	return inList;

}

// Resets the first pointer in the whole list
size_t BP_ChangeWebAssessmentListFirstPointers(P_BP_WEB_ASSESSMENT inList, P_BP_WEB_ASSESSMENT newFirst)
{

	// ensure we have an inlist, and a new first
	if (!inList || !newFirst)
		return ERR_FAILURE;

	// walk the list resetting pointers
	for (inList = inList->first; inList; inList = inList->next)
		inList->first = newFirst;

	// return indicating success
	return ERR_SUCCESS;

}

/// Remove an element from the list
size_t BP_RemoveWebAssessmentElementFromList(P_BP_WEB_ASSESSMENT inList, P_BP_WEB_ASSESSMENT removeList)
{

	if (!inList || !removeList)
		return ERR_FAILURE;

	if (BP_WebAssessmentFindElementInList(inList, removeList)) {

		if (removeList->prev != NULL) {
			removeList->prev->next = removeList->next;
		}

		if (removeList->next != NULL) {
			removeList->next->prev = removeList->prev;
		}

		bpfree(removeList);

	}

	return ERR_SUCCESS;
}

// See if element is in the list
P_BP_WEB_ASSESSMENT BP_WebAssessmentFindElementInList(P_BP_WEB_ASSESSMENT inList, P_BP_WEB_ASSESSMENT testList) {

	if (!inList || !testList)
		return NULL;

	for (inList = inList->first; inList; inList = inList->next) {

		if (inList == testList)
			return testList;

	}

	return NULL;
}

// ------------------------------------------------------------------


// Creates a full list of assessments provided an anchor list,
// in the case of an encountered anchor which is not HTTP, the baseURL parameter is
// prefixed to the new assessment, which is useful for relative anchors.  If the
// anchor contains a prefix of http(s):// this will not be used.
P_BP_WEB_ASSESSMENT BP_CreateWebAssessmentsFromAnchors(P_BP_WEB_ASSESSMENT appendList, char *baseURL, P_BP_HTML_ANCHOR_LIST anchors) {

	// cannot have null anchors or baseURL
	if (!anchors || !baseURL)
		return NULL;

	// Indicates if the loop is appending or not
	size_t firstIndicator = 0;

	P_BP_WEB_ASSESSMENT outList = NULL;
	P_BP_WEB_ASSESSMENT genElement = NULL;

	if (appendList != NULL)
		outList = appendList;

	// create 4096 bytes of stack space for our builder buff
	char baseStr[4096];

	// walk anchor list and create assessments around it
	for (anchors = anchors->first; anchors; anchors = anchors->next) {

		if (anchors->href == NULL)
			continue;

		// zero out base buffer
		memset(&baseStr, 0x00, sizeof(baseStr));

		// If the protocol is not 0, then its offsite (change later)
		if (anchors->proto == BP_ANCHOR_PROTO_HTTP || anchors->proto == BP_ANCHOR_PROTO_HTTPS)
		{
			snprintf(baseStr, 4000, "%s", anchors->relativePath);
		}
		else
		{
			snprintf(baseStr, 4000, "%s%s", baseURL, anchors->href);
		}

		// Session and Extraction are Null (safe to use stackbuff, as its bpstrdup'd)
		genElement = BP_CreateWebAssessment(baseStr, NULL, NULL, true, true, true);

		if (firstIndicator > 0)
		{

			// append list to outlist
			BP_AppendWebAssessmentList(outList, genElement);

		}
		else
		{

			// set as first if we are at the first position
			// ONLY NECESSARY IF A NULL APPEND WAS PASSED.
			if (outList == NULL)
				outList = genElement;

		}

		// only increment first, if we could generate a element
		// based on anchor properties.
		if (outList)
			firstIndicator = 1;

	}

	// set outlist pointer
	if (outList == NULL)
		return NULL;

	// return first pointer
	return outList->first;

}

// Creates a full list of assessments provided a form list
P_BP_WEB_ASSESSMENT BP_CreateWebAssessmentsFromForms(P_BP_WEB_ASSESSMENT appendList, P_BP_HTML_FORM_LIST forms)
{

	return NULL;
}

// Utility function to print list objects simply (debug function mainly)
void BP_PrintWebAssessmentListLinkage(P_BP_WEB_ASSESSMENT assessment)
{

	if (!assessment)
		return;

	for (assessment = assessment->first; assessment; assessment = assessment->next) {

		printf("\n [+] Assessment: %p", assessment);
		printf("\n     Base URL:   %s", assessment->baseAssessmentURL);
		printf("\n\t\t Linkages: [f] %p [p] %p [n] %p", assessment->first, assessment->prev, assessment->next);
		printf("\n");
	}

	return;
}

// ----------------- SETTRS AND GETTRS ---------------------------------


// Duplicates the provided string (calloc) and sets it in the provided
// structure.
size_t BP_SetAssessmentBaseURL(P_BP_WEB_ASSESSMENT assessment, char *url) {

	// ensure we have a url
	if (!url)
		return ERR_FAILURE;

	// ensure the url is reasonable/printable
	if(!BP_StringIsReasonablePrintableString(url, bpstrlen(url), BP_FALSE, BP_FALSE))
		return ERR_FAILURE;

	// set the duplicate
	assessment->baseAssessmentURL = bpstrndup(url, 4096);

	// return success code
	return ERR_SUCCESS;
}

// Sets session pointer in the web assessment
size_t BP_SetAssessmentSession(P_BP_WEB_ASSESSMENT assessment, P_BP_HTTP_SESSION session) {

	// ensure we have a session
	if (!session)
		return ERR_FAILURE;

	// set the duplicate
	assessment->session = session;

	// return indicating success
	return ERR_SUCCESS;

}

// Sets the SQL check pointer in assessment
size_t BP_SetAssessmentSQLChecks(P_BP_WEB_ASSESSMENT assessment, P_BP_WEB_SQLINJ_TEST sqlChecks)
{

	// ensure that we have an assessment and some checks to set
	if (!sqlChecks || !assessment)
		return ERR_FAILURE;

	// set the duplicate
	assessment->sqlChecks = sqlChecks;

	// return indicating success
	return ERR_SUCCESS;

}

// Sets the XSS check pointer in the assessment (can use dummy lists)
size_t BP_SetAssessmentXSSChecks(P_BP_WEB_ASSESSMENT assessment, P_BP_WEB_XSS_TEST xssChecks)
{

	// ensure that we have an assessment and some checks to set
	if (!xssChecks || !assessment)
		return ERR_FAILURE;

	// set the duplicate
	assessment->xssChecks = xssChecks;

	// return indicating success
	return ERR_SUCCESS;

}

// ERR_FAILURE if necessary pointers are unset
size_t BP_CheckWebAssessmentPointers(P_BP_WEB_ASSESSMENT assessment)
{

	for
	(
		assessment = assessment->first;
		assessment;
		assessment = assessment->next
	)
	{

		// ensure we have an assessment
		if (!assessment)
			return ERR_FAILURE;

		// check pointers
		if
		(
				!assessment->baseAssessmentURL ||
				!assessment->session           ||
				!assessment->pageExtraction    ||
				!assessment->sqlChecks         ||
				!assessment->xssChecks         ||
				!assessment->first
		)
		{

			// return indicating failure
			return ERR_FAILURE;
		}

	}

	// return indicating success
	return ERR_SUCCESS;

}

// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%% MAIN ASSESSMENT FUNCTIONALITY %%%%%%%%%%%%%%%%%%%%%%%


// Multiple assessment dispatcher (runs the full list of assessments)
size_t BP_RunWebAssessments(P_BP_WEB_ASSESSMENT assessmentList)
{

	// ensure we have an assessment list to work with
	if (!assessmentList)
		return ERR_FAILURE;

	// run each assessment in the assessment list
	for
	(
		assessmentList = assessmentList->first;
		assessmentList;
		assessmentList = assessmentList->next
	)
	{

		// run the web assessment
		BP_RunWebAssessment(assessmentList);

	}

	// return indicating success
	return ERR_SUCCESS;

}

// JM - - MAIN ASSESSMENT DISPATCHING FUNCTIONALITY LIVES HERE:
// This routine is responsible for running an assessment
size_t BP_RunWebAssessment(P_BP_WEB_ASSESSMENT assessment)
{

	// Null check
	if (!assessment)
		return ERR_FAILURE;

	// Create a new HTTP session if indicated
	if (assessment->createNewSession)
	{

		// Create a new session
		assessment->session = BP_HTTPCreateSession();
		if(!assessment->session)
			return ERR_FAILURE;

	}

	// Set to perform required extraction, go ahead and do it
	if (assessment->performRequiredExtraction)
	{

		// Set cookie vars if necessary
		if (assessment->cookie)
		{
			BP_HTTPSetCookie(assessment->session, assessment->cookie);
		}

		// Set post variables if necessary
		if (assessment->postArgs)
		{
			BP_HTTPSetPostVars(assessment->session, assessment->postArgs);
		}

		// set audit retry request iterator to zero
		size_t audit_retry_request_iter = 0;

		// set completed flag to an initial success value.  this value will change in the loop below in the case of errors.
		size_t request_completed_successfully = 1;

		// attempt to make actual initial request
		while(BP_HTTPRequest(assessment->session, assessment->baseAssessmentURL) == ERR_FAILURE)
		{

			// increment requests
			audit_retry_request_iter++;

			// display debug message (uncomment if necessary)
			//printf("\n va-retrying request: %u - %s", audit_retry_request_iter,  assessment->baseAssessmentURL);

			//  run a check and exit in the request attempts ahve exhausted the max attempts set in the assessment
			if(audit_retry_request_iter > assessment->http_request_max_retries)
			{

				// display error message
				printf("\n Request limit exceeded, marking result as erroneous (status=3)");

				// Set flag indicating that the request was unable to complete successfully.  This causes the assessment
				// to exit.
				request_completed_successfully = 0;
				break;

			}

		}

		// if the request failed for some reaason, continue the loop
		if(!request_completed_successfully)
		{
			printf("\n [!!] initial request to begin assessment failed.");
			return ERR_FAILURE;
		}

		// perform extraction
		assessment->pageExtraction = HTMLDecodeBuffer
		(
			assessment->session->page->memPtr,
			assessment->session->page->size,
			assessment->baseAssessmentURL,
			NULL,
			NULL,
			HTML_PARSE_NOERROR,
			NULL
		);

	}

	// ensure that the web assessment pointers have been filled appropriately, if not -- exit routine
	if (BP_CheckWebAssessmentPointers(assessment) != ERR_SUCCESS)
	{

		// return indicating failure
		return ERR_FAILURE;

	}


	// run checks against anchors
	printf("\n [+] Attempting to run web assessment anchor checks.");
	BP_RunWebAssessmentAnchorChecks(assessment);

	// Run checks against forms
	printf("\n [+] Attempting to run web assessment form checks.");
	BP_RunWebAssessmentFormChecks(assessment);


	// return indicating success
	return ERR_SUCCESS;

}

// Appends a result set to the end of an assessment set
size_t BP_WebAssessmentAppendXSSResultToList(P_BP_WEB_XSS_TEST_RESULT inList, P_BP_WEB_XSS_TEST_RESULT appendList)
{

	// ensure we have a list and an append list
	if (!inList || !appendList)
		return ERR_FAILURE;

	// move to the last position
	for (inList = inList->first; inList->next; inList = inList->next) {}

	// add to the list
	if (inList != NULL && inList->next == NULL)
	{

		// link next to the original list
		inList->next = appendList;

		// link up the append list with the inlist pointers
		appendList->prev  = inList;
		appendList->first = inList->first;
		appendList->next  = NULL;

		// return indicating success
		return ERR_SUCCESS;

	}

	// Return failure if link is impossible
	return ERR_FAILURE;

}

// Appends a result set to the end of an assessment set
size_t BP_WebAssessmentAppendSQLResultToList(P_BP_WEB_SQLINJ_TEST_RESULT inList, P_BP_WEB_SQLINJ_TEST_RESULT appendList)
{

	// check pointers
	if (!inList || !appendList)
		return ERR_FAILURE;

	// walk to the end of the list
	for
	(
		inList = inList->first;
		inList->next;
		inList = inList->next
	){}

	// add to the list
	if (inList && !inList->next)
	{

		// link next to the original list
		inList->next = appendList;

		// link up the append list with the inlist pointers
		appendList->prev  = inList;
		appendList->first = inList->first;
		appendList->next  = NULL;

		// return indicating success
		return ERR_SUCCESS;

	}

	// Return failure if link is impossible
	return ERR_FAILURE;

}

// Appends a result set to the end of an application engine assessment set
size_t BP_WebAssessmentAppendAppEngineResultToList(P_BP_WEB_APPSERVER_TEST_RESULT inList, P_BP_WEB_APPSERVER_TEST_RESULT appendList)
{

	// check pointers
	if (!inList || !appendList)
		return ERR_FAILURE;

	// save the first pointer
	P_BP_WEB_APPSERVER_TEST_RESULT savedFirst = inList->first;

	// move to the end of the list
	for
	(
		inList = inList->first;
		inList->next != NULL;
		inList = inList->next
	){}

	// add to the list
	if (inList && !inList->next)
	{

		// link next to the original list
		inList->next = appendList;

		// link up the append list with the inlist pointers
		appendList->prev  = inList;
		appendList->first = inList->first;
		appendList->next  = NULL;

		// reset pointer to position and return
		appendList = savedFirst;

		// return indicating success
		return ERR_SUCCESS;

	}

	// Return failure if link is impossible
	return ERR_FAILURE;

}

// Generates a magic-quotes string based on an instring (malloced and must be bpfreed)
char * BP_WebAssessmentGenerateMagicQuoteStrFromStr(char *inStr)
{

	// ensure we have an in string
	if(!inStr)
		return NULL;

	// ensure the string to modify is reasonable printable string
	if(!BP_StringIsReasonablePrintableString(inStr, bpstrlen(inStr), BP_TRUE, BP_TRUE))
		return NULL;

	// get the string length
	size_t maxLen = bpstrlen(inStr);

	// out string (returned pointer)
	char *outStr = NULL;

	// loop counters
	size_t x = 0; // modified length
	size_t i = 0; // orig length


	// walk original length
	for (i = 0; i < maxLen; i++)
	{

		switch (inStr[i])
		{

			case '\'':
				x += 2;
				outStr = (char *) bprealloc(outStr, x);
				memcpy(&outStr[x - 2], "\\'", 2);
				break;

			case '"':
				x += 2;
				outStr = (char *) bprealloc(outStr, x);
				memcpy(&outStr[x - 2], "\\\"", 2);
				break;

			default:
				x++;
				outStr = (char *) bprealloc(outStr, x);
				outStr[x - 1] = inStr[i];
				break;
		}

	}

	// append null terminator to out str
	x++;
	if (outStr) {
		outStr = (char *) bprealloc(outStr, x);
		outStr[x - 1] = '\0';
	}

	// return the output buffer
	return outStr;

}

// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%% Test Generators %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

// Generates a url suitable for XSS testing
char * BP_WebAssessmentGenerateXSSAnchorTestSet
(
	char *                      baseTestURL,
	P_BP_WEB_XSS_TEST           test,
	P_BP_HTML_ANCHOR_VAR_LIST   vars,
	P_BP_HTML_ANCHOR_DELIMITERS delims,
	char *                      asciiXSSPayload,
	size_t                      subAtPosition
)
{

	// NULL Checks
	if (!baseTestURL || !vars || !delims || !asciiXSSPayload)
		return NULL;

	// test front and tail cannot either be null
	if(!test->testFront || !test->testTail)
		return NULL;

	// Add the length of the base url
	size_t setSize = bpstrlen(baseTestURL);

	// Add the length of the test
	setSize += bpstrlen(test->testFront);
	setSize += bpstrlen(test->testTail);

	// Append size of start delimiter
	setSize += delims->sLen;
	setSize += bpstrlen(asciiXSSPayload);

	// Save first pointer
	P_BP_HTML_ANCHOR_VAR_LIST varsFirst = vars->first;
	for
	(
		vars = vars->first;
		vars != NULL;
		vars = vars->next
	)
	{

		setSize += vars->nameLen;
		setSize += vars->contentLen;

		setSize += delims->vLen;
		setSize += delims->nLen;

	}

	// reset pointer
	vars = varsFirst;

	// precision allocation
	char *embedStr = (char *) bpcalloc(setSize + 4096, 1);
	if (!embedStr)
		return NULL;

	// a rose by any other name
	memcpy(embedStr, baseTestURL, bpstrlen(baseTestURL));

	// variable position counter
	size_t posCounter = 0;

	// copy in start delimiter
	memcpy(&embedStr[bpstrlen(embedStr)], delims->startDelimiter, bpstrlen(delims->startDelimiter));

	// Walk Variable List
	for
	(
		vars = vars->first;
		vars;
		vars = vars->next
	)
	{

		// if the position indicates we're at the subsitution position, set things up as such
		if (posCounter == subAtPosition)
		{

			snprintf(&embedStr[bpstrlen(embedStr)], setSize, "%s%s%s%s%s", vars->name, delims->valueDelimiter, test->testFront, asciiXSSPayload, test->testTail);

		}
		else
		{

			snprintf(&embedStr[bpstrlen(embedStr)], setSize, "%s%s%s", vars->name, delims->valueDelimiter, vars->content);
		}

		// append next delimiter
		strncat(embedStr, delims->nextDelimiter, delims->nLen);

		// increments to determine proper replacements
		posCounter++;

	}

	// remove last next delimiter
	if (embedStr[bpstrlen(embedStr) - 1] == (char) delims->nextDelimiter[0])
		embedStr[bpstrlen(embedStr) - 1] = '\0';

	// return allocated string
	return embedStr;

}

// Generates a form input string suitable for xss testing
char * BP_WebAssessmentGenerateXSSFormTestSet
(
		P_BP_WEB_XSS_TEST           test,
		P_BP_HTML_FORM_LIST         form,
		P_BP_HTML_ANCHOR_DELIMITERS delims,
		char *                      asciiXSSPayload,
		size_t                      subAtPosition
)
{

	// NULL Checks
	if (!form || !delims || !asciiXSSPayload)
		return NULL;

	// form must have inputs (return null otherwise)
	if (!form->inputs)
		return NULL;

	// Length calculation variable
	size_t setSize = 0;

	// Add the length of the test
	setSize += bpstrlen(test->testFront);
	setSize += bpstrlen(test->testTail);

	// Append size of start delimiter
	setSize += delims->sLen;
	setSize += bpstrlen(asciiXSSPayload);

	// used in the loop below for form input calculations (not allocated)
	P_BP_HTML_INPUT_PROPERTY_LIST tmpName  = NULL;
	P_BP_HTML_INPUT_PROPERTY_LIST tmpValue = NULL;

	// Save first pointer
	P_BP_HTML_INPUT_LIST inputsFirst = form->inputs->first;

	// walk the list and grow buffer to an appropriate size
	P_BP_HTML_INPUT_LIST inputs = form->inputs->first;

	// walk the inputs
	for
	(
		inputs = inputsFirst;
		inputs;
		inputs = inputs->next
	)
	{

		tmpName = HTMLGetInputPropertyByNameI(inputs->properties, "name");
		if (!tmpName)
			continue;

		setSize += tmpName->nLen;
		setSize += tmpName->cLen;

		// value does not have to be set arbitrarily by the developer, if not set
		// add an arbitrary 1024 bytes to the buffer.
		tmpValue = HTMLGetInputPropertyByNameI(inputs->properties, "value");
		if (!tmpValue)
		{
			setSize += 1024;
		}
		else
		{
			setSize += tmpValue->nLen;
			setSize += tmpValue->cLen;
		}

		setSize += delims->vLen;
		setSize += delims->nLen;

	}

	// reset pointer
	inputs = inputsFirst;

	// precision allocation
	char *embedStr = (char *) bpcalloc(setSize + 4096, 1);
	if (!embedStr)
		return NULL;

	// variable position counter
	size_t posCounter = 0;

	// Walk Variable List
	for
	(
		inputs = inputs->first;
		inputs;
		inputs = inputs->next
	)
	{

		if (posCounter == subAtPosition)
		{

			tmpName = HTMLGetInputPropertyByNameI(inputs->properties, "name");
			if (!tmpName)
				break;

			snprintf(&embedStr[bpstrlen(embedStr)], setSize, "%s%s%s%s%s", tmpName->content, delims->valueDelimiter, test->testFront, asciiXSSPayload,
					test->testTail);

		}
		else
		{

			tmpName = HTMLGetInputPropertyByNameI(inputs->properties, "name");
			if (!tmpName)
				break;

			// Value does not have to be set, if its not set use the string ABC
			tmpValue = HTMLGetInputPropertyByNameI(inputs->properties, "value");
			if (!tmpValue)
			{
				snprintf(&embedStr[bpstrlen(embedStr)], setSize, "%s%s%s", tmpName->content, delims->valueDelimiter, "ABC");
			}
			else
			{
				snprintf(&embedStr[bpstrlen(embedStr)], setSize, "%s%s%s", tmpName->content, delims->valueDelimiter, tmpValue->content);
			}

		}

		// append next delimiter
		strncat(embedStr, delims->nextDelimiter, delims->nLen);

		// increments to determine proper replacements
		posCounter++;

	}

	// remove last next delimiter
	if(bpstrlen(embedStr))
	if (embedStr[bpstrlen(embedStr) - 1] == (char) delims->nextDelimiter[0])
		embedStr[bpstrlen(embedStr) - 1] = '\0';

	// return allocated string
	return embedStr;

}


// Generates an anchor test suitable for SQL Injection testing
char * BP_WebAssessmentGenerateSQLAnchorTestSet
(
		char *                      baseTestURL,
		P_BP_WEB_SQLINJ_TEST        test,
		P_BP_HTML_ANCHOR_VAR_LIST   vars,
		P_BP_HTML_ANCHOR_DELIMITERS delims,
		char *                      sqlInjectPayload,
		size_t                      subAtPosition
)
{

	// NULL Checks
	if (!baseTestURL || !vars || !delims || !sqlInjectPayload)
		return NULL;

	// Add the length of the base url
	size_t setSize = bpstrlen(baseTestURL);

	// Add the length of the test
	setSize += bpstrlen(test->testFront);
	setSize += bpstrlen(test->testTail);

	// Append size of start delimiter
	setSize += delims->sLen;
	setSize += bpstrlen(sqlInjectPayload);

	// Save first pointer
	P_BP_HTML_ANCHOR_VAR_LIST varsFirst = vars->first;
	for
	(
		vars = vars->first;
		vars;
		vars = vars->next
	)
	{

		setSize += vars->nameLen;
		setSize += vars->contentLen;

		setSize += delims->vLen;
		setSize += delims->nLen;

	}

	// reset pointer
	vars = varsFirst;

	// precision allocation
	char *embedStr = (char *) bpcalloc(setSize + 4096, 1);
	if (!embedStr)
		return NULL;

	// a rose by any other name
	memcpy(embedStr, baseTestURL, bpstrlen(baseTestURL));

	// variable position counter
	size_t posCounter = 0;

	// copy in start delimiter
	memcpy(&embedStr[bpstrlen(embedStr)], delims->startDelimiter, bpstrlen(delims->startDelimiter));

	// Walk Variable List
	for (vars = vars->first; vars != NULL; vars = vars->next)
	{

		if (posCounter == subAtPosition)
		{

			snprintf(&embedStr[bpstrlen(embedStr)], setSize, "%s%s%s%s%s", vars->name, delims->valueDelimiter, test->testFront, sqlInjectPayload, test->testTail);

		}
		else
		{

			snprintf(&embedStr[bpstrlen(embedStr)], setSize, "%s%s%s", vars->name, delims->valueDelimiter, vars->content);

		}

		// append next delimiter
		strncat(embedStr, delims->nextDelimiter, delims->nLen);

		// increments to determine proper replacements
		posCounter++;

	}

	// remove last next delimiter
	if (embedStr[bpstrlen(embedStr) - 1] == (char) delims->nextDelimiter[0])
		embedStr[bpstrlen(embedStr) - 1] = '\0';

	// return allocated string
	return embedStr;

}

// Generates a form test suitable for SQL Injection testing
char * BP_WebAssessmentGenerateSQLFormTestSet
(
		P_BP_WEB_SQLINJ_TEST        test,
		P_BP_HTML_FORM_LIST         form,
		P_BP_HTML_ANCHOR_DELIMITERS delims,
		char *                      sqlInjectPayload,
		size_t                      subAtPosition
)
{

	// NULL Checks
	if (!form || !delims || !sqlInjectPayload)
		return NULL;

	// form must have inputs (return null otherwise)
	if (!form->inputs)
		return NULL;

	// Length calculation variable
	size_t setSize = 0;

	// Add the length of the test
	setSize += bpstrlen(test->testFront);
	setSize += bpstrlen(test->testTail);

	// Append size of start delimiter
	setSize += delims->sLen;
	setSize += bpstrlen(sqlInjectPayload);

	// used in the loop below for form input calculations (not allocated)
	P_BP_HTML_INPUT_PROPERTY_LIST tmpName;
	P_BP_HTML_INPUT_PROPERTY_LIST tmpValue;

	// Save first pointer
	P_BP_HTML_INPUT_LIST inputsFirst = form->inputs->first;

	// walk the list and grow buffer to an appropriate size
	P_BP_HTML_INPUT_LIST inputs = form->inputs->first;
	for
	(
		inputs = inputsFirst;
		inputs;
		inputs = inputs->next
	)
	{

		tmpName = HTMLGetInputPropertyByNameI(inputs->properties, "name");
		if (!tmpName)
			continue;

		setSize += tmpName->nLen;
		setSize += tmpName->cLen;

		// value does not have to be set arbitrarily by the developer, if not set
		// add an arbitrary 1024 bytes to the buffer.
		tmpValue = HTMLGetInputPropertyByNameI(inputs->properties, "value");

		if (!tmpValue)
		{
			setSize += 1024;
		}
		else
		{
			setSize += tmpValue->nLen;
			setSize += tmpValue->cLen;
		}

		setSize += delims->vLen;
		setSize += delims->nLen;

	}

	// reset pointer
	inputs = inputsFirst;

	// precision allocation
	char *embedStr = (char *) bpcalloc(setSize + 4096, 1);
	if (!embedStr)
		return NULL;

	// variable position counter
	size_t posCounter = 0;

	// Walk Variable List
	for
	(
		inputs = inputs->first;
		inputs;
		inputs = inputs->next
	)
	{

		if (posCounter == subAtPosition)
		{

			tmpName = HTMLGetInputPropertyByNameI(inputs->properties, "name");
			if (!tmpName)
				break;

			snprintf(&embedStr[bpstrlen(embedStr)], setSize, "%s%s%s%s%s", tmpName->content, delims->valueDelimiter, test->testFront, sqlInjectPayload,
					test->testTail);

		}
		else
		{

			tmpName = HTMLGetInputPropertyByNameI(inputs->properties, "name");
			if (!tmpName)
				break;

			// Value does not have to be set, if its not set use the string ABC
			tmpValue = HTMLGetInputPropertyByNameI(inputs->properties, "value");
			if (!tmpValue)
			{
				snprintf(&embedStr[bpstrlen(embedStr)], setSize, "%s%s%s", tmpName->content, delims->valueDelimiter, "ABC");
			}
			else
			{
				snprintf(&embedStr[bpstrlen(embedStr)], setSize, "%s%s%s", tmpName->content, delims->valueDelimiter, tmpValue->content);
			}

		}

		// append next delimiter
		strncat(embedStr, delims->nextDelimiter, delims->nLen);

		// increments to determine proper replacements
		posCounter++;

	}

	// remove last next delimiter
	if(bpstrlen(embedStr))
	if (embedStr[bpstrlen(embedStr) - 1] == (char) delims->nextDelimiter[0])
		embedStr[bpstrlen(embedStr) - 1] = '\0';

	// return allocated string
	return embedStr;

}

// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%% DOMAIN/IP Identification Utilities %%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

// Tests to see if a string is part of a DNS domain, or simply an IP address. Will
// test up until either a 0x00 or a / character.
// eg http://192.168.1.1 vs http://www.test.com
BP_BASE_TARGET_TYPE BP_HTTPStringIsIP(char *testStr, size_t len)
{

	/*
	 enum BP_BASE_TARGET_TYPE {
	 BP_BASE_TARGET_TYPE_HTTP_IP,
	 BP_BASE_TARGET_TYPE_HTTPS_IP,
	 BP_BASE_TARGET_TYPE_HTTP_DNS,
	 BP_BASE_TARGET_TYPE_HTTPS_DNS
	 };


	 if(len < 8)
	 return false;

	 size_t i = 0;
	 for(i = 0; i < len; i++){



	 }
	 */
	return BP_BASE_TARGET_TYPE_HTTPS_DNS;
}


// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%% REQUEST STRING GENERATION/EXCLUSION %%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/*
 * Explanation:
 * These routines are used for the generation of request strings used with
 * either the GET or POST methods.  These routines take into account the values
 * set within the assessment structure, and based upon them either generate a
 * valid request string, or return NULL to indicate that an exclusion has
 * occured.  These routines are primarily utilized within the Run*Tests() series
 * of functions which are most often ran from RunAssessment().
 */

char * BP_WebAssessmentGenerateAnchorRequest(P_BP_WEB_ASSESSMENT assessment, P_BP_HTML_ANCHOR_LIST anchor)
{

	/*
	 * Step 1) Check anchor protocol to determine if its http/https.
	 * 		a) If anchor is http/https (non-relative) check to make sure
	 * 		   its in the same domain.  If not, return NULL.
	 *         note: Domain is considered, not subdomain.
	 *
	 */

	/*

	 // IMPORTANT: if the anchor protocol is http, and is not found to
	 // be the same as the base URL, then omit it from evaluation. A
	 // relative anchor always has a type of NONE because it is identified
	 // without a http:// prefix.
	 if((anchors->proto == BP_ANCHOR_PROTO_HTTP || anchors->proto == BP_ANCHOR_PROTO_HTTPS) &&
	 memcmp(assessment->baseAssessmentURL, anchors->href, bpstrlen(assessment->baseAssessmentURL)) != 0)
	 continue;

	 // If the protocol is not 0, then its offsite (change later)
	 if((anchors->proto == BP_ANCHOR_PROTO_HTTP || anchors->proto == BP_ANCHOR_PROTO_HTTPS) &&
	 memcmp(assessment->baseAssessmentURL, anchors->href, bpstrlen(assessment->baseAssessmentURL)) == 0){


	 snprintf(anchorTest, anchorLen, "%s",
	 anchors->relativePath);

	 } else {

	 baseTestURL = HTTPStripScript(assessment->baseAssessmentURL, bpstrlen(assessment->baseAssessmentURL));
	 snprintf(anchorTest, anchorLen, "%s%s", baseTestURL, anchors->relativePath);

	 }

	 // destroy test url if set then nullify for loop
	 if(baseTestURL){
	 bpfree(baseTestURL);
	 baseTestURL = NULL;
	 }

	 */
	return NULL;
}

char * BP_WebAssessmentGenerateFormRequest(P_BP_WEB_ASSESSMENT assessment, P_BP_HTML_FORM_LIST form)
{

	/*
	 // IMPORTANT: if the anchor protocol is http, and is not found to
	 // be the same as the base URL, then omit it from evaluation. A
	 // relative anchor always has a type of NONE because it is identified
	 // without a http:// prefix.
	 if((anchors->proto == BP_ANCHOR_PROTO_HTTP || anchors->proto == BP_ANCHOR_PROTO_HTTPS) &&
	 memcmp(assessment->baseAssessmentURL, anchors->href, bpstrlen(assessment->baseAssessmentURL)) != 0)
	 continue;

	 // If the protocol is not 0, then its offsite (change later)
	 if((anchors->proto == BP_ANCHOR_PROTO_HTTP || anchors->proto == BP_ANCHOR_PROTO_HTTPS) &&
	 memcmp(assessment->baseAssessmentURL, anchors->href, bpstrlen(assessment->baseAssessmentURL)) == 0){


	 snprintf(anchorTest, anchorLen, "%s",
	 anchors->relativePath);

	 } else {

	 baseTestURL = HTTPStripScript(assessment->baseAssessmentURL, bpstrlen(assessment->baseAssessmentURL));
	 snprintf(anchorTest, anchorLen, "%s%s", baseTestURL, anchors->relativePath);

	 }

	 // destroy test url if set then nullify for loop
	 if(baseTestURL){
	 bpfree(baseTestURL);
	 baseTestURL = NULL;
	 }
	 */
	return NULL;
}

// prints out a representation of the Application engine list
void BP_PrintAppEngineResultList(P_BP_WEB_ASSESSMENT assessment)
{

	// null check on assessment
	if (!assessment)
		return;

	// Get results pointer from structure and check results pointer
	P_BP_WEB_APPSERVER_TEST_RESULT inList = assessment->appErrorResults;
	if (!inList)
		return;

	// list iterator
	size_t x = 0;

	// walk the list printing out structure values
	for
	(
		inList = inList->first;
		inList;
		inList = inList->next
	)
	{

		printf("\n\t\t[+] App Engine Result %p", inList);

		// target type (anchor, form, or cookie)
		printf("\n\t\tAppEngine Target Type: %u", inList->targetType);

		// --- ANCHORS ------------------------

		if (inList->anchor)
		{

			printf("\n\t\tAnchor Test: %s", inList->anchorActualTest);
			printf("\n\t\tAnchor Pointer: %p", inList->anchor);
			printf("\n\t\tAnchor Var Pointer: %p", inList->vulnVar);
			printf("\n\t\tAnchor Var Position: %u", inList->anchorVarPosition);
		}

		// --- FORMS -------------------------------

		if (inList->form) {

			printf("\n\t\tAnchor Test: %s", inList->actualInputTest);
			printf("\n\t\tAnchor Pointer: %p", inList->form);
			printf("\n\t\tAnchor Var Pointer: %p", inList->input);
			printf("\n\t\tAnchor Var Position: %u", inList->inputPosition);

		}

		// Appserver engine detection based around alert
		printf("\n\t\tEngines Detected: ");
		for (x = 0; x < inList->engineDetectionCount; x++)
			printf("%u, ", inList->enginesDetected[x]);

		// PHP engine detection based around alert
		printf("\n\t\tPHP Detections: ");
		for (x = 0; x < inList->phpTestMatchesMade; x++)
			printf("%u, ", inList->phpTestMatchIndexes[x]);

		// ASP engine detection based around alert
		printf("\n\t\tASP Detections: ");
		for (x = 0; x < inList->aspTestMatchesMade; x++)
			printf("%u, ", inList->aspTestMatchIndexes[x]);

		// JSP engine detection based around alert
		printf("\n\t\tJSP Detections: ");
		for (x = 0; x < inList->jspTestMatchesMade; x++)
			printf("%u, ", inList->jspTestMatchIndexes[x]);

		// CFM engine detection based around alert
		printf("\n\t\tCFM Detections: ");
		for (x = 0; x < inList->cfmTestMatchesMade; x++)
			printf("%u, ", inList->cfmTestMatchIndexes[x]);

		// .NET engine detection based around alert
		printf("\n\t\t.NET Detections: ");
		for (x = 0; x < inList->dnetTestMatchesMade; x++)
			printf("%u, ", inList->dnetTestMatchIndexes[x]);

	}

}

// prints out a representation of the SQL Test list for use with
// debugging.
void BP_PrintSqlResultList(P_BP_WEB_ASSESSMENT assessment)
{

	// null check on assessment
	if (!assessment)
		return;

	// Get results pointer from structure and check results pointer
	P_BP_WEB_SQLINJ_TEST_RESULT inList = assessment->sqlResults;
	if (!inList)
		return;

	// loop iterator
	size_t x = 0;

	// Walk the list
	for
	(
		inList = inList->first;
		inList;
		inList = inList->next
	)
	{

		printf("\n\n\t\t[+] SQL Result:  %p", inList);

		// --- ANCHORS ------------------------

		// anchor test string
		printf("\n\n\t\t Test String: %s", inList->anchorActualTest);

		// Html anchor entity pointers (only filled out if found in anchor)
		printf("\n\n\t\t Anchor Pointer:                  %p", inList->anchor);

		// position in the variable list for the anchor in which
		// vulnVar occurs.
		printf("\n\t\t Vulnerable Var Position in List: %u", inList->anchorVarPosition);

		// --- FORMS -------------------------------

		// print out input test string
		printf("\n\t\t Form Input Test Str: %s", inList->actualInputTest);

		// Html form entity pointers (only filled out if found in form input)
		printf("\n\t\t Form Pointer:                    %p", inList->form);

		// Position in the input list which the vulnInput occurs.
		printf("\n\t\t Vulnerable Input Position in List: %u", inList->inputPosition);

		// Test index
		printf("\n\t\t Test Index:                        %i", inList->testIndex);

		// Walk the sql engine detections
		size_t x = 0;
		printf("\n\t\t SQL Engines Detected:              ");

		// print out the detected engines
		if (inList->engineDetectionCount == 0)
			printf(" No detected engines.");

		for (x = 0; x < inList->engineDetectionCount; x++)
			switch (inList->enginesDetected[x]) {
			case BP_SQLINJ_ENGINE_NONE:
				printf("None Detected (%u), ", inList->targetType);
				break;
			case BP_SQLINJ_ENGINE_MYSQL:
				printf("MYSQL, ");
				break;
			case BP_SQLINJ_ENGINE_MSQL:
				printf("MSQL, ");
				break;
			case BP_SQLINJ_ENGINE_POSTGRES:
				printf("Postgres, ");
				break;
			case BP_SQLINJ_ENGINE_ORACLE:
				printf("Oracle, ");
				break;
			default:
				printf("Unknown Engine Type (%u), ", inList->enginesDetected[x]);
				break;

			}

		// target type (anchor, form, or cookie)
		printf("\n\t\t Target Type:                       ");
		switch (inList->targetType) {
		case BP_SQLINJ_TARGET_TYPE_NONE:
			printf("No Target Type Set");
			break;
		case BP_SQLINJ_TARGET_TYPE_ANCHOR:
			printf("Anchor");
			break;
		case BP_SQLINJ_TARGET_TYPE_FORM:
			printf("Form");
			break;
		case BP_SQLINJ_TARGET_TYPE_COOKIE:
			printf("Cookie");
			break;
		}

		// number of UNIQUE mysql matches made
		if (inList->mysqlTestMatchesMade > 0) {
			printf("\n");
			printf("\n\t\t MySQL Signature Matches Found:     %i", inList->mysqlTestMatchesMade);

			printf("\n\t\t MySQL Err Index Matches: ..");
			for (x = 0; x < inList->mysqlTestMatchesMade; x++)
				printf("\n\t[-%u-] %s", inList->mysqlTestMatchIndexes[x], BP_MysqlGetDescriptionFromIndex(assessment->mysqlErrCodes,
						inList->mysqlTestMatchIndexes[x]));

		}

		// number of UNIQUE msql matches made
		if (inList->msqlTestMatchesMade > 0) {
			printf("\n");
			printf("\n\t\t MSQL Signature Matches Found:     %i", inList->msqlTestMatchesMade);

			printf("\n\t\t MSQL Err Index Matches: ..");
			for (x = 0; x < inList->msqlTestMatchesMade; x++)
				printf("\n\t[-%u-] %s", inList->msqlTestMatchIndexes[x], BP_MsqlGetDescriptionFromIndex(assessment->msqlErrCodes,
						inList->msqlTestMatchIndexes[x]));

		}

		// number of UNIQUE oracle matches made
		if (inList->oracleTestMatchesMade > 0) {
			printf("\n");
			printf("\n\t\t Oracle Signature Matches Found:     %i", inList->oracleTestMatchesMade);

			printf("\n\t\t Oracle Err Index Matches: ..");
			for (x = 0; x < inList->oracleTestMatchesMade; x++)
				printf("\n\t[-%u-] %s", inList->oracleTestMatchIndexes[x], BP_OracleGetDescriptionFromIndex(assessment->oracleErrCodes,
						inList->oracleTestMatchIndexes[x]));

		}

		// number of UNIQUE odbc matches made
		if (inList->odbcTestMatchesMade > 0) {
			printf("\n");
			printf("\n\t\t ODBC Signature Matches Found:     %i", inList->odbcTestMatchesMade);

			printf("\n\t\t ODBC Err Index Matches: ..");
			for (x = 0; x < inList->odbcTestMatchesMade; x++)
				printf("\n\t[-%u-] %s", inList->odbcTestMatchIndexes[x], BP_ODBCGetDescriptionFromIndex(assessment->odbcErrCodes,
						inList->odbcTestMatchIndexes[x]));

		}

		// number of UNIQUE postgres matches made
		if (inList->postgresTestMatchesMade > 0) {
			printf("\n");
			printf("\n\t\t Postgres Signature Matches Found:     %i", inList->postgresTestMatchesMade);

			printf("\n\t\t Postgres Err Index Matches: ..");
			for (x = 0; x < inList->postgresTestMatchesMade; x++)
				printf("\n\t[-%u-] %s", inList->postgresTestMatchIndexes[x], BP_PostgresGetDescriptionFromIndex(assessment->postgresErrCodes,
						inList->postgresTestMatchIndexes[x]));

		}

		printf("\n\t\t\t first: %p", inList->first);
		printf("\n\t\t\t prev : %p", inList->prev);
		printf("\n\t\t\t next : %p", inList->next);

	}

	return;
}

// Displays the stack of blind sql injection results.  The results
// are stored in a stack of structures rather than the list format of
// the other results due to it being a simply better design.  In the future
// i plan to reimplement all result lists as stacks in this fashion.
void BP_PrintBlindSQLiResults(P_BP_WEB_ASSESSMENT assessment)
{
	if(!assessment)
		return;
	if(!assessment->bsqli_results)
		return;

	printf("\n\t [+] Blind SQLi Results Stack: %p", assessment->bsqli_results);


	size_t j = 0;
	for(; j < assessment->bsqli_result_count; j++)
	{

		// if the type is NONE (0), we are at a dead end
		// as this condition should never be possible exept
		// at the truncating element.
		if(!assessment->bsqli_results[j].type)
			break;

		printf("\n\t\t  - target result id:  %u", assessment->bsqli_results[j].db_result_id);
		printf("\n\t\t  - target request id: %u", assessment->bsqli_results[j].db_request_log_id);

		// display the actual test string used
		// the blind sqli detected type
		switch(assessment->bsqli_results[j].type)
		{
			case BP_WEB_BLINDSQLI_TYPE_TIME_BENCHMARK:
				printf("\n\t\t bsqli type:  TIME DELAY/HEAVY QUERY DETECTION");
				printf("\n\t\t request delayed by: %u(s)", assessment->bsqli_results[j].actual_request_time);
				break;
			case BP_WEB_BLINDSQLI_TYPE_UNION_SELECT:
				printf("\n\t\t bsqli type: UNION SELECT");
				break;
			case BP_WEB_BLINDSQLI_TYPE_NONE:
				printf("\n\t\t bsqli type: NO TYPE, ERROR!");
				break;
			default:
				break;
		}
		printf("\n\t\t bsqli_test_vals:");
		printf("\n\t\t    http get:    %s", assessment->bsqli_results[j].http_get);
		printf("\n\t\t    http post:   %s", assessment->bsqli_results[j].http_post);
		printf("\n\t\t    http cookie: %s", assessment->bsqli_results[j].http_cookie);
		printf("\n");

	}

	return;
}


// Utility to print out xss resuls
void BP_PrintXssResultList(P_BP_WEB_XSS_TEST_RESULT inList) {

	if (!inList)
		return;

	for (inList = inList->first; inList != NULL; inList = inList->next) {

		printf("\n\n\t\t [+] XSS Test Result: %p", inList);
		printf("\n\t\t Test Index:        %u", inList->testIndex);

		// target type (anchor, form, or cookie)
		printf("\n\t\t Target Type:       %u", inList->targetType);

		// Normal match
		printf("\n\t\t Normal (non-magic quote) Match: %s", inList->match ? "yes" : "no");

		// Magic Quotes Match Flag
		printf("\n\t\t Magic Quote Match:              %s", inList->magicQuotesMatch ? "yes" : "no");

		printf("\n");

		// Anchor Information
		if (inList->anchorActualTest != NULL)
			printf("\n\t\t Actual Anchor Test: %s", inList->anchorActualTest);
		if (inList->anchor != NULL)
			printf("\n\t\t Anchor URL: %s", inList->anchor->href);
		printf("\n\t\t Anchor List Pointer:                  %p", inList->anchor);
		printf("\n\t\t Anchor Var List Pointer:              %p", inList->vulnVar);
		printf("\n\t\t Vulnerable Variable Position in List: %u", inList->anchorVarPosition);
		printf("\n");

		// print out input test string
		printf("\n\t\t Form Input Test Str: %s", inList->formActualTest);
		printf("\n\t\t Form List Pointer:                    %p", inList->form);
		printf("\n\t\t Form Input List Pointer:              %p", inList->vulnInput);
		printf("\n\t\t Vulnerable Input Position in List:    %u", inList->inputVarPosition);

		// List pointers
		printf("\n\n\t\t\t first: %p", inList->first);
		printf("\n\t\t\t prev:  %p", inList->prev);
		printf("\n\t\t\t next:  %p", inList->next);

		printf("\n");
	}

	return;
}

// Utility function to print out the values in the assessment
void BP_PrintAssessments(P_BP_WEB_ASSESSMENT assessment)
{

	// exit on null check
	if (!assessment) {
		printf("\n PRINT_ERR[+] NULL ASSESSMENT LIST PROVIDED.");
		return;
	}

	// Walk the assessment table and print out values
	for
	(
			assessment = assessment->first;
			assessment;
			assessment = assessment->next
	)
	{

		printf("\n [+] Assessment: %p", assessment);
		printf("\n\n\t [+] -----------------------");
		printf("\n\t Assessment Base URL:                  %s", assessment->baseAssessmentURL);
		printf("\n\t Assessment Session Pointer:           %p", assessment->session);
		printf("\n\t Assessment Extraction Pointer:        %p", assessment->pageExtraction);
		printf("\n");
		printf("\n\t Assessment SQL Check Table Pointer:   %p", assessment->sqlChecks);
		printf("\n\t Assessment SQL Results Table Pointer: %p", assessment->sqlResults);
		printf("\n\t --- MySQL Error Code Check Table: ....%p", assessment->mysqlErrChecks);
		printf("\n");
		printf("\n\t Assessment XSS Check Table Pointer:   %p", assessment->xssChecks);
		printf("\n\t Assessment XSS Results Table Pointer: %p", assessment->xssResults);

		printf("\n\n\n\t [+] Xss Table:");
		if (assessment->xssResults)
			BP_PrintXssResultList(assessment->xssResults);
		else
			printf("(empty)");

		printf("\n\n\n\t [+] Sql Inject Table:");
		if (assessment->sqlResults)
			BP_PrintSqlResultList(assessment);
		else
			printf("(empty)");

		printf("\n\n\n\t [+] AppEngine Detection Table (err based):");
		if (assessment->appErrorResults)
			BP_PrintAppEngineResultList(assessment);
		else
			printf("(empty)");


		printf("\n\n\n\t [+] Blind SQLi Detection Table (inferred detection):");
		if(assessment->bsqli_results)
			BP_PrintBlindSQLiResults(assessment);
		else
			printf("(empty)");


		// arbitrary list pointers
		printf("\n ------------------");
		printf("\n\t\t first: %p", assessment->first);
		printf("\n\t\t prev:  %p", assessment->prev);
		printf("\n\t\t next:  %p", assessment->next);

	}

}

// Gets the anchor variable lengths (total length of all variable names)
size_t BP_GetAnchorVarMaxLengths(P_BP_HTML_ANCHOR_VAR_LIST anchorVars) {

	// variable returned from routine which contains the size += for a
	// allocation to be made with.
	size_t nameLengths = 0;

	// walk the anchor variable list and set the arbitrary parameters
	for (anchorVars = anchorVars->first->next; anchorVars != NULL; anchorVars = anchorVars->next) {

		// Name length + content length + 16 bytes arbitrary padding
		nameLengths += anchorVars->nameLen;
		nameLengths += anchorVars->contentLen;
		nameLengths += 16;

	}

	// return a size proper for storing results
	return nameLengths;

}

// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%% ASSESSMENT DECONSTRUCTORS %%%%%%%%%%%%%%%%%%%%%%%%%%


// Destroys an appError Result List
size_t BP_DestroyAppErrorResults(P_BP_WEB_APPSERVER_TEST_RESULT results)
{

	// ensure we have results
	if(!results)
		return ERR_FAILURE;

	// save first pointer (makes walking list elements easier)
	P_BP_WEB_APPSERVER_TEST_RESULT savedFirst = results->first;

	// used for destroying list elements one at a time
	P_BP_WEB_APPSERVER_TEST_RESULT savedNext = NULL;




	// IMPORTANT NOTE: DO NOT DESTROY FORMS OR ANCHORS, THOSE ARE DESTROYED BY HTML
	// UTILITIES.

	for
	(
		results = results->first;
		results;
		results = results->next
	)
	{

		if(results->actualInputTest)
			bpfree(results->actualInputTest);
		if(results->anchorActualTest)
			bpfree(results->anchorActualTest);

		if(results->enginesDetected)
		{
			bpfree(results->enginesDetected);
			results->engineDetectionCount = 0;
			results->enginesDetected = NULL;
		}

		if(results->aspTestMatchIndexes)
		{
			bpfree(results->aspTestMatchIndexes);
			results->aspTestMatchIndexes = NULL;

		}
		if(results->cfmTestMatchIndexes)
		{
			bpfree(results->cfmTestMatchIndexes);
			results->cfmTestMatchIndexes = NULL;
		}

		if(results->dnetTestMatchIndexes)
		{
			bpfree(results->dnetTestMatchIndexes);
			results->dnetTestMatchIndexes = NULL;
		}

		if(results->jspTestMatchIndexes)
		{
			bpfree(results->jspTestMatchIndexes);
			results->jspTestMatchIndexes = NULL;
		}

		if(results->phpTestMatchIndexes)
		{
			bpfree(results->phpTestMatchIndexes);
			results->phpTestMatchIndexes = NULL;
		}




	}

	// Destroy results one by one
	for
	(
		results = savedFirst;
		results;
		results = savedNext
	)
	{

		// save next pointer
		savedNext = results->next;

		// destroy element
		bpfree(results);

		// ensure we have a next pointer
		if(!savedNext)
			break;

	}

	// return indicating success
	return ERR_SUCCESS;

}

// Destroys a Valid Assessment
size_t BP_DestroyAssessment
(
		P_BP_WEB_ASSESSMENT assessment,
		bool destroySession,
		bool destroyExtraction,
		bool destroyResults
)
{



	// ensure we have an assessment to work with
	if (!assessment)
		return ERR_FAILURE;

	// URL Base for the assessment
	if (assessment->baseAssessmentURL)
	{
		bpfree(assessment->baseAssessmentURL);
		assessment->baseAssessmentURL = NULL;
	}

	// session associated with the assessment (destroyed/created seperately :: Only a ptr)
	if (destroySession)
	if (assessment->session)
	{
		BP_HTTPDestroySession(assessment->session);
		assessment->session = NULL;
	}

	// decoded html associated with the assessment  (destroyed/created seperately :: Only a ptr)
	if (destroyExtraction)
	if (assessment->pageExtraction)
	{
		HTMLDestroyExtraction(assessment->pageExtraction);
		assessment->pageExtraction = NULL;
	}

	// format character table to use when generating test sets
	if (assessment->fmtTable)
	{
		BP_DestroyPointerArray((void **) assessment->fmtTable, BP_WebExploitGetFormatTableEntries());
		bpfree(assessment->fmtTable);
		assessment->fmtTable = NULL;
	}

	// ---------- REQUEST RANDOMIZATION VARS ----------------------

	// User strings used by the assessment
	if (assessment->userAgentPool)
	{
		BP_DestroyPointerArray((void **) assessment->userAgentPool, BP_HTTPUserAgentCount(assessment->userAgentPool));
		bpfree(assessment->userAgentPool);
		assessment->userAgentPool = NULL;
	}

	// Proxy strings
	if (assessment->proxyList)
	{
		bpfree(assessment->proxyList);
		assessment->proxyList = NULL;
	}

	// ---------- STATUS CODES ------------------------------------

	// http status code array
	if (assessment->statusCodes)
	{
		bpfree(assessment->statusCodes);
		assessment->statusCodes = NULL;
	}

	// --------------------------------------

	// XSS Check List to Use
	if (assessment->xssChecks)
	{
		BP_DestroyXSSTests(assessment->xssChecks, assessment->xssChecksCount);
		assessment->xssChecks = NULL;
	}

	// (Filled out Dynamically through Run) Results structure for xss
	// checks.
	if (destroyResults)
	{

		if (assessment->xssResults)
		{

			// destroy entire list
			BP_DestroyXSSResults(assessment->xssResults);
			assessment->xssResults = NULL;

		}

	}

	// destroy app error results
	if(destroyResults)
	{

		if(assessment->appErrorResults)
		{
			BP_DestroyAppErrorResults(assessment->appErrorResults);
			assessment->appErrorResults = NULL;
		}

	}

	// Payload used for xss checks (default is alert(1);)
	if (assessment->xssPayload)
	{
		bpfree(assessment->xssPayload);
		assessment->xssPayload = NULL;
	}

	// --------------------------------------


	// SQL Injection Check List to Use
	if (assessment->sqlChecks)
	{
		BP_DestroySQLTests(assessment->sqlChecks, assessment->sqlCheckCount);
		assessment->sqlChecks = NULL;
	}

	// Results list/structure for sql checks
	if (assessment->sqlResults)
	{
		BP_DestroySQLResults(assessment->sqlResults->first);
		assessment->sqlResults = NULL;
	}

	// Payload destined for server
	if (assessment->sqlInjectPayload)
	{
		bpfree(assessment->sqlInjectPayload);
		assessment->sqlInjectPayload = NULL;
	}

	// ----------- MYSQL -------------------------------------------

	// Error Table which contains unmodified/unparsed table of errors
	if (assessment->mysqlErrCodes)
	{
		BP_DestroyMySQLErrCodes(assessment->mysqlErrCodes);
		assessment->mysqlErrCodes = NULL;
	}

	// Error Checks Related to Mysql Used for Identifying SQL Injections
	if (assessment->mysqlErrChecks)
	{
		BP_DestroyFmtErrTests(assessment->mysqlErrChecks, assessment->mysqlErrCheckCount);
		assessment->mysqlErrChecks = NULL;
		assessment->mysqlErrCheckCount = 0;
	}

	// ----------- MSQL -------------------------------------------

	// Error Table which contains unmodified/unparsed table of errors
	if (assessment->msqlErrCodes)
	{
		BP_DestroyMSQLErrCodes(assessment->msqlErrCodes);
		assessment->msqlErrCodes = NULL;
	}

	// Error Checks Related to Msql Used for Identifying SQL Injections
	if (assessment->msqlErrChecks)
	{
		BP_DestroyFmtErrTests(assessment->msqlErrChecks, assessment->msqlErrCheckCount);
		assessment->msqlErrChecks     = NULL;
		assessment->msqlErrCheckCount = 0;
	}

	// ----------- ORACLE -------------------------------------------

	// Error Table which contains unmodified/unparsed table of errors
	if (assessment->oracleErrCodes)
	{
		BP_DestroyOracleErrCodes(assessment->oracleErrCodes);
		assessment->oracleErrCodes = NULL;
	}

	// Error Checks Related to Msql Used for Identifying SQL Injections
	if (assessment->oracleErrChecks)
	{
		BP_DestroyFmtErrTests(assessment->oracleErrChecks, assessment->oracleErrCheckCount);
		assessment->oracleErrChecks = NULL;
		assessment->oracleErrCheckCount = 0;
	}

	// ----------- ODBC -------------------------------------------

	// Error Table which contains unmodified/unparsed table of errors
	if (assessment->odbcErrCodes)
	{
		BP_DestroyODBCErrCodes(assessment->odbcErrCodes);
		assessment->odbcErrCodes = NULL;
	}

	// Error Checks Related to ODBC Used for Identifying SQL Injections
	if (assessment->odbcErrChecks)
	{
		BP_DestroyFmtErrTests(assessment->odbcErrChecks, assessment->odbcErrCheckCount);
		assessment->odbcErrChecks     = NULL;
		assessment->odbcErrCheckCount = 0;
	}

	// ----------- Postgres -------------------------------------------

	// Error Table which contains unmodified/unparsed table of errors
	if (assessment->postgresErrCodes)
	{
		BP_DestroyPostgresErrCodes(assessment->postgresErrCodes);
		assessment->postgresErrCodes = NULL;
	}

	// Error Checks Related to Postgres Used for Identifying SQL Injections
	if (assessment->postgresErrChecks)
	{
		BP_DestroyFmtErrTests(assessment->postgresErrChecks, assessment->postgresErrCheckCount);
		assessment->postgresErrChecks = NULL;
		assessment->postgresErrCheckCount = 0;
	}

	// Main Application Error List (contains any errors found during assessment)
	if (assessment->appErrorResults)
	{
		//P_BP_WEB_APPSERVER_TEST_RESULT appErrorResults;
		BP_DestroyAppErrorResults(assessment->appErrorResults);
		assessment->appErrorResults = NULL;

	}

	// ------------------ PHP -----------------------------------

	// Error Table which contains unmodified/unparsed table of errors
	if (assessment->phpErrCodes)
	{
		BP_DestroyPHPErrCodes(assessment->phpErrCodes);
		assessment->phpErrCodes = NULL;
	}

	// Error Checks Related to PHP Used for Identifying PHP Errors
	if (assessment->phpErrChecks)
	{
		BP_DestroyFmtErrTests(assessment->phpErrChecks, assessment->phpErrCheckCount);
		assessment->phpErrChecks = NULL;
		assessment->phpErrCheckCount = 0;
	}

	// ------------------ JSP -----------------------------------

	// Error Table which contains unmodified/unparsed table of errors
	if (assessment->jspErrCodes)
	{
		BP_DestroyJSPErrCodes(assessment->jspErrCodes);
		assessment->jspErrCodes = NULL;
	}

	// Error Checks Related to JSP Used for Identifying PHP Errors
	if (assessment->jspErrChecks) {
		BP_DestroyFmtErrTests(assessment->jspErrChecks, assessment->jspErrCheckCount);
		assessment->jspErrChecks     = NULL;
		assessment->jspErrCheckCount = 0;
	}

	// ------------------ ASP -----------------------------------

	// error code check array
	if (assessment->aspErrCodes)
	{
		BP_DestroyASPErrCodes(assessment->aspErrCodes);
		assessment->aspErrCodes = NULL;
	}

	// Error Checks Related to ASP Used for Identifying errors
	if (assessment->aspErrChecks)
	{
		BP_DestroyFmtErrTests(assessment->aspErrChecks, assessment->aspErrCheckCount);
		assessment->aspErrChecks = NULL;
		assessment->aspErrCheckCount = NULL;
	}

	// ------------------ CFM -----------------------------------


	// Error Table which contains unmodified/unparsed table of errors
	if (assessment->cfmErrCodes)
	{
		BP_DestroyCFMErrCodes(assessment->cfmErrCodes);
		assessment->cfmErrCodes = NULL;
	}

	// Error Checks Related to Cold Fusion Used for Identifying Cold Fusion Errors
	if (assessment->cfmErrChecks)
	{
		BP_DestroyFmtErrTests(assessment->cfmErrChecks, assessment->cfmErrCheckCount);
		assessment->cfmErrChecks = NULL;
		assessment->cfmErrCheckCount = 0;
	}

	// ------------------ .NET -----------------------------------

	// Error Table which contains unmodified/unparsed table of errors
	if (assessment->dnetErrCodes)
	{
		BP_DestroyDNETErrCodes(assessment->dnetErrCodes);
		assessment->dnetErrCodes = NULL;
	}

	// Error Checks Related to .NET Used for Identifying .NET Errors
	if (assessment->dnetErrChecks)
	{
		BP_DestroyFmtErrTests(assessment->dnetErrChecks, assessment->dnetErrCheckCount);
		assessment->dnetErrChecks     = NULL;
		assessment->dnetErrCheckCount = 0;
	}

	// destroy structure --------------
	bpfree(assessment);

	// return indicating success
	return ERR_SUCCESS;

}

