/*
 * BP-WebExploitationBlindSQLiDetection.cc
 *
 *  Created on: Dec 11, 2011
 *      Author: root
 */

#include "../../../../include/BP-Main.h"

// Generate blind sqli anchor test set.
char * BP_WebAssessmentGenerateBlindSQLiAnchorTestSet
(
		char *                      baseTestURL,
		P_BP_WEB_BLIND_SQLINJ_TEST  test,
		P_BP_HTML_ANCHOR_VAR_LIST   vars,
		P_BP_HTML_ANCHOR_DELIMITERS delims,
		char *                      asciiXSSPayload,
		size_t                      subAtPosition
)
{

	// NULL Checks
	if (!baseTestURL || !vars || !delims)
		return NULL;

	// test front and tail cannot either be null
	if(!test->testFront)
		return NULL;

	// Add the length of the base url
	size_t setSize = bpstrlen(baseTestURL);

	// Add the length of the test
	if(test->testFront)
		setSize += bpstrlen(test->testFront);
	if(test->testTail)
		setSize += bpstrlen(test->testTail);

	// Append size of start delimiter
	setSize += delims->sLen;
	if(asciiXSSPayload)
		setSize += bpstrlen(asciiXSSPayload);

	// Save first pointer
	P_BP_HTML_ANCHOR_VAR_LIST varsFirst = vars->first;

	// Walk var list to calculate the set size
	for
	(
		vars = vars->first;
		vars;
		vars = vars->next
	)
	{

		// increase the set size by the name length
		setSize += vars->nameLen;

		// increase the set size by the content length
		setSize += vars->contentLen;

		// increase the set size by the vlen
		setSize += delims->vLen;

		// increase the set size by the nlen
		setSize += delims->nLen;

	}

	// reset pointer
	vars = varsFirst;

	// allocate space for the set
	char *embedStr = (char *) bpcalloc(setSize + 4096, 1);
	if (!embedStr)
		return NULL;

	// copy in the base test url first
	memcpy(embedStr, baseTestURL, bpstrlen(baseTestURL));

	// variable position counter
	size_t posCounter = 0;

	// copy in start delimiter
	memcpy(&embedStr[bpstrlen(embedStr)], delims->startDelimiter, bpstrlen(delims->startDelimiter));

	// Walk var list and fill in data
	for
	(
		vars = vars->first;
		vars;
		vars = vars->next
	)
	{

		if (posCounter == subAtPosition)
		{

			snprintf(&embedStr[bpstrlen(embedStr)], setSize, "%s%s%s%s%s", vars->name, delims->valueDelimiter, test->testFront, asciiXSSPayload?asciiXSSPayload:"", test->testTail?test->testTail : "");

		}
		else
		{

			snprintf(&embedStr[bpstrlen(embedStr)], setSize, "%s%s%s", vars->name, delims->valueDelimiter, vars->content);

		}

		// append next delimiter
		strncat(embedStr, delims->nextDelimiter, delims->nLen);

		// increment the position
		posCounter++;

	}

	// remove last next delimiter
	if (embedStr[bpstrlen(embedStr) - 1] == (char) delims->nextDelimiter[0])
		embedStr[bpstrlen(embedStr) - 1] = '\0';

	// return allocated string
	return embedStr;

}

// Generates a form input string suitable for blind sql injection testing.
char * BP_WebAssessmentGenerateBlindSQLiFormTestSet
(
	P_BP_WEB_BLIND_SQLINJ_TEST  test,
	P_BP_HTML_FORM_LIST         form,
	P_BP_HTML_ANCHOR_DELIMITERS delims,
	char *                      asciiXSSPayload,
	size_t                      subAtPosition
)
{

	// NULL Checks
	if (!form || !delims)
		return NULL;

	// form must have inputs (return null otherwise)
	if (!form->inputs)
		return NULL;

	// Length calculation variable
	size_t setSize = 0;

	// Add the length of the test
	if(test->testFront)
		setSize += bpstrlen(test->testFront);
	if(test->testTail)
		setSize += bpstrlen(test->testTail);

	// Append size of start delimiter
	setSize += delims->sLen;
	if(asciiXSSPayload)
		setSize += bpstrlen(asciiXSSPayload);

	// used in the loop below for form input calculations (not allocated)
	P_BP_HTML_INPUT_PROPERTY_LIST tmpName   = NULL;
	P_BP_HTML_INPUT_PROPERTY_LIST tmpValue  = NULL;

	// Save first pointer
	P_BP_HTML_INPUT_LIST inputsFirst = form->inputs->first;

	// walk the list and grow buffer to an appropriate size
	P_BP_HTML_INPUT_LIST inputs = form->inputs->first;


	// walk inputs and generate the correct size for our buffer
	for
	(
		inputs = inputsFirst;
		inputs;
		inputs = inputs->next
	)
	{

		tmpName = HTMLGetInputPropertyByNameI(inputs->properties, "name");
		if (!tmpName)
			continue;

		setSize += tmpName->nLen;
		setSize += tmpName->cLen;

		// value does not have to be set arbitrarily by the developer, if not set
		// add an arbitrary 1024 bytes to the buffer.
		tmpValue = HTMLGetInputPropertyByNameI(inputs->properties, "value");
		if (!tmpValue)
		{
			setSize += 1024;
		}
		else
		{
			setSize += tmpValue->nLen;
			setSize += tmpValue->cLen;
		}

		setSize += delims->vLen;
		setSize += delims->nLen;

	}

	// reset pointer
	inputs = inputsFirst;

	// allocate space for the test
	char *embedStr = (char *) bpcalloc(setSize + 4096, 1);
	if (!embedStr)
		return NULL;

	// variable position counter
	size_t posCounter = 0;

	// Walk the input list and generate buffer
	for
	(
		inputs = inputs->first;
		inputs;
		inputs = inputs->next
	)
	{

		// if were at the position of substitution, go ahead and perform the substitution
		if (posCounter == subAtPosition)
		{

			// retrieve the property name
			tmpName = HTMLGetInputPropertyByNameI(inputs->properties, "name");
			if (!tmpName)
				break;

			// generate the substitution
			snprintf
			(
					&embedStr[bpstrlen(embedStr)],
					setSize,
					"%s%s%s%s%s",
					tmpName->content ? tmpName->content :  "",
					delims->valueDelimiter,
					test->testFront,
					asciiXSSPayload ? asciiXSSPayload :    "",
					test->testTail ? test->testTail :      ""
			);

		}
		else
		{

			// gather the input property
			tmpName = HTMLGetInputPropertyByNameI(inputs->properties, "name");
			if (!tmpName)
				break;

			// Value does not have to be set, if its not set use the string ABC
			tmpValue = HTMLGetInputPropertyByNameI(inputs->properties, "value");

			// if no name, just embed
			if (!tmpValue)
			{
				snprintf(&embedStr[bpstrlen(embedStr)], setSize, "%s%s%s", tmpName->content, delims->valueDelimiter, "ABC");
			}
			else // embed with name
			{
				snprintf(&embedStr[bpstrlen(embedStr)], setSize, "%s%s%s", tmpName->content, delims->valueDelimiter, tmpValue->content);
			}

		}

		// append next delimiter
		strncat(embedStr, delims->nextDelimiter, delims->nLen);

		// increments to determine proper replacements
		posCounter++;

	}

	// remove last next delimiter
	if (embedStr[bpstrlen(embedStr) - 1] == (char) delims->nextDelimiter[0])
		embedStr[bpstrlen(embedStr) - 1] = '\0';

	// return allocated string
	return embedStr;
}


// Generates a list of test conditions for union select conditions.  The front_parts
// parameter must be null pointer terminated to use this function correctly.
P_BP_WEB_BLIND_SQLINJ_TEST BP_WebExploitatinGenUnionSelectTestConditions(char ** front_parts, size_t matrix_size, char *str_test, char *int_test, size_t gen_integer_tests, size_t gen_string_tests, size_t max_nesting)
{

	// must have a set of at least 1 front part for union select.
	if(!front_parts)
		return NULL;

	// used in the matrix generator to determine how many
	// test tails are currently being implemented.
	size_t test_tail_ctr = 0;

	char ***merged      = NULL;
	char ***tmp_merging = NULL;

	// generate all matrix stacks
	size_t i = 1;
	for(; i <= matrix_size; i++)
	{
		tmp_merging = BP_GenerateBlindSQLiUnionMatrixFromStrIntText(str_test, int_test, i);
		merged      = BP_WebExploitationBlindSQLiMergeMatrixesAndFree(merged, tmp_merging);

	}

	// display the merged matrix
	BP_WebExploitationPrintUnionSelectMatrix(merged);


	// generate nesting end strings
	char ** end_strs = (char **) bpcalloc( (max_nesting+1) * sizeof(char *), 1);

	// nested parenthesis iter
	size_t p = 0;


	// iterate through nesting
	for
	(
		i = 0;
		i < max_nesting;
		i++
	)
	{

		// create an iterator string
		char *iter_str = (char *) bpcalloc(max_nesting+30, 1);
		for(p = 0; p < i; p++)
		{
			strcat(iter_str, ")");
		}

		// add the end and loop it
		strcat(iter_str, "--%20");
		end_strs[i] = iter_str;

	}

	// walk frotparts and generate test matrix for each
	size_t x =  0;
	char *iter_str = NULL;

	// this contains the final list of tests ready for processing
	char **final_test_strings = NULL;
	size_t final_test_ctr = 0;

	// iterate through front parts and join
	for
	(
		;
		front_parts[x];
		x++
	)
	{

		// generating all string middle variations
		for(i = 0; merged[i]; i++)
		{

			size_t j = 0;
			for(; end_strs[j]; j++)
			{

				iter_str = BP_WebExploitationBlindSQLiCreateExploitStr(front_parts[x], merged[i], end_strs[j]);
				if(iter_str)
				{

					// allocate space on the stack for the iter string and drop in position
					final_test_ctr++;
					final_test_strings = (char **) bprealloc(final_test_strings, (final_test_ctr+1) * sizeof(char*));
					final_test_strings[final_test_ctr-1] = iter_str;
					final_test_strings[final_test_ctr]   = NULL;

				}

			}

		}

		// Test Tail Matrix Loop Theory:
		// pass 1:
		//     front_parts[x] = UNION SELECT
		//     test_tail =;
		// pass 2:
		// 		front_parts[x] = UNION SELECT
		//      test_tail = )
		// pass 3:
		//      front_parts[x] = UNION SELECT
		//      test_tail = ))

	}

	// generate bsqli test set
	P_BP_WEB_BLIND_SQLINJ_TEST bsqli_test_set = NULL;

	for(i = 0; final_test_strings[i]; i++)
	{
		// generate space for the test set
		bsqli_test_set = (P_BP_WEB_BLIND_SQLINJ_TEST) bprealloc(bsqli_test_set, sizeof(BP_WEB_BLIND_SQLINJ_TEST) * (i+2));
		bsqli_test_set[i].testFront = final_test_strings[i];
		bsqli_test_set[i].type = BP_WEB_BLINDSQLI_TYPE_UNION_SELECT;

		// zero out last element to truncate on loop
		memset((void *) &bsqli_test_set[i+1], 0x00, sizeof(BP_WEB_BLIND_SQLINJ_TEST));

	}

	// return the populated array
	return bsqli_test_set;

}

// Generates a completed union select string suitable for use in blind
// sqli testing.  All strings must be null terminated.
char * BP_WebExploitationBlindSQLiCreateExploitStr(char *test_front, char ** test_positions, char *test_tail)
{

	// all pointers must be set to continue
	if(!test_front || !test_positions || !test_tail)
	{
		return NULL;
	}

	// must have at least one position
	if(!test_positions[0])
		return NULL;

	// loop iterator
	size_t i = 0;

	// middle part of the union select string (the variable positions)
	char *middle_part = NULL;

	// size of the middle string (grows)
	size_t middle_str_len = 0;

	// calculate total length of positions
	for(; test_positions[i]; i++)
	{
		// calculate position length
		middle_str_len += bpstrlen(test_positions[i]) + 5;
	}

	// calculate middle string length
	if(!middle_str_len)
		return NULL;

	// populate middle string
	middle_part = (char *) bpcalloc(middle_str_len + bpstrlen(test_front) + bpstrlen(test_tail) + 10, 1);
	strncat(middle_part, test_front, 1024);
	for(i = 0; test_positions[i]; i++)
	{
		strncat(middle_part, test_positions[i], 512);
		strcat(middle_part, ",");
	}

	// truncate along border to remove comma
	if(middle_part[bpstrlen(middle_part)-1] == ',')
		middle_part[bpstrlen(middle_part)-1] = '\0';

	// add the tail
	strncat(middle_part, test_tail, 1024);

	// return the fixed up string
	return middle_part;
}

// Generates a matrix of union select tests to run provided str and int type values.  All
// arrays in all dimensions of this matrix are null pointer terminated.  The order in which
// tests are generated is optimized for blind sqli detection and should not be modified
// without understanding what's going on.
char *** BP_GenerateBlindSQLiUnionMatrixFromStrIntText(char *str_val, char *int_val, size_t width)
{

	// parameter matrix
	char *** matrix = NULL;

	// loop iter
	size_t i = 0;

	// allocate space for a single row
	char ** tmp_row = (char **) bpcalloc(sizeof(char *) * (width+1), 1);

	// row counter
	size_t row_counter = 0;

	// IN THE AM: FIGURE OUT MEMORY LEAKS IN THE tmp_row AS IT
	// IS POPULATED BELOW AND FIX THEM.

	// IN THE AM: FIGURE OUT MEMORY LEAKS IN THE tmp_row AS IT
	// IS POPULATED BELOW AND FIX THEM.



	// This matrix is used to hold union test strings
	// an example of how these are used is below.  Integer
	// and string positions are unique identifiers.
	// example: (6x6 matrix loop)
	//
	//      first pass is regular starting with int as its the most common: these should match
	//      on all mysql union poisonings i believe.
	//             int1,int2,int3,int4,int5,int6
	//             str1,str2,str3,str4,str5,str6
	//
	// ints first
	for(i = 0; i < width; i++)
	{
		tmp_row[i] = int_val;
	}

	// store the row
	row_counter++;
	matrix = (char ***) bprealloc(matrix, sizeof(char ***) * (row_counter+1));
	matrix[row_counter-1] = BP_WebExploitationDuplicateUnionSelectRow(tmp_row);
	matrix[row_counter]   = NULL;

	// now invert the row
	row_counter++;
	matrix = (char ***) bprealloc(matrix, sizeof(char ***) * (row_counter+1));
	matrix[row_counter-1] = BP_WebExploitationDuplicateInvertedUnionSelectRow(tmp_row, int_val, str_val);
	matrix[row_counter]   = NULL;

	// prints a matrix

	//      second pass is parameter inversing as it has a double digit success chance if int or str isn't found
	//             int1,str2,int3,str4,int5,str6
	//             str1,int2,str3,int4,str5,int6


	// ints first
	size_t row_iter = 0;
	for(i = 0; i < width; i++)
	{

		if(row_iter == 0)
		{
			tmp_row[i] = int_val;
			row_iter = 1;
		}
		else
		{
			tmp_row[i] = str_val;
			row_iter = 0;
		}
	}

	// store the row
	row_counter++;
	matrix = (char ***) bprealloc(matrix, sizeof(char ***) * (row_counter+1));
	matrix[row_counter-1] = BP_WebExploitationDuplicateUnionSelectRow(tmp_row);
	matrix[row_counter]   = NULL;

	// now invert the row
	row_counter++;
	matrix = (char ***) bprealloc(matrix, sizeof(char ***) * (row_counter+1));
	matrix[row_counter-1] = BP_WebExploitationDuplicateInvertedUnionSelectRow(tmp_row, int_val, str_val);
	matrix[row_counter]   = NULL;

	//      second pass is string for int replacement
	//             str1,int2,int3,int4,int5,int6
	//             str1,str2,int3,int4,int5,int6
	//             str1,str2,str3,int4,int5,int6
	//             str1,int2,str3,str4,int5,int6
	//             str1,str2,str3,str4,str5,int6
	//

	size_t str_cnt = 0;
	size_t int_cnt = 0;

	// iterate though the list
	size_t x = 0;
	i = 0;
	for(; x < width-1; x++)
	{
		// increment string count
		str_cnt++;
		for(i = 0; i < str_cnt; i++)
		{
			tmp_row[i] = str_val;
		}

		int_cnt = width - str_cnt;
		for(i = str_cnt; i < int_cnt+1; i++)
		{
			tmp_row[i] = int_val;
		}
		// store the row
		row_counter++;
		matrix = (char ***) bprealloc(matrix, sizeof(char ***) * (row_counter+1));
		matrix[row_counter-1] = BP_WebExploitationDuplicateUnionSelectRow(tmp_row);
		matrix[row_counter]   = NULL;

		// now invert the row
		row_counter++;
		matrix = (char ***) bprealloc(matrix, sizeof(char ***) * (row_counter+1));
		matrix[row_counter-1] = BP_WebExploitationDuplicateInvertedUnionSelectRow(tmp_row, int_val, str_val);
		matrix[row_counter]   = NULL;

	}

	//    fourth pass collapses outwards in on string positions
	//             int1,str2,str3,str4,str5,int6
	//             int1,int2,str3,str4,str5,int6
	//             int1,int2,str3,str4,int5,int6
	//             int1,int2,int3,str4,int5,int6
	//

	size_t front_str_cnt = 1;
	size_t end_str_cnt   = 1;

	for(x = 0; x < width-1; x++)
	{

		// set the front positions first
		for(i = 0; i < front_str_cnt; i++)
		{
			tmp_row[i] = str_val;
		}

		// now set the ends
		for(i = 0; i < end_str_cnt; i++)
		{
			tmp_row[(width-1)-i] = str_val;
		}

		// calculate distance if set
		size_t distance = 0;
		if(width > (front_str_cnt + end_str_cnt))
			distance = width - (front_str_cnt + end_str_cnt);

		if(distance)
		for(i = front_str_cnt; i < distance; i++)
		{
			if(!distance)
				break;

			tmp_row[i] = int_val;

		}

		front_str_cnt++;
		end_str_cnt++;

		// store the row
		row_counter++;
		matrix = (char ***) bprealloc(matrix, sizeof(char ***) * (row_counter+1));
		matrix[row_counter-1] = BP_WebExploitationDuplicateUnionSelectRow(tmp_row);
		matrix[row_counter]   = NULL;

		// now invert the row

		row_counter++;
		matrix = (char ***) bprealloc(matrix, sizeof(char ***) * (row_counter+1));
		matrix[row_counter-1] = BP_WebExploitationDuplicateInvertedUnionSelectRow(tmp_row, int_val, str_val);
		matrix[row_counter]   = NULL;
		/**/
		if(!distance)
			break;
	}



	//   fifth pass collapses outwards in on ints
	//             str1,int2,int3,int4,int5,str6
	//             str1,str2,int3,int4,int5,str6
	//             str1,str2,int3,int4,str5,str6
	//             str1,str2,str3,int4,str5,str6
	//


	//   sixth pass is odd man out on ints
	//             int1,int2,int3,int4,int5,int6
	//             int1,str2,int3,int4,int5,int6
	//             int1,int2,str3,int4,int5,int6
	//             int1,int2,int3,str4,int5,int6
	//             int1,int2,int3,int4,str5,int6
	//             int1,int2,int3,int4,int5,str6
	//


	// seventh pass is odd man out on strs
	//             str1,str2,str3,str4,str5,str6
	//             str1,int2,str3,str4,str5,str6
	//             str1,str2,int3,str4,str5,str6
	//             str1,str2,str3,int4,str5,str6
	//             str1,str2,str3,str4,int5,str6
	//             str1,str2,str3,str4,str5,int6
	//


	// eight pass is int edge cases
	//             int1,str2,int3,int4,str5,str6
	//             int1,str2,str3,int4,str5,str6
	//
	// BP_WebExploitationPrintUnionSelectMatrix(matrix);

	// ninth pass is str edge cases
	//             str1,int2,int3,str4,int5,int6
	//             str1,int2,int3,str4,int5,int6


	return matrix;
}

// Creates a duplicate row for use in unioning which can be position modified.
char **BP_WebExploitationDuplicateUnionSelectRow(char **row)
{

	// string
	char ** dup_arr = NULL;

	// count the rows
	size_t i = 0;
	for(; row[i]; i++){}

	// allocate space for elements
	dup_arr = (char **) bpcalloc(sizeof(char *) * (i+1), 1);

	// now duplicate array
	for(i = 0; row[i]; i++)
	{
		dup_arr[i] = bpstrdup(row[i]);
	}

	// return the duplicated array
	return dup_arr;

}

// Duplicates an inverted union select row of items
char **BP_WebExploitationDuplicateInvertedUnionSelectRow(char **row, char *invert_this, char *with_this)
{

	// string
	char ** dup_arr = NULL;

	// count the rows
	size_t i = 0;
	for(; row[i]; i++){}

	// allocate space for elements
	dup_arr = (char **) bpcalloc(sizeof(char *) * (i+1), 1);

	// now duplicate array
	for(i = 0; row[i]; i++)
	{

		if(memcmp(row[i], invert_this, bpstrlen(invert_this)) == 0)
		{

			dup_arr[i] = bpstrdup(with_this);
			continue;
		}
		if(memcmp(row[i], with_this, bpstrlen(with_this)) == 0)
		{
			dup_arr[i] = bpstrdup(invert_this);
			continue;
		}

		dup_arr[i] = bpstrdup("unknown_badval");
		continue;

	}

	// return the duplicated array
	return dup_arr;

}

// prints a matrix
size_t BP_WebExploitationPrintUnionSelectMatrix(char *** matrix)
{

	// display the union select matrix
	printf("\n [+] Displaying Union Select Matrix: %p", matrix);

	// matrix dimension iterators
	size_t i = 0;
	size_t x = 0;

	// walk the matrix and display
	for(; matrix[i]; i++)
	{
		printf("\n\t");
		for(x = 0; matrix[i][x]; x++)
		{
			printf("%s, ", matrix[i][x]);
		}
	}

	return ERR_SUCCESS;
}


// Joins two matrixes bottom to top logically in a stacked
// array.  No inputs are destroyed, only pointer swapping occurs so
// you must be careful to not doublefree pointers.
char *** BP_WebExploitationBlindSQLiMergeMatrixesAndFree(char *** matrix_top, char *** matrix_bottom)
{

	// merged pointer array to return
	char *** merged = NULL;

	// index / counter for counting matrix elements.
	size_t top_n = 0;
	size_t bottom_n = 0;

	// count top
	if(matrix_top)
	for(top_n = 0; matrix_top[top_n] ; top_n++){}

	// count bottom
	if(matrix_bottom)
	for(bottom_n = 0; matrix_bottom[bottom_n] ; bottom_n++){}

	// allocate space for the merged array
	merged = (char ***) bpcalloc((top_n + bottom_n + 2) * sizeof(char ***), 1 );

	// loop merge iterator
	size_t j = 0;
	for(j = 0; j < top_n; j++)
	{
		merged[j] = matrix_top[j];
	}

	// second loop iter
	size_t i = 0;
	for(; matrix_bottom[i]; i++, j++)
	{
		merged[j] = matrix_bottom[i];
	}

	// Note: Since allocation is allocated with bpcalloc, it can
	// be considered null terminated as is.

	// return the merged data
	return merged;

}

// displays a blind sql injection test set
size_t BP_DisplayBlindSQLiTestSet(P_BP_WEB_BLIND_SQLINJ_TEST tests)
{

	// run rudimentary checks
	if(!tests)
		return ERR_FAILURE;
	if(!tests->testFront)
		return ERR_FAILURE;


	printf("\n [+] Displaying Blind SQLi Test Stack: %p", tests);

	size_t i = 0;
	for(i = 0; tests[i].testFront; i++)
	{
		BP_DisplayBlindSQLiTest(&tests[i]);
	}

	// return indicating success
	return ERR_SUCCESS;

}

// displays a blind sql injection test (singular)
size_t BP_DisplayBlindSQLiTest(P_BP_WEB_BLIND_SQLINJ_TEST test)
{

	printf("\n\t [+] Blind SQLi Test: %p", test);
	printf("\n\t\t front: %s", test->testFront);

	// switch on the test type
	switch(test->type)
	{

		case BP_WEB_BLINDSQLI_TYPE_NONE:
			printf("\n\t\t type: no type set.");
			break;

		case BP_WEB_BLINDSQLI_TYPE_TIME_BENCHMARK:
			printf("\n\t\t type: TIME_BENCHMARK");
			break;

		case BP_WEB_BLINDSQLI_TYPE_UNION_SELECT:
			printf("\n\t\t type: UNION_SELECT");
			break;

		default:
			break;

	}

	// return indicating success
	return ERR_SUCCESS;
}
