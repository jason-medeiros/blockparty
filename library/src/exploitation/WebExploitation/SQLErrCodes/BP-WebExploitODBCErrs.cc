/*
 * BP-WebExploitODBCErrs.cc
 *
 *  Created on: Apr 7, 2009
 *      Author: root
 */

#ifndef BPWEBEXPLOITODBCERRS_CC_
#define BPWEBEXPLOITODBCERRS_CC_

#include "../../../../include/BP-Main.h"

BP_ODBC_ERR_CODES odbcErrCodes[] = {
	{(char*)"01000", (char*)"General warning"},
	{(char*)"01001", (char*)"Cursor operation conflict"},
	{(char*)"01002", (char*)"Disconnect error"},
	{(char*)"01003", (char*)"NULL value eliminated in set function"},
	{(char*)"01004", (char*)"String data, right-truncated"},
	{(char*)"01006", (char*)"Privilege not revoked"},
	{(char*)"01007", (char*)"Privilege not granted"},
	{(char*)"01S00", (char*)"Invalid connection string attribute"},
	{(char*)"01S01", (char*)"Error in row"},
	{(char*)"01S02", (char*)"Option value changed"},
	{(char*)"01S06", (char*)"Attempt to fetch before the result set returned the first rowset"},
	{(char*)"01S07", (char*)"Fractional truncation"},
	{(char*)"01S08", (char*)"Error saving File DSN"},
	{(char*)"01S09", (char*)"Invalid keyword"},
	{(char*)"07001", (char*)"Wrong number of parameters"},
	{(char*)"07002", (char*)"COUNT field incorrect"},
	{(char*)"07005", (char*)"Prepared statement not a cursor-specification"},
	{(char*)"07006", (char*)"Restricted data type attribute violation"},
	{(char*)"07009", (char*)"Invalid descriptor index"},
	{(char*)"07S01", (char*)"Invalid use of default parameter"},
	{(char*)"08001", (char*)"Client unable to establish connection"},
	{(char*)"08002", (char*)"Connection name in use"},
	{(char*)"08003", (char*)"Connection does not exist"},
	{(char*)"08004", (char*)"Server rejected the connection"},
	{(char*)"08007", (char*)"Connection failure during transaction"},
	{(char*)"08S01", (char*)"Communication link failure"},
	{(char*)"21S01", (char*)"Insert value list does not match column list"},
	{(char*)"21S02", (char*)"Degree of derived table does not match column list"},
	{(char*)"22001", (char*)"String data, right-truncated"},
	{(char*)"22002", (char*)"Indicator variable required but not supplied"},
	{(char*)"22003", (char*)"Numeric value out of range"},
	{(char*)"22007", (char*)"Invalid datetime format"},
	{(char*)"22008", (char*)"Datetime field overflow"},
	{(char*)"22012", (char*)"Division by zero"},
	{(char*)"22015", (char*)"Interval field overflow"},
	{(char*)"22018", (char*)"Invalid character value for cast specification"},
	{(char*)"22019", (char*)"Invalid escape character"},
	{(char*)"22025", (char*)"Invalid escape sequence"},
	{(char*)"22026", (char*)"String data, length mismatch"},
	{(char*)"23000", (char*)"Integrity constraint violation"},
	{(char*)"24000", (char*)"Invalid cursor state"},
	{(char*)"25000", (char*)"Invalid transaction state"},
	{(char*)"25S01", (char*)"Transaction state"},
	{(char*)"25S02", (char*)"Transaction is still active"},
	{(char*)"25S03", (char*)"Transaction is rolled back"},
	{(char*)"28000", (char*)"Invalid authorization specification"},
	{(char*)"34000", (char*)"Invalid cursor name"},
	{(char*)"3C000", (char*)"Duplicate cursor name"},
	{(char*)"3D000", (char*)"Invalid catalog name"},
	{(char*)"3F000", (char*)"Invalid schema name"},
	{(char*)"40001", (char*)"Serialization failure"},
	{(char*)"40002", (char*)"Integrity constraint violation"},
	{(char*)"40003", (char*)"Statement completion unknown"},
	{(char*)"42000", (char*)"Syntax error or access violation"},
	{(char*)"42S01", (char*)"Base table or view already exists"},
	{(char*)"42S02", (char*)"Base table or view not found"},
	{(char*)"42S11", (char*)"Index already exists"},
	{(char*)"42S12", (char*)"Index not found"},
	{(char*)"42S21", (char*)"Column already exists"},
	{(char*)"42S22", (char*)"Column not found"},
	{(char*)"44000", (char*)"WITH CHECK OPTION violation"},
	{(char*)"HY000", (char*)"General error"},
	{(char*)"HY001", (char*)"Memory allocation error"},
	{(char*)"HY003", (char*)"Invalid application buffer type"},
	{(char*)"HY004", (char*)"Invalid SQL data type"},
	{(char*)"HY007", (char*)"Associated statement is not prepared"},
	{(char*)"HY008", (char*)"Operation canceled"},
	{(char*)"HY009", (char*)"Invalid use of null pointer"},
	{(char*)"HY010", (char*)"Function sequence error"},
	{(char*)"HY011", (char*)"Attribute cannot be set now"},
	{(char*)"HY012", (char*)"Invalid transaction operation code"},
	{(char*)"HY013", (char*)"Memory management error"},
	{(char*)"HY014", (char*)"Limit on the number of handles exceeded"},
	{(char*)"HY015", (char*)"No cursor name available"},
	{(char*)"HY016", (char*)"Cannot modify an implementation row descriptor"},
	{(char*)"HY017", (char*)"Invalid use of an automatically allocated descriptor handle"},
	{(char*)"HY018", (char*)"Server declined cancel request"},
	{(char*)"HY019", (char*)"Non-character and non-binary data sent in pieces"},
	{(char*)"HY020", (char*)"Attempt to concatenate a null value"},
	{(char*)"HY021", (char*)"Inconsistent descriptor information"},
	{(char*)"HY024", (char*)"Invalid attribute value"},
	{(char*)"HY090", (char*)"Invalid string or buffer length"},
	{(char*)"HY091", (char*)"Invalid descriptor field identifier"},
	{(char*)"HY092", (char*)"Invalid attribute/option identifier"},
	{(char*)"HY095", (char*)"Function type out of range"},
	{(char*)"HY096", (char*)"Invalid information type"},
	{(char*)"HY097", (char*)"Column type out of range"},
	{(char*)"HY098", (char*)"Scope type out of range"},
	{(char*)"HY099", (char*)"Nullable type out of range"},
	{(char*)"HY100", (char*)"Uniqueness option type out of range"},
	{(char*)"HY101", (char*)"Accuracy option type out of range"},
	{(char*)"HY103", (char*)"Invalid retrieval code"},
	{(char*)"HY104", (char*)"Invalid precision or scale value"},
	{(char*)"HY105", (char*)"Invalid parameter type"},
	{(char*)"HY106", (char*)"Fetch type out of range"},
	{(char*)"HY107", (char*)"Row value out of range"},
	{(char*)"HY109", (char*)"Invalid cursor position"},
	{(char*)"HY110", (char*)"Invalid driver completion"},
	{(char*)"HY111", (char*)"Invalid bookmark value"},
	{(char*)"HYC00", (char*)"Optional feature not implemented"},
	{(char*)"HYT00", (char*)"Timeout expired"},
	{(char*)"HYT01", (char*)"Connection timeout expired"},
	{(char*)"IM001", (char*)"Driver does not support this function"},
	{(char*)"IM002", (char*)"Data source name not found and no default driver specified"},
	{(char*)"IM003", (char*)"Specified driver could not be loaded"},
	{(char*)"IM004", (char*)"Driver's SQLAllocHandle on SQL_HANDLE_ENV failed"},
	{(char*)"IM005", (char*)"Driver's SQLAllocHandle on SQL_HANDLE_DBC failed"},
	{(char*)"IM006", (char*)"Driver's SQLSetConnectAttr failed"},
	{(char*)"IM007", (char*)"No data source or driver specified; dialog prohibited"},
	{(char*)"IM008", (char*)"Dialog failed"},
	{(char*)"IM009", (char*)"Unable to load translation DLL"},
	{(char*)"IM010", (char*)"Data source name too long"},
	{(char*)"IM011", (char*)"Driver name too long"},
	{(char*)"IM012", (char*)"DRIVER keyword syntax error"},
	{(char*)"IM013", (char*)"Trace file error"},
	{(char*)"IM014", (char*)"Invalid name of File DSN"},
	{(char*)"IM015", (char*)"Corrupt file data source"}
};



// Generates an allocated array of Msql error codes
P_BP_ODBC_ERR_CODES BP_ODBCGenErrCodeArray(){

	size_t retSize = sizeof(odbcErrCodes);
	P_BP_ODBC_ERR_CODES retTable = (P_BP_ODBC_ERR_CODES) bpcalloc(retSize, 1);
	if(!retTable)
		return NULL;

	BP_ODBC_ERR_CODES nullCmp;
	memset(&nullCmp, 0x00, sizeof(nullCmp));

	// duplicate the array
	size_t x = 0;
	for(x = 0; ( sizeof(BP_ODBC_ERR_CODES) * x ) < sizeof(odbcErrCodes); x++){

		retTable[x].description = bpstrdup(odbcErrCodes[x].description);
		retTable[x].errCode     = bpstrdup(odbcErrCodes[x].errCode);

	}

	return retTable;
}


// Generates a list of error code tests based around the
// error code array defined above.  This set is basically
// a string array w/o format strings.
P_BP_FMT_ERR_TESTS BP_ODBCGenErrTestsFromErrCodeArray(P_BP_ODBC_ERR_CODES inCodes, size_t numCodes, char **fmtReplacementTable){

	if(!inCodes)
		return NULL;

	size_t i = 0;
	P_BP_FMT_ERR_TESTS genSet = NULL;
	BP_FMT_ERR_TESTS * retSet = NULL;


	// set code array pointer into an indexable typedef
	BP_ODBC_ERR_CODES * testCodes = (P_BP_ODBC_ERR_CODES) inCodes;


	for(i = 0; i < numCodes; i++)
	{

		// increase the size of the return set
		retSet = (BP_FMT_ERR_TESTS *) bprealloc(retSet, ((i+1) * sizeof(BP_FMT_ERR_TESTS)) + sizeof(BP_FMT_ERR_TESTS));

		// generate match set from a string
		genSet = BP_GenerateMatchSetFromTestString(testCodes[i].description, bpstrlen(testCodes[i].description), fmtReplacementTable);
		if(!genSet)
			return NULL;

		// copy in the array data
		memcpy(&retSet[i], genSet, sizeof(BP_FMT_ERR_TESTS));

		// zero out trailing item
		memset(&retSet[i+1], 0x00, sizeof(BP_FMT_ERR_TESTS));

		// destroy chunk structure (dont destroy internal pointers)
		bpfree(genSet);
		genSet = NULL;

	}

	// return the filled out structure
	return (P_BP_FMT_ERR_TESTS) retSet;
}

// Returns the total number of checks within the msql array.
size_t BP_ODBCErrCount(){

	size_t retCount = sizeof(odbcErrCodes) / sizeof(BP_ODBC_ERR_CODES);
	return retCount;
}

// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%% DECONSTRUCTORS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

// Destroys a set of ODBC error code allocations
size_t BP_DestroyODBCErrCodes(BP_ODBC_ERR_CODES * codes){

	if(!codes)
		return ERR_FAILURE;

	size_t x = 0;
	for(x = 0; x < BP_ODBCErrCount(); x++){
		bpfree(codes[x].description);
		bpfree(codes[x].errCode);
	}

	// NO MORE FREE CODE, NO MORE, NONE lol (memory 4free tho | bovice)
	bpfree(codes);

	// return success
	return ERR_SUCCESS;
}


#endif /* BPWEBEXPLOITODBCERRS_CC_ */
