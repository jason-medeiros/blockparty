/*
 * BP-WebExploitationMatching.cc
 *
 *  Created on: Apr 7, 2009
 *      Author: root
 */

#include "../../../include/BP-Main.h"

// This table was generated by strategically parsing out all format
// characters from the error tables and is used as a generic table for
// generating test sets.
char *fmtTable[] = {
		"%S_BLKIOPTR",
		"%S_DATE",
		"%S_MSG",
		"%S_PAGE",
		"%S_TS",
		"%S_PGID",
		"%.%s",
		"%*.s",
		"%05d",
		"%-.200s",
		"%d",
		"%-.64s",
		"%s",
		"%-.150s",
		"%-.32s",
		"%-.100s",
		"%-.80s",
		"%ld",
		"%-.128s",
		"%lu",
		"%-.16s",
		"%.*s",
		"%u",
		"%.64s",
		"%.256s",
		"%.192s",
		"%-.70",
	 	"%d",
		"%.*ls",
		"%ld",
		"%ls",
		"%.*s",
		"%s",
		"%f",
		"%hs",
		"%x",
		"%i",
		"%I64d",
		"%p",
		"%#016I64x",
		"%u",
		"%08x",
		"%#x",
		"%I64x",
		"%I64u",
		"%-30ls",
		"%.8x",
		"%.4x",
		"%.2x",
		"%lx",
		"%c",
		"%0*I64x",
		"%.*hs",
		"%08lx",
		"%04lx",
		"%X",
		"%08X",
		"%02d",
		NULL
};

// Returns an allocated null terminated character array containing the
// format table above.
char ** BP_WebExploitGenFormatTable(){

	char ** retFmtTable = (char **) bpcalloc(sizeof(fmtTable), 1);
	if(!retFmtTable)
		return NULL;

	size_t x = 0;
	for(x = 0; fmtTable[x]; x++)
		retFmtTable[x] = bpstrdup(fmtTable[x]);

	// null terminate the table
	retFmtTable[x] = NULL;

	return retFmtTable;

}

// Returns the number of entries in the format table (used primarily
// by the format table deconstrution routine)
size_t BP_WebExploitGetFormatTableEntries(){
	return (sizeof(fmtTable) / sizeof(char *)) - 1;
}

// Use this routine in order to facilitate buffer matching if the
// error match set contains format strings.  Returns true if the
// match set activated, and false if it does not.
bool BP_TestMatchSet(char *inBuff, size_t buffSize, P_BP_FMT_ERR_TESTS test)
{

	// null check in test (can happen some times with bad rules)
	if(test->fmtErrTestStrs == NULL || test->numStrs == 0)
	{
		return false;
	}

	// test pointers
	void * testPtr = NULL;

	// JM: Changed numStrs to numStrs-1 12/2011 to fix potential corruption.
	size_t i = 0;
	for(i = 0; i < test->numStrs; i++)
	{

		if(memcmp(test->fmtErrTestStrs[i], ": eval()'d code on line", bpstrlen(": eval()'d code on line")) == 0)
		{
			// __asm("int3");
		}

		testPtr = memmem(inBuff, buffSize, test->fmtErrTestStrs[i], bpstrlen(test->fmtErrTestStrs[i]));
		if(!testPtr)
			break;

	}

	size_t x = 0;
	if(i != test->numStrs){
		return false;
	}

	return true;
}

// Generates an error test structure based around an input string
// which may or may not contain a format string.
P_BP_FMT_ERR_TESTS BP_GenerateMatchSetFromTestString
(
		char *inStr,
		size_t buffSize,
		char **fmtReplacementTable
)
{

	if(!inStr)
		return NULL;

	// iterators
	size_t i = 0;
	size_t x = 0;


	// Used for matching in the list
	char *fmtMatch = NULL;

	// section length (for extracting strings)
	size_t sectionLen = 0;

	// allocate space for the tests (ALLOCATE 2.  This fixes a trucation leak.  This
	// isn't the cleanest solution, but I have 5 days to fix this, so this is what it is).
	P_BP_FMT_ERR_TESTS errTest = (P_BP_FMT_ERR_TESTS) bpcalloc(sizeof(BP_FMT_ERR_TESTS)*2, 1);

	// zero out the structure
	memset(errTest, 0x00, sizeof(BP_FMT_ERR_TESTS) * 2);

	// Error placeholder string for doing extractions
	char *tmpStr = inStr;

	// jump label for reiterating over strings for formats (fast)
	looper:

	// attempt to find a % in the error string
	fmtMatch = (char *) memmem((void *) tmpStr, bpstrlen(tmpStr), (void *) "%", 1);


	// if a match is made, we're good to go
	if(fmtMatch != NULL){

		// walk format list looking for a matching token set
		for(x = 0; fmtReplacementTable[x]; x++){

			// skip if the fmt is too short
			if(bpstrlen(fmtReplacementTable[x]) > bpstrlen(fmtMatch) )
				continue;

			// test if match is made
			if(memcmp(fmtMatch, fmtReplacementTable[x], bpstrlen(fmtReplacementTable[x])) == 0){

				// retrieve the length of the string section
				sectionLen = BP_GetLengthTillMatch(tmpStr, fmtReplacementTable[x], bpstrlen(fmtReplacementTable[x]));

				// At this point we have a match, and a length, and a proper string, so
				// increment the number of strings.
				errTest->numStrs++;

				// set data in errTests
				errTest->fmtErrTestStrs = (char **) bprealloc(errTest->fmtErrTestStrs, errTest->numStrs * sizeof(char *));

				// allocate space for the space section
				errTest->fmtErrTestStrs[errTest->numStrs-1] = (char *) bpcalloc(sectionLen + 100, 1);
				memcpy(errTest->fmtErrTestStrs[errTest->numStrs-1], tmpStr, sectionLen);

				// move forward
				tmpStr = &tmpStr[sectionLen+bpstrlen(fmtReplacementTable[x])];

				// jump to the reiteration label if we have something to analyze
				goto looper;

			}


		}

	// If the message has no %'s in it, then it is a direct match
	// and can simply be duplicated.
	} else {

		// At this point we have a match, and a length, and a proper string, so
		// increment the number of strings.
		errTest->numStrs++;

		// set data in errTests
		errTest->fmtErrTestStrs = (char **) bprealloc(errTest->fmtErrTestStrs, errTest->numStrs * sizeof(char *));

		// allocate space for the space section
		errTest->fmtErrTestStrs[errTest->numStrs-1] = bpstrdup(tmpStr);

	}

	size_t j = 0;
	size_t totalLen = 0;
	// arbitrary generation check for gen sets

	for(j = 0; j < errTest->numStrs; j++){
		totalLen += bpstrlen(errTest->fmtErrTestStrs[j]);
	}

	if(totalLen == 0){
		printf("\n[+] ERROR CONVERTING TEST: %s ", tmpStr);

	} else if(totalLen < 5){
		printf("\n[+] ERROR LENGTH LESS THEN 5: %s", tmpStr);
	}

	// return the filled out structure
	return errTest;
}


// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%% DECONSTRUCTORS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

// Destroys a set of format error checks, REQUIRES COUNT
size_t BP_DestroyFmtErrTests(BP_FMT_ERR_TESTS * tests, size_t count){

	if(!tests)
		return ERR_FAILURE;

	// indexes for frees
	size_t x = 0;
	size_t y = 0;

	for(x = 0; x < count; x++)
	{

		// can't possibly have an empty front string
		if(!tests[x].fmtErrTestStrs)
			break;;

		// destroy individual strings in structure
		if(tests[x].fmtErrTestStrs && tests[x].numStrs)
		for(y = 0; y < tests[x].numStrs; y++){

			bpfree(tests[x].fmtErrTestStrs[y]);

		}

		// destroy test string array
		bpfree(tests[x].fmtErrTestStrs);
	}


	// destroy the structure array
	bpfree(tests);

	// return success
	return ERR_SUCCESS;
}
