/*
 * BP-WebExploitationTestResultAnalysis.cc
 *
 *  Created on: Apr 6, 2009
 *      Author: root
 */

#include "../../../include/BP-Main.h"

// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%% ANCHOR MATCH CHECK ROUTINES %%%%%%%%%%%%%%%%%%%%%%%

// Returns an analysis index set which contains the matches for the given
// format tests.
P_BP_WEB_ANALYSIS_RESULT_INDEX_SET BP_WebAssessmentRunTests(P_BP_WEB_ASSESSMENT assessment, BP_FMT_ERR_TESTS * tests, size_t testCount)
{

	// Null checks
	if(!assessment || !tests || !testCount)
		return NULL;


	// create new index set
	P_BP_WEB_ANALYSIS_RESULT_INDEX_SET indexSet = (P_BP_WEB_ANALYSIS_RESULT_INDEX_SET) bpcalloc(sizeof(BP_WEB_ANALYSIS_RESULT_INDEX_SET), 1);
	if(!indexSet)
		return NULL;

	// save page data pointer
	char *pageData = assessment->session->page->page_data;

	// save page size pointer
	size_t pageSize = assessment->session->page->page_data_size;


	// tmp for validation of algorithm, remove when done validating
	size_t x = 0;

	// Walk tests and create linked list element when matched
	size_t i = 0;
	for(i = 0; i < testCount-1; i++)
	{


		if(i == 146)
		{
			//	asm("int3");
		}

		if(BP_TestMatchSet(pageData, pageSize, &tests[i]) == true)
		{

			indexSet->matchCount++;
			indexSet->matchIndexes = (size_t *) bprealloc(indexSet->matchIndexes, sizeof(size_t) * indexSet->matchCount);

			// set the actual match index to the position in the array which the
			// match was found.
			indexSet->matchIndexes[indexSet->matchCount-1] = i;

		}


	}

	// check if we've made matches, if not, destroy
	if(indexSet->matchCount == 0)
	{
		bpfree(indexSet);
		return NULL;
	}

	// if we have matches, we can return them
	return indexSet;
}


// ---------------- ANCHOR XSS CHECK PORTION ----------------------------

// Utilizes the data stored within the session in order to attempt a match with
// a given XSS Test.
P_BP_WEB_XSS_TEST_RESULT BP_WebAssessmentRunXSSAnchorMatchCheck(P_BP_WEB_ASSESSMENT assessment, P_BP_WEB_XSS_TEST test, size_t testIndex, size_t runMagicQuotesTest, P_BP_HTML_ANCHOR_LIST anchor, P_BP_HTML_ANCHOR_VAR_LIST vulnVar, size_t anchorVarPosition){

	// Null checks
	if(!assessment || !test)
		return NULL;

	// create new structure
	P_BP_WEB_XSS_TEST_RESULT result = (P_BP_WEB_XSS_TEST_RESULT) bpcalloc(sizeof(BP_WEB_XSS_TEST_RESULT), 1);
	if(!result)
		return NULL;


	// set pointers
	result->first = result;
	result->next = NULL;
	result->prev = NULL;

	// type is anchor
	result->targetType = BP_XSS_TARGET_TYPE_ANCHOR;

	// set the test index
	result->testIndex = testIndex;


	// Non-magic quotes aware search string
	char * standardSearchString = NULL;

	// increase the string size + size of payload
	size_t strSize = bpstrlen(assessment->xssPayload);

	// increase size around test front/tail combo
	strSize += bpstrlen(test->testFront);
	strSize += bpstrlen(test->testTail);

	// allocate memory plus some just in case
	standardSearchString = (char *) bpcalloc(strSize+4096, 1);



	// copy in parameters
	snprintf(standardSearchString, strSize+1024, "%s%s%s",
			test->testFront, assessment->xssPayload, test->testTail);

	char * standardSearchStringCORRECT = BP_GenNonUnicodeSpaceString(standardSearchString, bpstrlen(standardSearchString));

	// Normal String Checks
	char *match = (char *) memmem((void *) assessment->session->page->page_data,
											assessment->session->page->page_data_size,
											(void *) standardSearchStringCORRECT,
											bpstrlen(standardSearchStringCORRECT)  );

	// If the pointer is found, we have a match
	if(match)
		result->match = true;


	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	// %%%%%% MAGIC QUOTE CHECKS %%%%%%%%%%%%%%%%%%%%%


	char *magicQuoteMatch = NULL;

	// Magic Quote Checks
	char * mgQuoteStr = BP_WebAssessmentGenerateMagicQuoteStrFromStr(standardSearchString);

	char * mgQuoteStrCORRECT = BP_GenNonUnicodeSpaceString(mgQuoteStr, bpstrlen(mgQuoteStr));

	magicQuoteMatch = (char *) memmem((void *) assessment->session->page->page_data,
									assessment->session->page->page_data_size,
									(void *) mgQuoteStrCORRECT,
									bpstrlen(mgQuoteStrCORRECT));

	// set match flag
	if(magicQuoteMatch)
		result->magicQuotesMatch = true;

	result->anchor = anchor;
	result->vulnVar = vulnVar;
	result->anchorVarPosition = anchorVarPosition;

	// bpfree the standard/magic quote string
	bpfree(mgQuoteStr);
	bpfree(mgQuoteStrCORRECT);

	bpfree(standardSearchString);
	bpfree(standardSearchStringCORRECT);


	// return the filled in structure
	return result;

}

// ----------------------------------------------------------------
// Form Checks

// Utilizes the data stored within the session in order to attempt a match with
// a given XSS Test. (FORM VERSION)
P_BP_WEB_XSS_TEST_RESULT BP_WebAssessmentRunXSSFormMatchCheck(P_BP_WEB_ASSESSMENT assessment, P_BP_WEB_XSS_TEST test, size_t testIndex, size_t runMagicQuotesTest, P_BP_HTML_FORM_LIST form, P_BP_HTML_INPUT_LIST vulnInput, size_t inputVarPosition){

	// Null checks
	if(!assessment || !test)
		return NULL;

	// create new structure
	P_BP_WEB_XSS_TEST_RESULT result = (P_BP_WEB_XSS_TEST_RESULT) bpcalloc(sizeof(BP_WEB_XSS_TEST_RESULT), 1);
	if(!result)
		return NULL;


	// set pointers
	result->first = result;
	result->next = NULL;
	result->prev = NULL;

	// type is anchor
	result->targetType = BP_XSS_TARGET_TYPE_FORM;

	// set the test index
	result->testIndex = testIndex;


	// Non-magic quotes aware search string
	char * standardSearchString = NULL;

	// increase the string size + size of payload
	size_t strSize = bpstrlen(assessment->xssPayload);

	// increase size around test front/tail combo
	strSize += bpstrlen(test->testFront);
	strSize += bpstrlen(test->testTail);

	// allocate memory plus some just in case
	standardSearchString = (char *) bpcalloc(strSize+4096, 1);



	// copy in parameters
	snprintf(standardSearchString, strSize+1024, "%s%s%s",
			test->testFront, assessment->xssPayload, test->testTail);

	char * standardSearchStringCORRECT = BP_GenNonUnicodeSpaceString(standardSearchString, bpstrlen(standardSearchString));

	// Normal String Checks
	char *match = (char *) memmem((void *) assessment->session->page->page_data,
								strnlen(assessment->session->page->page_data, assessment->session->page->page_data_size),
								(void *) standardSearchStringCORRECT,
								bpstrlen(standardSearchStringCORRECT));


	// If the pointer is found, we have a match
	if(match)
		result->match = true;



	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	// %%%%%% MAGIC QUOTE CHECKS %%%%%%%%%%%%%%%%%%%%%

	char *magicQuoteMatch = NULL;


	// Magic Quote Checks
	char * mgQuoteStr = BP_WebAssessmentGenerateMagicQuoteStrFromStr(standardSearchString);

	char * mgQuoteStrCORRECT = BP_GenNonUnicodeSpaceString(mgQuoteStr, bpstrlen(mgQuoteStr));

	magicQuoteMatch = (char *) memmem((void *) assessment->session->page->page_data,
									strnlen(assessment->session->page->page_data, assessment->session->page->page_data_size),
									(void *) mgQuoteStrCORRECT,
									bpstrlen(mgQuoteStrCORRECT));

	// set match flag
	if(magicQuoteMatch)
		result->magicQuotesMatch = true;

	result->form             = form;
	result->vulnInput        = vulnInput;
	result->inputVarPosition = inputVarPosition;

	// bpfree the standard/magic quote string
	bpfree(mgQuoteStr);
	bpfree(mgQuoteStrCORRECT);

	bpfree(standardSearchString);
	bpfree(standardSearchStringCORRECT);


	// return the filled in structure
	return result;

}
