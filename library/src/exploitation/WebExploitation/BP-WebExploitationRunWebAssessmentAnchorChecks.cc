/*
 * BP_RunWebAssessmentAnchorChecks.cc
 *
 *  Created on: Dec 10, 2011
 *      Author: root
 */

// Include main header
#include "../../../include/BP-Main.h"

// Checks anchors in an assessment (SHOULD BE INVOKED FROM MAIN DISPATCHER ONLY)
size_t BP_RunWebAssessmentAnchorChecks(P_BP_WEB_ASSESSMENT assessment)
{

	// Null check
	if (!assessment)
		return ERR_FAILURE;

	if (BP_CheckWebAssessmentPointers(assessment) != ERR_SUCCESS)
		return ERR_FAILURE;

	// Local anchor and form vars used for request generation
	P_BP_HTML_ANCHOR_LIST anchors          = NULL;
	P_BP_HTML_ANCHOR_LIST anchorSavedFirst = NULL;

	// Set anchor pointers.  These assignments are safe because
	// of the mandatory extraction structure pointer checks inside
	// the invoked BP_CheckWebAssessmentPointers routine.
	anchors = assessment->pageExtraction->anchors;
	if(anchors)
	{
		anchorSavedFirst = anchors->first;
	}
	else
	{
		printf("\n [+] Exiting assessment anchor run test because anchors are null.");
		return ERR_FAILURE;
	}

	// general purpose iterators used for walking checks in the
	// loops below.
	size_t anchorVarIndex = 0;
	size_t xssTestIndex   = 0;

	// set in the anchor loop below dynamically (per loop)
	size_t anchorVarCount = 0;
	size_t anchorLen = 0;

	// Browser string used for request randomizations (allocated and bpfreed() per loop)
	char *browserStr = NULL;

	// set anchor (GET) and form (GET/POST) test string allocated/used/freed in loop.
	char *anchorTest = NULL;

	// XSS test created/destroyed on loop
	char *xssTest = NULL;

	// sql injection test created/destroyed on loop
	char *sqlInjectTest = NULL;

	// form test string created/destroyed on loop
	char *formTest = NULL;

	// Temporary string used and bpfree'd below which takes a string
	// with ordinary spaces, and encodes them as %20s if encountered.
	// (necessary for libcurl to properly utilize strings)
	char *unicodeSpaceEncodeStr = NULL;

	// Result set pointers (used internally and stored in assessment)---------
	P_BP_WEB_XSS_TEST_RESULT    xssResultSet    = NULL;
	P_BP_WEB_SQLINJ_TEST_RESULT sqlInjResultSet = NULL;

	// Match set utilized during the index matching
	P_BP_WEB_ANALYSIS_RESULT_INDEX_SET indexSet = NULL;

	/***********************************************************
	 * MAIN ANCHOR ANALYSIS LOOP
	 * *********************************************************/

	// walk anchors and perform tests based around the anchor sets/tests
	for
	(
			anchors = anchors->first->next;
			anchors;
			anchors = anchors->next
	)
	{

		// Retrieves the variable count from an anchor based
		// on the delimiter set used for parsing.
		anchorVarCount = HTMLGetAnchorVarCount(anchors->vars);

		// if the anchor count is 0, we can skip to the next anchor
		// element.
		if (!anchorVarCount)
			continue;

		// This variable is used in the case that the assessment is
		// started with a base URL which contains a script name
		// eg. www.google.com/index.html in which case the appending
		// of any variables or test conditions would cause a problem.
		// In the if() statements below you can see how this variable
		// has the script name stripped out and the appending is done
		// properly to avoid problems.
		char *baseTestURL = NULL;


		printf("\n Xss Testing Anchor: %s", anchors->href);

		// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		// %%%%%%%%% XSS CHECKS FIRST %%%%%%%%%%%%%%%%%%%%

		// walk xss checks in the assessment (all checks per var)
		for
		(
				xssTestIndex = 0;
				;
				xssTestIndex++
		)
		{

			// test is required to have a test front
			if(!assessment->xssChecks[xssTestIndex].testFront)
				break;

			// now walk individual anchor variables
			for (anchorVarIndex = 0; anchorVarIndex < anchorVarCount; anchorVarIndex++)
			{

				// set base url + max lengths (bpstrlen is safe due to bpstrndup allocation)
				anchorLen = strnlen(assessment->baseAssessmentURL, 2048);

				// this routine gets a count of the character composition of anchors
				anchorLen += BP_GetAnchorVarMaxLengths(anchors->vars);

				// add front and tail check lengths to the total
				if(assessment->xssChecks[xssTestIndex].testFront)
					anchorLen += strnlen(assessment->xssChecks[xssTestIndex].testFront, 2048);

				if(assessment->xssChecks[xssTestIndex].testTail)
					anchorLen += strnlen(assessment->xssChecks[xssTestIndex].testTail, 2048);

				// add max embedded length
				anchorLen += BP_MAX_EMBEDDED_ANCHOR_TEST_LENGTH;

				// substitute variable at position
				anchorTest = (char *) bprealloc(anchorTest, anchorLen);
				memset(anchorTest, 0x00, anchorLen);

				// Check to see if we have a http:// or https:// link.  If not consider
				// link a relative link.
				if
				(
						anchors->proto == BP_ANCHOR_PROTO_HTTP ||
						anchors->proto == BP_ANCHOR_PROTO_HTTPS
				)
				{


					// create base test url (duplicated)
					baseTestURL      = BP_ParseURLToPathPCRE(anchors->full_url, BP_FALSE);

					// parse script (duplicated)
					char *tmp_script = BP_ParseURLToScriptPCRE(anchors->full_url, BP_FALSE);

					if(tmp_script)
						snprintf(anchorTest, anchorLen, "%s", tmp_script);
					else
						snprintf(anchorTest, anchorLen, "%s", baseTestURL);

					if(tmp_script)
					{
						bpfree(tmp_script);
						tmp_script = NULL;
					}



				}
				else
				{

					// baseTestURL = HTTPStripScript(assessment->baseAssessmentURL, bpstrlen(assessment->baseAssessmentURL));
					baseTestURL = BP_ParseURLToPathPCRE(assessment->baseAssessmentURL, BP_FALSE);
					char *tmp_script = BP_ParseURLToScriptPCRE(anchors->full_url, BP_FALSE);


					if(tmp_script)
					{
						snprintf(anchorTest, anchorLen, "%s",tmp_script);
						bpfree(tmp_script);
						tmp_script = NULL;

					}




				}

				// destroy test url if set then nullify for loop
				if (baseTestURL)
				{
					bpfree(baseTestURL);
					baseTestURL = NULL;
				}

				// %%%%%%%%%% BEGIN XSS TESTS %%%%%%%%%%%%%%%%%%%%%%%%%%

				// destroy xssTest if it already exists for some god forsaken reason
				if(xssTest)
				{
					bpfree(xssTest);
					xssTest = NULL;
				}

				// generate the xss test
				xssTest = BP_WebAssessmentGenerateXSSAnchorTestSet
				(
						anchorTest,
						&assessment->xssChecks[xssTestIndex],
						anchors->vars,
						anchors->delims,
						assessment->xssPayload,
						anchorVarIndex
				);

				// continue loop if there is no xss test here
				if(!xssTest)
					continue;


				if(unicodeSpaceEncodeStr)
				{
					bpfree(unicodeSpaceEncodeStr);
					unicodeSpaceEncodeStr = NULL;
				}

				// run request against anchor
				unicodeSpaceEncodeStr = BP_GenUnicodeSpaceString(xssTest, bpstrlen(xssTest));
				// printf("\n Got anchor final test after fixup: %s", xssTest);

				// bpfree browser string on loop if set
				if (browserStr)
				{
					bpfree(browserStr);
					browserStr = NULL;
				}

				// enable browser pool randomization
				if (assessment->randomizeBrowserStrsBetweenRequests)
				{
					browserStr = BP_HTTPGetRandomUserAgentString(assessment->userAgentPool, assessment->userAgentCount);
					BP_HTTPUserAgent(assessment->session, browserStr);
				}

				// generate exploit request set
				P_BP_WEB_EXPLOIT_REQUEST_SET ers = BP_GenWebExploitRequestSet(unicodeSpaceEncodeStr, NULL);


				// run the actual test, continue if not-possible
				if(BP_RunWebExploitRequestSet(assessment, ers, assessment->http_request_max_retries) != ERR_SUCCESS)
				{
					BP_DestroyWebExploitRequestSet(ers);
					continue;
				}

				// display the exploit request set
				BP_DisplayExploitRequestSet(ers);

				// if the browser string was not destroyed, destroy it here
				if (browserStr)
				{
					bpfree(browserStr);
					browserStr = NULL;
				}

				// destroy unicode string
				if (unicodeSpaceEncodeStr)
				{
					bpfree(unicodeSpaceEncodeStr);
					unicodeSpaceEncodeStr = NULL;
				}

				// reset unicode pointer
				unicodeSpaceEncodeStr = NULL;


				// run xss verification code
				xssResultSet = BP_WebAssessmentRunXSSAnchorMatchCheck
				(
						assessment,
						&assessment->xssChecks[xssTestIndex],
						xssTestIndex,
						true,
						anchors,
						anchors->vars,
						anchorVarIndex
				);



				// destroy and nullify if no match was made
				if (xssResultSet->match == false && xssResultSet->magicQuotesMatch == false)
				{

					bpfree(xssResultSet);
					xssResultSet = NULL;

				}
				else
				{

					xssResultSet->anchorActualTest = bpstrndup(xssTest, bpstrlen(xssTest));

				}

				// set basic data
				BP_WebAssessmentSetBasicRequestData
				(
						assessment,
						&xssResultSet->request_data, /* this structure is filled */
						ers,
						assessment->session,
						anchors,
						anchorVarIndex,
						NULL, /* form */
						0,    /* form index */
						0   /* header index */
				);

				// destroy xss test string
				if (xssTest)
				{
					bpfree(xssTest);
					xssTest = NULL;
				}


				// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
				// %%% Set Request Data %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
				// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

				// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
				// %%% Append Result to the Assessment %%%%%%%%%%%%%%%%%%%
				// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

				// Add result to the list if the result found a match
				if (xssResultSet != NULL)
				{

					if (assessment->xssResults == NULL)
					{
						assessment->xssResults = xssResultSet;
					}
					else
					{

						// send email if required
						if(assessment->send_notification_email_on_xss)
						{

							// set find strings
							char * find_strs[] = {
									"BASE_HREF",
									"HTTP_GET_DATA",
									"HTTP_POST_DATA",
									"HTTP_COOKIE_DATA",
									NULL,
							};

							// set replace strings
							char * replace_strs[] = {
									assessment->baseAssessmentURL,
									ers->get_str,
									ers->post_str,
									ers->cookie_str,
									NULL
							};

							if(!replace_strs[0])
								replace_strs[0] = "";
							if(!replace_strs[1])
								replace_strs[1] = "";
							if(!replace_strs[2])
								replace_strs[2] = "";
							if(!replace_strs[3])
								replace_strs[3] = "";

							char *email_send_str = BP_GenerateSubstitutedTemplate(assessment->email_xss_template, find_strs, replace_strs);


						    // attempt to send new message
						    BP_SendEmailMessage(
						    		assessment->email_smtp_username,
						    		assessment->email_smtp_password,
						    		assessment->email_smtp_server,
						    		assessment->email_smtp_from,
						    		assessment->notification_emails,
						    		/* Message Body including Subject */
						    		"Subject: XSS Detected in Anchor:",
						    		email_send_str
							);

						}

						BP_WebAssessmentAppendXSSResultToList(assessment->xssResults, xssResultSet);
					}

				}


				if(ers)
				{
					BP_DestroyWebExploitRequestSet(ers);
					ers = NULL;
				}


				// zero out anchor test
				memset(anchorTest, 0x00, anchorLen);

				// Destroy the session page memory pointers before running
				if (assessment->session->page->memPtr != NULL) {
					//bpfree(assessment->session->page->memPtr);
					//assessment->session->page->memPtr = NULL;
					//assessment->session->page->size = 0;
				}

				// destroy xss test string
				if (xssTest)
				{
					bpfree(xssTest);
					xssTest = NULL;
				}

			}

			// destroy xss test string
			if (xssTest)
			{
				bpfree(xssTest);
				xssTest = NULL;
			}

		} // END ANCHOR XSS TESTS

		// destroy xss test string if its still set somehow
		if (xssTest)
		{
			bpfree(xssTest);
			xssTest = NULL;
		}

		// destroy encoded string
		if (unicodeSpaceEncodeStr)
		{
			bpfree(unicodeSpaceEncodeStr);
			unicodeSpaceEncodeStr = NULL;
		}

		// destroy anchor test if set
		if (anchorTest)
		{
			bpfree(anchorTest);
			anchorTest = NULL;
		}

		// Destroy assessment last retrieved buffer content
		if (assessment->session->page->memPtr != NULL)
		{
			//bpfree(assessment->session->page->memPtr);
			//assessment->session->page->memPtr = NULL;
			//assessment->session->page->size = 0;
		}


		// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		// %%%%%%%% BEGIN SQL INJECTION TESTING  %%%%%%%%%%%%%%%%%%%%
		// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


		// walk sql checks in the assessment
		for
		(
			xssTestIndex = 0;
			;
			xssTestIndex++
		)
		{

			// ensure we have a first check
			if(!assessment->sqlChecks[xssTestIndex].testFront)
				break;

			// walk individual anchor variables and test them all
			for
			(
				anchorVarIndex = 0;
				anchorVarIndex < anchorVarCount;
				anchorVarIndex++
			)
			{


				// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
				// %%% BEGIN ANCHOR/RELATIVE ANCHOR COMPOSITING %%%%%%%%%
				// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

				// set base url + max lengths
				anchorLen  = bpstrlen(assessment->baseAssessmentURL);
				anchorLen += BP_GetAnchorVarMaxLengths(anchors->vars);

				// plus check front and tail
				anchorLen += bpstrlen(assessment->sqlChecks[xssTestIndex].testFront);
				anchorLen += bpstrlen(assessment->sqlChecks[xssTestIndex].testTail);

				// plus max embedded length
				anchorLen += BP_MAX_EMBEDDED_ANCHOR_TEST_LENGTH;

				// Generates a test target based off an anchor.
				anchorTest = BP_WebExploitationGetAnchorRelativeTestTarget(assessment, anchors, anchorLen);



				// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
				// %%% BEGIN SQL TESTS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
				// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


				// generate the sql injection test
				sqlInjectTest = BP_WebAssessmentGenerateSQLAnchorTestSet
				(
					anchorTest,
					&assessment->sqlChecks[xssTestIndex],
					anchors->vars,
					anchors->delims,
					assessment->sqlInjectPayload,
					anchorVarIndex
				);

				// anchor test is no longer required at this point, destroy it on loop.
				if(anchorTest)
				{
					bpfree(anchorTest);
					anchorTest = NULL;
				}

				// Free this on loop.  Since this is generated below, we can
				// free this once the loop encounters it.  It's free'd again
				// a final time on exit.
				if(unicodeSpaceEncodeStr)
				{
					bpfree(unicodeSpaceEncodeStr);
					unicodeSpaceEncodeStr = NULL;
				}

				// Encode the string with unicode spaces so as not to anger cURL (destroyed on loop)
				unicodeSpaceEncodeStr = BP_GenUnicodeSpaceString(sqlInjectTest, bpstrlen(sqlInjectTest));

				// At this point destroy the sql injection test.
				if (sqlInjectTest)
				{
					bpfree(sqlInjectTest);
					sqlInjectTest = NULL;
				}

				// If you've set a browser string, destroy it on loop.  It gets
				// set again below.
				if (browserStr)
				{
					bpfree(browserStr);
					browserStr = NULL;
				}

				// set the browser string from a random string here
				if (assessment->randomizeBrowserStrsBetweenRequests)
				{

					// gather the browser string
					browserStr = BP_HTTPGetRandomUserAgentString(assessment->userAgentPool, assessment->userAgentCount);

					// set the user agent
					BP_HTTPUserAgent(assessment->session, browserStr);

				}

				// generate exploit request set
				P_BP_WEB_EXPLOIT_REQUEST_SET ers = BP_GenWebExploitRequestSet(unicodeSpaceEncodeStr, NULL);

				// run the actual test, continue if not-possible
				if(BP_RunWebExploitRequestSet(assessment, ers, assessment->http_request_max_retries) != ERR_SUCCESS)
				{

					// destroy the exploit request set
					BP_DestroyWebExploitRequestSet(ers);

					// If you've set a browser string, destroy it on loop.
					if (browserStr)
					{
						bpfree(browserStr);
						browserStr = NULL;
					}

					if(unicodeSpaceEncodeStr)
					{
						bpfree(unicodeSpaceEncodeStr);
						unicodeSpaceEncodeStr = NULL;
					}

					continue;
				}

				// display the exploit request set
				BP_DisplayExploitRequestSet(ers);


				// if the browser string was not destroyed, destroy it here
				if (browserStr)
				{
					bpfree(browserStr);
					browserStr = NULL;
				}

				// -------------- CHECKS AND STORAGE ----------------

				// Create a new injection result storage structure
				P_BP_WEB_SQLINJ_TEST_RESULT result = (P_BP_WEB_SQLINJ_TEST_RESULT) bpcalloc(sizeof(BP_WEB_SQLINJ_TEST_RESULT), 1);
				result->first = result;

				// MYSQL
				indexSet = BP_WebAssessmentRunTests(assessment, assessment->mysqlErrChecks, assessment->mysqlErrCheckCount);
				if (indexSet)
				{

					result->mysqlTestMatchIndexes = indexSet->matchIndexes;
					result->mysqlTestMatchesMade  = indexSet->matchCount;

					// set engine detection
					result->engineDetectionCount++;
					result->enginesDetected = (BP_SQLINJ_ENGINE *) bprealloc(result->enginesDetected, sizeof(BP_SQLINJ_ENGINE) * result->engineDetectionCount);
					result->enginesDetected[result->engineDetectionCount - 1] = BP_SQLINJ_ENGINE_MYSQL;

					// destroy index set
					bpfree(indexSet);
				}

				// MSQL
				indexSet = BP_WebAssessmentRunTests(assessment, assessment->msqlErrChecks, assessment->msqlErrCheckCount);
				if (indexSet)
				{

					// set match count and index
					result->msqlTestMatchIndexes = indexSet->matchIndexes;
					result->msqlTestMatchesMade  = indexSet->matchCount;

					// set engine detection
					result->engineDetectionCount++;
					result->enginesDetected = (BP_SQLINJ_ENGINE *) bprealloc(result->enginesDetected, sizeof(BP_SQLINJ_ENGINE) * result->engineDetectionCount);
					result->enginesDetected[result->engineDetectionCount - 1] = BP_SQLINJ_ENGINE_MSQL;

					bpfree(indexSet);
				}

				// ORACLE
				indexSet = BP_WebAssessmentRunTests(assessment, assessment->oracleErrChecks, assessment->oracleErrCheckCount);
				if (indexSet)
				{

					// set match count and index
					result->oracleTestMatchIndexes = indexSet->matchIndexes;
					result->oracleTestMatchesMade  = indexSet->matchCount;

					// set engine detection
					result->engineDetectionCount++;
					result->enginesDetected = (BP_SQLINJ_ENGINE *) bprealloc(result->enginesDetected, sizeof(BP_SQLINJ_ENGINE) * result->engineDetectionCount);
					result->enginesDetected[result->engineDetectionCount - 1] = BP_SQLINJ_ENGINE_ORACLE;

					bpfree(indexSet);

				}

				// Postgres
				indexSet = BP_WebAssessmentRunTests(assessment, assessment->postgresErrChecks, assessment->postgresErrCheckCount);
				if (indexSet)
				{

					// set match count and index
					result->postgresTestMatchIndexes = indexSet->matchIndexes;
					result->postgresTestMatchesMade  = indexSet->matchCount;

					// set engine detection
					result->engineDetectionCount++;
					result->enginesDetected = (BP_SQLINJ_ENGINE *) bprealloc(result->enginesDetected, sizeof(BP_SQLINJ_ENGINE) * result->engineDetectionCount);
					result->enginesDetected[result->engineDetectionCount - 1] = BP_SQLINJ_ENGINE_POSTGRES;

					bpfree(indexSet);
				}

				// Odbc
				indexSet = BP_WebAssessmentRunTests(assessment, assessment->odbcErrChecks, assessment->odbcErrCheckCount);
				if (indexSet)
				{

					// set match count and index
					result->odbcTestMatchIndexes = indexSet->matchIndexes;
					result->odbcTestMatchesMade  = indexSet->matchCount;

					// set engine detection
					result->engineDetectionCount++;
					result->enginesDetected = (BP_SQLINJ_ENGINE *) bprealloc(result->enginesDetected, sizeof(BP_SQLINJ_ENGINE) * result->engineDetectionCount);
					result->enginesDetected[result->engineDetectionCount - 1] = BP_SQLINJ_ENGINE_ODBC;

					bpfree(indexSet);
				}


				// set basic data
				BP_WebAssessmentSetBasicRequestData
				(
						assessment,
						&result->request_data, /* this structure is filled */
						ers,
						assessment->session,
						anchors,
						anchorVarIndex,
						NULL, /* form */
						0,    /* form index */
						0   /* header index */
				);



				// Check to see if any matches were made, if so
				// link up the result with the existing list.
				if
				(
					result->odbcTestMatchesMade     ||
					result->oracleTestMatchesMade   ||
					result->mysqlTestMatchesMade    ||
					result->msqlTestMatchesMade	    ||
					result->postgresTestMatchesMade
				)
				{

					// Set appropriate structure pointers and data (per loop)
					result->anchor = anchors;
					result->anchorActualTest  = bpstrndup(unicodeSpaceEncodeStr, 65535);
					result->anchorVarPosition = anchorVarIndex;
					result->targetType        = BP_SQLINJ_TARGET_TYPE_ANCHOR;
					result->testIndex         = xssTestIndex;

					// Link the result in the list
					if (!assessment->sqlResults)
					{
						assessment->sqlResults = result;
					}
					else
					{
						BP_WebAssessmentAppendSQLResultToList(assessment->sqlResults, result);
					}

					// send email if required
					if(assessment->send_notification_email_on_sql_error_messages)
					{

						// set find strings
						char * find_strs[] =
						{
								"BASE_HREF",
								"HTTP_GET_DATA",
								"HTTP_POST_DATA",
								"HTTP_COOKIE_DATA",
								NULL,
						};

						// set replace strings
						char * replace_strs[] =
						{
								assessment->baseAssessmentURL,
								ers->get_str,
								ers->post_str,
								ers->cookie_str,
								NULL
						};

						// Fill in blank strings with valid empty pointers if
						// necessary.
						if(!replace_strs[0])
							replace_strs[0] = "";
						if(!replace_strs[1])
							replace_strs[1] = "";
						if(!replace_strs[2])
							replace_strs[2] = "";
						if(!replace_strs[3])
							replace_strs[3] = "";

						// generate the substituted template
						char *email_send_str = BP_GenerateSubstitutedTemplate
						(
								assessment->email_sql_error_message_template,
								find_strs,
								replace_strs
						);

					    // attempt to send new message
					    BP_SendEmailMessage
					    (
							   assessment->email_smtp_username,
							   assessment->email_smtp_password,
							   assessment->email_smtp_server,
							   assessment->email_smtp_from,
							   assessment->notification_emails,
							   /* Message Body including Subject */
							   "Subject: SQL Error Message Detected:",
							   email_send_str
						);

					}

				}
				else
				{

					// if the result hasn't been added (due to the result not having
					// any loggable data) destroy it here.
					bpfree(result);
					result = NULL;

				}


				// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
				// %%% Run Application Error Checks %%%%%%%%%%%%%%%%%%%%%%%%%
				// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


				// Create new appserver test result structure
				P_BP_WEB_APPSERVER_TEST_RESULT appresult = (P_BP_WEB_APPSERVER_TEST_RESULT) bpcalloc(sizeof(BP_WEB_APPSERVER_TEST_RESULT), 1);

				// set the first item in app result
				appresult->first = appresult;

				// set basic data
				BP_WebAssessmentSetBasicRequestData
				(
						assessment,
						&appresult->request_data, /* this structure is filled */
						ers,
						assessment->session,
						anchors,
						anchorVarIndex,
						NULL, /* form */
						0,    /* form index */
						0   /* header index */
				);


				// PHP
				// __asm("int3");
				indexSet = BP_WebAssessmentRunTests(assessment, assessment->phpErrChecks, assessment->phpErrCheckCount);
				if (indexSet)
				{
					// __asm("int3");
					// set php match indexes
					appresult->phpTestMatchIndexes = indexSet->matchIndexes;

					// set php matches made count
					appresult->phpTestMatchesMade = indexSet->matchCount;

					// set engine detection
					appresult->engineDetectionCount++;
					appresult->enginesDetected = (BP_APPSERVER_ENGINE *) bprealloc(appresult->enginesDetected, sizeof(BP_APPSERVER_ENGINE)	* appresult->engineDetectionCount);
					appresult->enginesDetected[appresult->engineDetectionCount - 1] = BP_APPSERVER_ENGINE_PHP;

					// destroy index set
					bpfree(indexSet);

				}

				// ASP
				indexSet = BP_WebAssessmentRunTests(assessment, assessment->aspErrChecks, assessment->aspErrCheckCount);
				if (indexSet)
				{

					// set the match count and the matches made
					appresult->aspTestMatchIndexes = indexSet->matchIndexes;
					appresult->aspTestMatchesMade  = indexSet->matchCount;

					// set engine detection
					appresult->engineDetectionCount++;
					appresult->enginesDetected = (BP_APPSERVER_ENGINE *) bprealloc(appresult->enginesDetected, sizeof(BP_APPSERVER_ENGINE)* appresult->engineDetectionCount);
					appresult->enginesDetected[appresult->engineDetectionCount - 1] = BP_APPSERVER_ENGINE_ASP;

					// destroy index set
					bpfree(indexSet);

				}

				// JSP
				indexSet = BP_WebAssessmentRunTests(assessment, assessment->jspErrChecks, assessment->jspErrCheckCount);
				if (indexSet)
				{

					// set the match count and the matches made
					appresult->jspTestMatchIndexes = indexSet->matchIndexes;
					appresult->jspTestMatchesMade  = indexSet->matchCount;

					// set engine detection
					appresult->engineDetectionCount++;
					appresult->enginesDetected = (BP_APPSERVER_ENGINE *) bprealloc(appresult->enginesDetected, sizeof(BP_APPSERVER_ENGINE) * appresult->engineDetectionCount);
					appresult->enginesDetected[appresult->engineDetectionCount - 1] = BP_APPSERVER_ENGINE_JSP;

					// destroy index set
					bpfree(indexSet);

				}

				// .NET
				indexSet = BP_WebAssessmentRunTests(assessment, assessment->dnetErrChecks, assessment->dnetErrCheckCount);
				if (indexSet)
				{

					// set the match count and the matches made
					appresult->dnetTestMatchIndexes = indexSet->matchIndexes;
					appresult->dnetTestMatchesMade  = indexSet->matchCount;

					// set engine detection
					appresult->engineDetectionCount++;
					appresult->enginesDetected = (BP_APPSERVER_ENGINE *) bprealloc(appresult->enginesDetected, sizeof(BP_APPSERVER_ENGINE) * appresult->engineDetectionCount);
					appresult->enginesDetected[appresult->engineDetectionCount - 1] = BP_APPSERVER_ENGINE_DNET;

					// destroy index set
					bpfree(indexSet);

				}

				// Cold Fustion
				indexSet = BP_WebAssessmentRunTests(assessment, assessment->cfmErrChecks, assessment->cfmErrCheckCount);
				if (indexSet)
				{

					// set the match count and the matches made
					appresult->cfmTestMatchIndexes = indexSet->matchIndexes;
					appresult->cfmTestMatchesMade  = indexSet->matchCount;

					// set engine detection
					appresult->engineDetectionCount++;
					appresult->enginesDetected = (BP_APPSERVER_ENGINE *) bprealloc(appresult->enginesDetected, sizeof(BP_APPSERVER_ENGINE) * appresult->engineDetectionCount);
					appresult->enginesDetected[appresult->engineDetectionCount - 1] = BP_APPSERVER_ENGINE_CFM;

					// destroy index set
					bpfree(indexSet);

				}

				// Check to see if any matches were made, if so
				// link up the result with the existing list.
				if
				(

					// set the match count and the matches made
					appresult->phpTestMatchesMade ||
					appresult->aspTestMatchesMade ||
					appresult->jspTestMatchesMade ||
					appresult->cfmTestMatchesMade ||
					appresult->dnetTestMatchesMade
				)
				{

					// Set appropriate structure pointers and data (per loop)
					appresult->anchor = anchors;
					appresult->anchorActualTest  = bpstrndup(unicodeSpaceEncodeStr, 65535);
					appresult->anchorVarPosition = anchorVarIndex;
					appresult->targetType        = BP_APPSERVER_TARGET_ANCHOR;

					// Link the result in the list
					if (!assessment->appErrorResults)
						assessment->appErrorResults = appresult;
					else
						BP_WebAssessmentAppendAppEngineResultToList(assessment->appErrorResults, appresult);

					// send email if required
					if(assessment->send_notification_email_on_appserver_messages)
					{

						// set find strings
						char * find_strs[] =
						{
								"BASE_HREF",
								"HTTP_GET_DATA",
								"HTTP_POST_DATA",
								"HTTP_COOKIE_DATA",
								NULL,
						};

						// set replace strings
						char * replace_strs[] =
						{
								assessment->baseAssessmentURL,
								ers->get_str ? ers->get_str : (char *) "",
								ers->post_str ? ers->post_str : (char *) "",
								ers->cookie_str ? ers->cookie_str : (char *) "",
								NULL
						};

						if(!replace_strs[0])
							replace_strs[0] = " ";
						if(!replace_strs[1])
							replace_strs[1] = " ";
						if(!replace_strs[2])
							replace_strs[2] = " ";
						if(!replace_strs[3])
							replace_strs[3] = " ";

						char *email_send_str = BP_GenerateSubstitutedTemplate(assessment->email_appserver_message_template, find_strs, replace_strs);

					    // attempt to send new message
					    BP_SendEmailMessage
					    (
					    		   assessment->email_smtp_username,
					    		   assessment->email_smtp_password,
					    		   assessment->email_smtp_server,
					               assessment->email_smtp_from,
					               assessment->notification_emails,
					               /* Message Body including Subject */
					               "Subject: GrIEF Appserver Error Detected",
					               email_send_str
					    );

					    if(email_send_str)
					    	bpfree(email_send_str);

					}

				}
				else /* if the app result is empty, destroy items before looping */
				{
					// destroy app result if necessary
					if(appresult)
						bpfree(appresult);

					// null out pointer
					appresult = NULL;

				}

				// Destroy sql test
				if (sqlInjectTest)
				{
					bpfree(sqlInjectTest);
					sqlInjectTest = NULL;
				}

				// Destroy Unicode encoded str
				if (unicodeSpaceEncodeStr)
				{
					bpfree(unicodeSpaceEncodeStr);
					unicodeSpaceEncodeStr = NULL;
				}

				// Destroy the session page memory pointers before moving on to forms
				// next.
				if (assessment->session->page->memPtr != NULL)
				{
					// bpfree(assessment->session->page->memPtr);
					// assessment->session->page->memPtr = NULL;
					// assessment->session->page->size = 0;
				}

				if(ers)
				{
					BP_DestroyWebExploitRequestSet(ers);
					ers = NULL;
				}

			}

		} // END ANCHOR SQL TESTS


		// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		// %%% BEGIN BLIND SQL INJECTION TESTING  %%%%%%%%%%%%%%%%%%%
		// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

		// run blind sqli tests if set (can be request intensive)
		if(assessment->bsqli_testing_enabled)
			BP_WebAssessmentCheckAnchorForBlindSQLi( assessment, anchors );

	}

	// reset saved first in the page extraction
	assessment->pageExtraction->anchors = anchorSavedFirst;

	// return indicating success
	return ERR_SUCCESS;

}

// Generates a test target based off an anchor.
char *BP_WebExploitationGetAnchorRelativeTestTarget(P_BP_WEB_ASSESSMENT assessment, P_BP_HTML_ANCHOR_LIST anchor, size_t anchor_buff_len)
{

	if(!anchor)
		return NULL;

	// url used as a baseline test, initialized
	char * baseTestURL = NULL;

	// substitute variable at position
	char * anchorTest = (char *) bpcalloc(anchor_buff_len, 1);
	memset(anchorTest, 0x00, anchor_buff_len);

	// Check to see if we have a http:// or https:// or relative link.
	if
	(
			anchor->proto == BP_ANCHOR_PROTO_HTTP ||
			anchor->proto == BP_ANCHOR_PROTO_HTTPS
	)
	{

		// create base test url (duplicated)
		// baseTestURL      = BP_ParseURLToPathPCRE(anchor->href);

		baseTestURL = bpstrdup(anchor->path);

		// parse script (duplicated)
		char *tmp_script = BP_ParseURLToScriptPCRE(anchor->full_url, BP_FALSE);

		if(tmp_script)
		{

			snprintf(anchorTest, anchor_buff_len, "%s", (char *) tmp_script);

		}
		else
		{
			snprintf(anchorTest, anchor_buff_len, "%s", baseTestURL);
		}

		if(tmp_script)
			bpfree(tmp_script);

	}
	else
	{

		// baseTestURL = HTTPStripScript(assessment->baseAssessmentURL, bpstrlen(assessment->baseAssessmentURL));
		baseTestURL = bpstrdup(anchor->path);
		char *tmp_script = BP_ParseURLToScriptPCRE(anchor->full_url, BP_FALSE);

		if(tmp_script)
		{

			snprintf(anchorTest, anchor_buff_len, "%s", (char *) tmp_script);

		}

		if(tmp_script)
			bpfree(tmp_script);


	}

	// destroy test url if set then nullify for loop
	if (baseTestURL)
	{
		bpfree(baseTestURL);
		baseTestURL = NULL;

	}

	return anchorTest;

}

