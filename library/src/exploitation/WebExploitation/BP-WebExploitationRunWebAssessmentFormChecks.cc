/*
 * BP-WebExploitationRunWebAssessmentFormChecks.cc
 *
 *  Created on: Dec 10, 2011
 *      Author: root
 */

// Include main header
#include "../../../include/BP-Main.h"



// Checks form in an assessment (SHOULD BE INVOKED FROM MAIN DISPATCHER ONLY)
size_t BP_RunWebAssessmentFormChecks(P_BP_WEB_ASSESSMENT assessment)
{

	// Null check
	if (!assessment)
		return ERR_FAILURE;

	if (BP_CheckWebAssessmentPointers(assessment) != ERR_SUCCESS)
		return ERR_FAILURE;

	// make sure we have a valid forms pointer before
	// continuing.
	if (!assessment->pageExtraction->forms)
		return ERR_FAILURE;

	// This variable is used in the case that the assessment is
	// started with a base URL which contains a script name
	// eg. www.google.com/index.html in which case the appending
	// of any variables or test conditions would cause a problem.
	// In the if() statements below you can see how this variable
	// has the script name stripped out and the appending is done
	// properly to avoid problems.
	char *baseTestURL = NULL;

	// Local anchor and form vars used for request generation
	P_BP_HTML_ANCHOR_LIST anchors       = NULL;
	P_BP_HTML_FORM_LIST forms           = NULL;
	P_BP_HTML_FORM_LIST formsSavedFirst = NULL;

	// set anchor pointers
	anchors = assessment->pageExtraction->anchors;

	// set form pointers
	forms = assessment->pageExtraction->forms;

	// create saved first pointer
	formsSavedFirst = forms->first;

	// general purpose iterators used for walking checks in the
	// loops below.
	size_t formInputIndex = 0;
	size_t testSetIndex   = 0;

	// set in the anchor loop below dynamically (per loop)
	size_t anchorLen = 0;

	// input count based on number of forms
	size_t formInputCount = 0;
	size_t formLen = 0;

	// used for detecting form protocols
	BP_ANCHOR_PROTO formProto = BP_ANCHOR_PROTO_DEFAULT;

	// Browser string used for request randomizations (generated and bpfreed() per loop)
	char *browserStr = NULL;

	// set anchor and form tests
	char *anchorTest = NULL;

	// XSS test created on loop
	char *xssTest = NULL;

	// sql injection test created onloop
	char *sqlInjectTest = NULL;

	// form test string
	char *formTest = NULL;

	// Form HTTP Get String
	char *formGetStr = NULL;

	// Temporary string used and bpfree'd below which takes a string
	// with ordinary spaces, and encodes them as %20s
	char *unicodeSpaceEncodeStr = NULL;

	// Result set pointers (used internally and stored in assessment)---------
	P_BP_WEB_XSS_TEST_RESULT xssResultSet = NULL;

	// Match set utilized during the index matching
	P_BP_WEB_ANALYSIS_RESULT_INDEX_SET indexSet = NULL;

	// --------------------------------------------------
	// Form Analysis

	// Target and Method
	P_BP_HTML_FORM_PROPERTY_LIST formActionInput = NULL;
	P_BP_HTML_FORM_PROPERTY_LIST formMethodInput = NULL;

	// form method,
	BP_HTML_FORM_METHOD formMethod = BP_HTML_FORM_METHOD_UNSET;

	// walk forms and perform tests based around the anchor sets/tests
	for
	(
			forms = forms->first;
			forms != NULL;
			forms = forms->next
	)
	{

		printf("\n [+] Running web assessment form checks: %p", forms);

		// Retrieves the variable count from an anchor based
		// on the delimiter set used for parsing.
		formInputCount = HTMLGetFormVarCount(forms);
		// printf("\n Form input count is: %u", formInputCount);

		// if the anchor count is 0, we can skip to the next anchor
		// element.
		if (!formInputCount)
			continue;



		// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

		// walk xss checks in the assessment
		for
		(
			testSetIndex = 0;
			;
			testSetIndex++
		)
		{

			if(!assessment->xssChecks[testSetIndex].testFront)
				break;

			// printf("\n Running form xss checks!: %s", assessment->xssChecks[i].testFront);

			for
			(
				formInputIndex = 0;
				formInputIndex < formInputCount;
				formInputIndex++
			)
			{

				// retrieve the form action property
				formActionInput = HTMLGetFormPropertyByNameI(forms->properties, (char *) "action");

				// The form must have an action property, if not, continue
				if (!formActionInput)
					continue;

				formMethodInput = HTMLGetFormPropertyByNameI(forms->properties, (char *) "method");

				// default form behavior if no method is found, is to use the HTTP GET
				// method.
				if (!formMethodInput)
				{
					formMethod = BP_HTML_FORM_METHOD_GET;
				}
				else
				{
					formMethod = HTMLGetFormMethodFromString(formMethodInput->content);
				}

				// %%%%%%%%%% BEGIN ANCHOR/RELATIVE ANCHOR COMPOSITING %%%%%%%

				// set base url + max lengths
				formLen = strnlen(assessment->baseAssessmentURL, 2048);

				// add test front, no check required due to initial check
				formLen += bpstrlen(assessment->xssChecks[testSetIndex].testFront);

				// check test tail and add to sum
				if(assessment->xssChecks[testSetIndex].testTail)
					formLen += bpstrlen(assessment->xssChecks[testSetIndex].testTail);

				// plus max embedded length
				formLen += BP_MAX_EMBEDDED_ANCHOR_TEST_LENGTH;

				// substitute variable at position
				formTest = (char *) bprealloc(formTest, formLen);
				memset(formTest, 0x00, formLen);

				// Check anchor protocol onsite/offsite check.
				formProto = HTMLGetAnchorProtocol(formActionInput->content, formActionInput->cLen);

				// tmp string for onsite
				char * tmp_str = NULL;

				// run form checks
				if (formProto == BP_ANCHOR_PROTO_HTTP || formProto == BP_ANCHOR_PROTO_HTTPS)
				{

					snprintf(formTest, formLen + 5, "%s", formActionInput->content);
					if(formTest[bpstrlen(formTest)-1] != '/')
						formTest[bpstrlen(formTest)] = '/';

				}
				else
				{

					baseTestURL = BP_ParseURLToPathPCRE(assessment->baseAssessmentURL);
					snprintf(formTest, formLen + 5, "%s%s", baseTestURL, formActionInput->content);

				}

				// destroy tmp string if necessary
				if(tmp_str)
					bpfree(tmp_str);

				// destroy test url if set then nullify for loop
				if (baseTestURL)
				{
					bpfree(baseTestURL);
					baseTestURL = NULL;
				}

				// %%%%%%%%%% BEGIN XSS TESTS %%%%%%%%%%%%%%%%%%%%%%%%%%

				// set xss test
				if(xssTest)
				{
					bpfree(xssTest);
					xssTest = NULL;
				}

				// Generates a form input string suitable for xss testing
				xssTest = BP_WebAssessmentGenerateXSSFormTestSet
				(
						&assessment->xssChecks[testSetIndex],
						forms,
						assessment->pageExtraction->delims,
						assessment->xssPayload,
						formInputIndex
				);

				if (!xssTest)
				{
					continue;
				}

				// run request against anchor
				unicodeSpaceEncodeStr = BP_GenUnicodeSpaceString(xssTest, bpstrlen(xssTest));
				if(formGetStr)
				{
					bpfree(formGetStr);
					formGetStr = NULL;
				}

				// Depending on the form method, link up the variables
				switch (formMethod)
				{

					// create a get request
					case BP_HTML_FORM_METHOD_GET:

						if(formGetStr)
						{
							bpfree(formGetStr);
							formGetStr = NULL;
						}

						// long story short, allocate space for a HTTP GET request based on args + base + start delim lengths (1024 bytes extra in case im a retard)
						formGetStr = (char *) bpcalloc(bpstrlen(formTest) + bpstrlen(unicodeSpaceEncodeStr) + bpstrlen(assessment->pageExtraction->delims->startDelimiter)+ 1024, 1);

						// place data in buffer
						snprintf(formGetStr, bpstrlen(formTest) + bpstrlen(unicodeSpaceEncodeStr) + bpstrlen(assessment->pageExtraction->delims->startDelimiter)+10,
								"%s%s%s", formTest, assessment->pageExtraction->delims->startDelimiter, unicodeSpaceEncodeStr);

						// printf("\n Form get bstring3: %s", formGetStr);
						break;

					// html form method post
					case BP_HTML_FORM_METHOD_POST:

						// if its a post set, we can add only the form test string (URL)
						formGetStr = (char *) bpcalloc(bpstrlen(formTest) + 1024, 1);

						snprintf(formGetStr, bpstrlen(formTest) + 1, "%s", formTest);
						// printf("\n Form get string2: %s", formGetStr);
						break;

					// default is GET (per http standard)
					default:

						// long story short, allocate space for a HTTP GET request based on args + base + start delim lengths (1024 bytes extra in case im a retard)
						formGetStr = (char *) bpcalloc(bpstrlen(formTest) + bpstrlen(unicodeSpaceEncodeStr) + bpstrlen(assessment->pageExtraction->delims->startDelimiter)
								+ 1024, 1);

						// place data in buffer
						snprintf(formGetStr, bpstrlen(formTest) + bpstrlen(unicodeSpaceEncodeStr) + bpstrlen(assessment->pageExtraction->delims->startDelimiter),
								"%s%s%s", formTest, assessment->pageExtraction->delims->startDelimiter, unicodeSpaceEncodeStr);

						// printf("\n Form get string1: %s", formGetStr);
						break;
				}

				// bpfree browser string on loop if set
				if (browserStr)
				{
					bpfree(browserStr);
					browserStr = NULL;
				}

				if (assessment->randomizeBrowserStrsBetweenRequests)
				{
					browserStr = BP_HTTPGetRandomUserAgentString(assessment->userAgentPool, assessment->userAgentCount);
					BP_HTTPUserAgent(assessment->session, browserStr);
				}


				// ##########################################
				// ######### HTTP Request Section ###########
				// ##########################################

				// exploit request set
				P_BP_WEB_EXPLOIT_REQUEST_SET ers = NULL;

				// create form ers (set post if necessary)
				if (formMethod == BP_HTML_FORM_METHOD_POST)
					ers = BP_GenWebExploitRequestSet(formGetStr, unicodeSpaceEncodeStr);
				else
					ers = BP_GenWebExploitRequestSet(formGetStr, NULL);

				// run the actual test, continue if not-possible
				if(BP_RunWebExploitRequestSet(assessment, ers, assessment->http_request_max_retries) != ERR_SUCCESS)
				{

					// destroy the exploit request set
					BP_DestroyWebExploitRequestSet(ers);

					// destroy xss test string
					if (xssTest)
					{
						bpfree(xssTest);
						xssTest = NULL;
					}

					// destroy unicode encoded string
					if (unicodeSpaceEncodeStr)
					{
						bpfree(unicodeSpaceEncodeStr);
						unicodeSpaceEncodeStr = NULL;
					}

					// destroy get string if set
					if (formGetStr)
					{
						bpfree(formGetStr);
						formGetStr = NULL;
					}

					// destroy form test if set
					if (formTest)
					{
						bpfree(formTest);
						formTest = NULL;
					}

					// continue the loop
					continue;
				}

				// display the exploit request set
				BP_DisplayExploitRequestSet(ers);


				// --


				// if the browser string was not destroyed, destroy it here
				if (browserStr) {
					bpfree(browserStr);
					browserStr = NULL;
				}

				// run xss verification code
				xssResultSet = BP_WebAssessmentRunXSSFormMatchCheck
				(
						assessment,
						&assessment->xssChecks[testSetIndex],
						testSetIndex,
						true,
						forms,
						forms->inputs,
						formInputIndex
				);

				// destroy and nullify if no match was made
				if (xssResultSet->match == false && xssResultSet->magicQuotesMatch == false) {
					bpfree(xssResultSet);
					xssResultSet = NULL;
				} else {
					xssResultSet->formActualTest = bpstrndup(xssTest, bpstrlen(xssTest));
				}

				// Add result to the list if the result found a match
				if (xssResultSet != NULL)
				{
					if (assessment->xssResults == NULL) {
						assessment->xssResults = xssResultSet;
					}
					else
					{
						BP_WebAssessmentAppendXSSResultToList(assessment->xssResults, xssResultSet);

						// send email if required
						if(assessment->send_notification_email_on_xss)
						{

							// set find strings
							char * find_strs[] = {
									"BASE_HREF",
									"HTTP_GET_DATA",
									"HTTP_POST_DATA",
									"HTTP_COOKIE_DATA",
									NULL,
							};

							// set replace strings
							char * replace_strs[] = {
									assessment->baseAssessmentURL,
									ers->get_str,
									ers->post_str,
									ers->cookie_str,
									NULL
							};

							if(!replace_strs[0])
								replace_strs[0] = "";
							if(!replace_strs[1])
								replace_strs[1] = "";
							if(!replace_strs[2])
								replace_strs[2] = "";
							if(!replace_strs[3])
								replace_strs[3] = "";

							char *email_send_str = BP_GenerateSubstitutedTemplate(assessment->email_xss_template, find_strs, replace_strs);

						    // attempt to send new message
						    BP_SendEmailMessage(
						    		assessment->email_smtp_username,
						    		assessment->email_smtp_password,
						    		assessment->email_smtp_server,
						    		assessment->email_smtp_from,
						    		assessment->notification_emails,
						    		/* Message Body including Subject */
						    		"Subject: Potential XSS Detected:",
						    		email_send_str
							);

						}
					}
				}

				if(ers)
				{
					BP_DestroyWebExploitRequestSet(ers);
					ers = NULL;
				}

				// zero out anchor test
				memset(anchorTest, 0x00, anchorLen);

				// Destroy the session page memory pointers before running
				// SQL injection checks.
				if (assessment->session->page->memPtr != NULL) {
					//bpfree(assessment->session->page->memPtr);
					//assessment->session->page->memPtr = NULL;
					//assessment->session->page->size = 0;
				}

				// destroy xss test string
				if (xssTest) {
					bpfree(xssTest);
					xssTest = NULL;
				}

				// destroy unicode encoded string
				if (unicodeSpaceEncodeStr) {
					bpfree(unicodeSpaceEncodeStr);
					unicodeSpaceEncodeStr = NULL;
				}

				// destroy get string if set
				if (formGetStr) {
					bpfree(formGetStr);
					formGetStr = NULL;
				}

				// destroy form test if set
				if (formTest) {
					bpfree(formTest);
					formTest = NULL;
				}

			} // END ANCHOR XSS TESTS

		}




		// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		// %%% SQL INJECTION TESTING NEXT %%%%%%%%%%%%%%%%%%%%%%%%%%%
		// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

		// walk sql checks in the assessment
		for
		(
				testSetIndex = 0;
				;
				testSetIndex++
		)
		{

			// check test front
			if(!assessment->sqlChecks[testSetIndex].testFront)
				break;

			// run format input count
			for
			(
				formInputIndex = 0;
				formInputIndex < formInputCount;
				formInputIndex++
			)
			{

				// Retrieves the variable count from an anchor based
				// on the delimiter set used for parsing.
				formInputCount = HTMLGetFormVarCount(forms);

				// if the anchor count is 0, we can skip to the next anchor
				// element.
				if (!formInputCount)
					continue;

				// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
				// retrieve the form action property
				formActionInput = HTMLGetFormPropertyByNameI(forms->properties, "action");

				// The form must have an action property, if not, continue
				if (!formActionInput)
					continue;

				// retrieve form method
				formMethodInput = HTMLGetFormPropertyByNameI(forms->properties, "method");

				// default form behavior if no method is found, is to use the HTTP GET
				// method.
				if (!formMethodInput)
				{
					formMethod = BP_HTML_FORM_METHOD_GET;
				}
				else
				{
					formMethod = HTMLGetFormMethodFromString(formMethodInput->content);
				}

				// %%%%%%%%%% BEGIN ANCHOR/RELATIVE ANCHOR COMPOSITING %%%%%%%

				// set base url + max lengths
				formLen = bpstrlen(assessment->baseAssessmentURL);

				// plus check front and tail
				if(assessment->sqlChecks[testSetIndex].testFront)
					formLen += bpstrlen(assessment->sqlChecks[testSetIndex].testFront);
				if(assessment->sqlChecks[testSetIndex].testTail)
					formLen += bpstrlen(assessment->sqlChecks[testSetIndex].testTail);

				// plus max embedded length
				formLen += BP_MAX_EMBEDDED_ANCHOR_TEST_LENGTH;

				// If the protocol is not 0, then its offsite (change later)
				formProto = HTMLGetAnchorProtocol(formActionInput->content, formActionInput->cLen);

				// destroy the form test if it exists (loop destroy)
				if(formTest)
				{
					bpfree(formTest);
					formTest = NULL;
				}

				// recreate the form test
				formTest = BP_WebExploitationGetFormRelativeTestTarget(assessment, forms, formLen);

				// prevent memory omission
				if(sqlInjectTest)
				{
					bpfree(sqlInjectTest);
					sqlInjectTest = NULL;
				}

				// Generates a form input string suitable for SQL testing
				sqlInjectTest = BP_WebAssessmentGenerateSQLFormTestSet
				(
						&assessment->sqlChecks[testSetIndex],
						forms,
						assessment->pageExtraction->delims,
						assessment->sqlInjectPayload,
						formInputIndex
				);

				// if we don't have a test to run, just continue the loop at this point
				if (!sqlInjectTest)
				{
					continue;
				}

				// run request against anchor
				unicodeSpaceEncodeStr = BP_GenUnicodeSpaceString(sqlInjectTest, bpstrlen(sqlInjectTest));

				// Depending on the form method, link up the variables
				switch (formMethod)
				{

					// create a get request
					case BP_HTML_FORM_METHOD_GET:

						// long story short, allocate space for a HTTP GET request based on args + base + start delim lengths (1024 bytes extra in case im a retard)
						formGetStr = (char *) bpcalloc(bpstrlen(formTest) + bpstrlen(unicodeSpaceEncodeStr) + bpstrlen(assessment->pageExtraction->delims->startDelimiter)	+ 1024, 1);

						// place data in buffer
						snprintf
						(
								formGetStr,
								bpstrlen(formTest) + bpstrlen(unicodeSpaceEncodeStr) + bpstrlen(assessment->pageExtraction->delims->startDelimiter),
							   "%s%s%s",
							   formTest,
							   assessment->pageExtraction->delims->startDelimiter,
							   unicodeSpaceEncodeStr
						);

						break;

					// html form method post
					case BP_HTML_FORM_METHOD_POST:

						// if its a post set, we can add only the form test string (URL)
						formGetStr = (char *) bpcalloc(bpstrlen(formTest) + 1024, 1);
						snprintf(formGetStr, bpstrlen(formTest) + 1, "%s", formTest);
						break;

					// default is GET (per http standard)
					default:

						// long story short, allocate space for a HTTP GET request based on args + base + start delim lengths (1024 bytes extra in case im a retard)
						formGetStr = (char *) bpcalloc(bpstrlen(formTest) + bpstrlen(unicodeSpaceEncodeStr) + bpstrlen(assessment->pageExtraction->delims->startDelimiter)
							+ 1024, 1);

						// place data in buffer
						snprintf(formGetStr, bpstrlen(formTest) + bpstrlen(unicodeSpaceEncodeStr) + bpstrlen(assessment->pageExtraction->delims->startDelimiter),
							"%s%s%s", formTest, assessment->pageExtraction->delims->startDelimiter, unicodeSpaceEncodeStr);
						break;

				}


				// bpfree browser string on loop if set
				if (browserStr)
				{
					bpfree(browserStr);
					browserStr = NULL;
				}

				// generate a random browser string between requests
				if (assessment->randomizeBrowserStrsBetweenRequests)
				{
					browserStr = BP_HTTPGetRandomUserAgentString(assessment->userAgentPool, assessment->userAgentCount);
					BP_HTTPUserAgent(assessment->session, browserStr);
				}

				// ##########################################
				// ######### HTTP Request Section ###########
				// ##########################################

				// exploit request set
				P_BP_WEB_EXPLOIT_REQUEST_SET ers = NULL;

				// Set Exploit Request Set
				if (formMethod == BP_HTML_FORM_METHOD_POST)
				{
					ers = BP_GenWebExploitRequestSet(formGetStr, unicodeSpaceEncodeStr);
				}
				else
				{
					ers = BP_GenWebExploitRequestSet(formGetStr, NULL);
				}

				// run the actual test, continue if not-possible
				if(BP_RunWebExploitRequestSet(assessment, ers, assessment->http_request_max_retries) != ERR_SUCCESS)
				{

					// destroy the exploit request set
					BP_DestroyWebExploitRequestSet(ers);

					// bpfree browser string on loop if set
					if (browserStr)
					{
						bpfree(browserStr);
						browserStr = NULL;
					}

					// destroy unicode string if it exits
					if(unicodeSpaceEncodeStr)
					{
						bpfree(unicodeSpaceEncodeStr);
						unicodeSpaceEncodeStr = NULL;
					}

					if(formGetStr)
					{
						bpfree(formGetStr);
						formGetStr = NULL;
					}

					// destroy used form test string
					if (formTest)
					{
						bpfree(formTest);
						formTest = NULL;
					}

					// destroy unicode string at the end of the test loop only
					if (unicodeSpaceEncodeStr)
					{

						// destroy string
						bpfree(unicodeSpaceEncodeStr);

						// reset unicode pointer
						unicodeSpaceEncodeStr = NULL;

					}

					if(sqlInjectTest)
					{
						bpfree(sqlInjectTest);
						sqlInjectTest = NULL;
					}


					if(formGetStr)
					{
						bpfree(formGetStr);
						formGetStr = NULL;
					}

					continue;

				}

				// display the exploit request set
				printf("\n FORM EXPLOIT REQUEST SET XSS: ");
				BP_DisplayExploitRequestSet(ers);

				// if the browser string was not destroyed, destroy it here
				if (browserStr)
				{
					bpfree(browserStr);
					browserStr = NULL;
				}



				// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
				// %%%%%%%%%%%% SQLI MATCHING ALGORITHMS %%%%%%%%%%%%%%%%
				// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

				// NOTICE: No actual requests are sent past this point.  The
				// remainder of this body is simply checking to see if sql
				// conditions exist.

				// Create a new injection result storage structure
				P_BP_WEB_SQLINJ_TEST_RESULT result = (P_BP_WEB_SQLINJ_TEST_RESULT) bpcalloc(sizeof(BP_WEB_SQLINJ_TEST_RESULT), 1);
				result->first = result;

				// MYSQL
				indexSet = BP_WebAssessmentRunTests(assessment, assessment->mysqlErrChecks, assessment->mysqlErrCheckCount);
				if (indexSet)
				{

					result->mysqlTestMatchIndexes = indexSet->matchIndexes;
					result->mysqlTestMatchesMade  = indexSet->matchCount;

					// set engine detection
					result->engineDetectionCount++;
					result->enginesDetected = (BP_SQLINJ_ENGINE *) bprealloc(result->enginesDetected, sizeof(BP_SQLINJ_ENGINE) * result->engineDetectionCount);
					result->enginesDetected[result->engineDetectionCount - 1] = BP_SQLINJ_ENGINE_MYSQL;

					// destroy the structure
					bpfree(indexSet);

				}

				// MSQL
				indexSet = BP_WebAssessmentRunTests(assessment, assessment->msqlErrChecks, assessment->msqlErrCheckCount);
				if (indexSet) {

					result->msqlTestMatchIndexes = indexSet->matchIndexes;
					result->msqlTestMatchesMade = indexSet->matchCount;

					// set engine detection
					result->engineDetectionCount++;
					result->enginesDetected = (BP_SQLINJ_ENGINE *) bprealloc(result->enginesDetected, sizeof(BP_SQLINJ_ENGINE) * result->engineDetectionCount);
					result->enginesDetected[result->engineDetectionCount - 1] = BP_SQLINJ_ENGINE_MSQL;

					// destroy the structure
					bpfree(indexSet);

				}

				// ORACLE
				indexSet = BP_WebAssessmentRunTests(assessment, assessment->oracleErrChecks, assessment->oracleErrCheckCount);
				if (indexSet) {

					result->oracleTestMatchIndexes = indexSet->matchIndexes;
					result->oracleTestMatchesMade  = indexSet->matchCount;

					// set engine detection
					result->engineDetectionCount++;
					result->enginesDetected = (BP_SQLINJ_ENGINE *) bprealloc(result->enginesDetected, sizeof(BP_SQLINJ_ENGINE) * result->engineDetectionCount);
					result->enginesDetected[result->engineDetectionCount - 1] = BP_SQLINJ_ENGINE_ORACLE;

					// destroy the structure
					bpfree(indexSet);

				}

				// Postgres
				indexSet = BP_WebAssessmentRunTests(assessment, assessment->postgresErrChecks, assessment->postgresErrCheckCount);
				if (indexSet) {

					result->postgresTestMatchIndexes = indexSet->matchIndexes;
					result->postgresTestMatchesMade = indexSet->matchCount;

					// set engine detection
					result->engineDetectionCount++;
					result->enginesDetected = (BP_SQLINJ_ENGINE *) bprealloc(result->enginesDetected, sizeof(BP_SQLINJ_ENGINE) * result->engineDetectionCount);
					result->enginesDetected[result->engineDetectionCount - 1] = BP_SQLINJ_ENGINE_POSTGRES;

					bpfree(indexSet);
				}

				// Odbc
				indexSet = BP_WebAssessmentRunTests(assessment, assessment->odbcErrChecks, assessment->odbcErrCheckCount);
				if (indexSet) {

					result->odbcTestMatchIndexes = indexSet->matchIndexes;
					result->odbcTestMatchesMade = indexSet->matchCount;

					// set engine detection
					result->engineDetectionCount++;
					result->enginesDetected = (BP_SQLINJ_ENGINE *) bprealloc(result->enginesDetected, sizeof(BP_SQLINJ_ENGINE) * result->engineDetectionCount);
					result->enginesDetected[result->engineDetectionCount - 1] = BP_SQLINJ_ENGINE_ODBC;

					bpfree(indexSet);
				}


				// set basic data
				BP_WebAssessmentSetBasicRequestData
				(
						assessment,
						&result->request_data, /* this structure is filled */
						ers,
						assessment->session,
						NULL,            /* anchors */
						0,               /* anchor index */
						forms,           /* form */
						formInputIndex,  /* form input index */
						0                /* header index */
				);

				// Check to see if any matches were made, if so
				// link up the result with the existing list.
				if
				(
						result->odbcTestMatchesMade   ||
						result->oracleTestMatchesMade ||
						result->mysqlTestMatchesMade  ||
						result->msqlTestMatchesMade   ||
						result->postgresTestMatchesMade
				)
				{

					// Set appropriate structure pointers and data (per loop)
					result->form            = forms;
					result->actualInputTest = bpstrndup(unicodeSpaceEncodeStr, 65535);
					result->inputPosition   = formInputIndex;
					result->targetType      = BP_SQLINJ_TARGET_TYPE_FORM;
					result->testIndex       = testSetIndex;

					// Link the result in the list
					if (!assessment->sqlResults)
						assessment->sqlResults = result;
					else
						BP_WebAssessmentAppendSQLResultToList(assessment->sqlResults, result);


					// send email if required
					if(assessment->send_notification_email_on_sql_error_messages)
					{

						// set find strings
						char * find_strs[] =
						{
								"BASE_HREF",
								"HTTP_GET_DATA",
								"HTTP_POST_DATA",
								"HTTP_COOKIE_DATA",
								NULL,
						};

						// set replace strings
						char * replace_strs[] =
						{
								assessment->baseAssessmentURL,
								ers->get_str,
								ers->post_str,
								ers->cookie_str,
								NULL
						};

						if(!replace_strs[0])
							replace_strs[0] = "";
						if(!replace_strs[1])
							replace_strs[1] = "";
						if(!replace_strs[2])
							replace_strs[2] = "";
						if(!replace_strs[3])
							replace_strs[3] = "";

						char *email_send_str = BP_GenerateSubstitutedTemplate(assessment->email_sql_error_message_template, find_strs, replace_strs);

					    // attempt to send new message
					    BP_SendEmailMessage(
						    		   assessment->email_smtp_username,
						    		   assessment->email_smtp_password,
						    		   assessment->email_smtp_server,
						               assessment->email_smtp_from,
						               assessment->notification_emails,
									   /* Message Body including Subject */
									   "Subject: SQL Error Message Detected:",
									   email_send_str
						);

					}

				}
				else
				{
					if(result)
					{
						bpfree(result);
						result = NULL;
					}
				}

				// ----------- APPLICATION ENGINE CHECKS -------------------

				// Create new appserver test result structure
				P_BP_WEB_APPSERVER_TEST_RESULT appresult = (P_BP_WEB_APPSERVER_TEST_RESULT) bpcalloc(sizeof(BP_WEB_APPSERVER_TEST_RESULT), 1);

				// set app result first pointer
				appresult->first = appresult;

				// PHP
				indexSet = BP_WebAssessmentRunTests(assessment, assessment->phpErrChecks, assessment->phpErrCheckCount);
				if (indexSet)
				{

					appresult->phpTestMatchIndexes = indexSet->matchIndexes;
					appresult->phpTestMatchesMade = indexSet->matchCount;

					// set engine detection
					appresult->engineDetectionCount++;
					appresult->enginesDetected = (BP_APPSERVER_ENGINE *) bprealloc(appresult->enginesDetected, sizeof(BP_APPSERVER_ENGINE) * appresult->engineDetectionCount);
					appresult->enginesDetected[appresult->engineDetectionCount - 1] = BP_APPSERVER_ENGINE_PHP;

					// destroy index set
					bpfree(indexSet);
				}

				// ASP
				indexSet = BP_WebAssessmentRunTests(assessment, assessment->aspErrChecks, assessment->aspErrCheckCount);
				if (indexSet)
				{

					appresult->aspTestMatchIndexes = indexSet->matchIndexes;
					appresult->aspTestMatchesMade = indexSet->matchCount;

					// set engine detection
					appresult->engineDetectionCount++;
					appresult->enginesDetected = (BP_APPSERVER_ENGINE *) bprealloc(appresult->enginesDetected, sizeof(BP_APPSERVER_ENGINE) * appresult->engineDetectionCount);
					appresult->enginesDetected[appresult->engineDetectionCount - 1] = BP_APPSERVER_ENGINE_ASP;

					// destroy index set
					bpfree(indexSet);
				}

				// JSP
				indexSet = BP_WebAssessmentRunTests(assessment, assessment->jspErrChecks, assessment->jspErrCheckCount);
				if (indexSet)
				{

					appresult->jspTestMatchIndexes = indexSet->matchIndexes;
					appresult->jspTestMatchesMade = indexSet->matchCount;

					// set engine detection
					appresult->engineDetectionCount++;
					appresult->enginesDetected = (BP_APPSERVER_ENGINE *) bprealloc(appresult->enginesDetected, sizeof(BP_APPSERVER_ENGINE) * appresult->engineDetectionCount);
					appresult->enginesDetected[appresult->engineDetectionCount - 1] = BP_APPSERVER_ENGINE_JSP;

					// destroy index set
					bpfree(indexSet);
				}

				// .NET
				indexSet = BP_WebAssessmentRunTests(assessment, assessment->dnetErrChecks, assessment->dnetErrCheckCount);
				if (indexSet)
				{

					appresult->dnetTestMatchIndexes = indexSet->matchIndexes;
					appresult->dnetTestMatchesMade = indexSet->matchCount;

					// set engine detection
					appresult->engineDetectionCount++;
					appresult->enginesDetected = (BP_APPSERVER_ENGINE *) bprealloc(appresult->enginesDetected, sizeof(BP_APPSERVER_ENGINE) * appresult->engineDetectionCount);
					appresult->enginesDetected[appresult->engineDetectionCount - 1] = BP_APPSERVER_ENGINE_DNET;

					// destroy index set
					bpfree(indexSet);
				}

				// Cold Fustion
				indexSet = BP_WebAssessmentRunTests(assessment, assessment->cfmErrChecks, assessment->cfmErrCheckCount);
				if (indexSet)
				{

					appresult->cfmTestMatchIndexes = indexSet->matchIndexes;
					appresult->cfmTestMatchesMade = indexSet->matchCount;

					// set engine detection
					appresult->engineDetectionCount++;
					appresult->enginesDetected = (BP_APPSERVER_ENGINE *) bprealloc(appresult->enginesDetected, sizeof(BP_APPSERVER_ENGINE) * appresult->engineDetectionCount);
					appresult->enginesDetected[appresult->engineDetectionCount - 1] = BP_APPSERVER_ENGINE_CFM;

					// destroy index set
					bpfree(indexSet);
				}

				// set basic data
				BP_WebAssessmentSetBasicRequestData
				(
						assessment,
						&appresult->request_data, /* this structure is filled */
						ers,
						assessment->session,
						NULL,            /* anchors */
						0,               /* anchor index */
						forms,           /* form */
						formInputIndex,  /* form input index */
						0                /* header index */
				);

				// Check to see if any matches were made, if so
				// link up the result with the existing list.
				if
				(
						appresult->phpTestMatchesMade ||
						appresult->aspTestMatchesMade ||
						appresult->jspTestMatchesMade ||
						appresult->cfmTestMatchesMade ||
						appresult->dnetTestMatchesMade
				)
				{

					// Set appropriate structure pointers and data (per loop)
					appresult->form            = forms;
					appresult->actualInputTest = bpstrndup(unicodeSpaceEncodeStr, 65535);
					appresult->inputPosition   = formInputIndex;
					appresult->targetType      = BP_APPSERVER_TARGET_FORM;

					// Link the result in the list
					if (!assessment->appErrorResults)
					{
						assessment->appErrorResults = appresult;
					}
					else
					{
						BP_WebAssessmentAppendAppEngineResultToList(assessment->appErrorResults, appresult);
					}

					// send email if required
					if(assessment->send_notification_email_on_appserver_messages)
					{

						// set find strings
						char * find_strs[] = {
							"BASE_HREF",
							"HTTP_GET_DATA",
							"HTTP_POST_DATA",
							"HTTP_COOKIE_DATA",
							NULL,
						};

						// set replace strings
						char * replace_strs[] = {
								assessment->baseAssessmentURL,
								ers->get_str,
								ers->post_str,
								ers->cookie_str,
								NULL
						};

						if(!replace_strs[0])
							replace_strs[0] = "";
						if(!replace_strs[1])
							replace_strs[1] = "";
						if(!replace_strs[2])
							replace_strs[2] = "";
						if(!replace_strs[3])
							replace_strs[3] = "";

						char *email_send_str = BP_GenerateSubstitutedTemplate(assessment->email_appserver_message_template, find_strs, replace_strs);

					    // attempt to send new message
					    BP_SendEmailMessage(
					    		   assessment->email_smtp_username,
					    		   assessment->email_smtp_password,
					    		   assessment->email_smtp_server,
					               assessment->email_smtp_from,
					               assessment->notification_emails,
					               /* Message Body including Subject */
					               "Subject: App. Server Error Detected:",
					               "Application server error was detected. "
					    );

					}

				}
				else
				{

					// destroy the app error results
					BP_DestroyAppErrorResults(appresult);

					// nullify the pointer to prevent confusion
					appresult = NULL;

				}

				// Destroy the session page memory pointers before moving on to forms
				// next.
				if (assessment->session->page->memPtr)
				{

					// destroy the memptr
					//bpfree(assessment->session->page->memPtr);

					// nullify the pointer
					//assessment->session->page->memPtr = NULL;

					// reset the size
					//assessment->session->page->size = 0;

				}

				// destroy used form test string
				if (formTest)
				{
					bpfree(formTest);
					formTest = NULL;
				}

				// destroy unicode string at the end of the test loop only
				if (unicodeSpaceEncodeStr)
				{

					// destroy string
					bpfree(unicodeSpaceEncodeStr);

					// reset unicode pointer
					unicodeSpaceEncodeStr = NULL;

				}

				// destroy sql injection test if it's still set
				if(sqlInjectTest)
				{
					bpfree(sqlInjectTest);
					sqlInjectTest = NULL;
				}

				// destroy form get string if it's still set
				if(formGetStr)
				{
					bpfree(formGetStr);
					formGetStr = NULL;
				}

				// destroy the exploit request set if it's still set
				if(ers)
				{
					BP_DestroyWebExploitRequestSet(ers);
					ers = NULL;
				}


			} // END FORM SQL TESTS

		}


		// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		// %%%%%%%% BEGIN COMMAND EXECUTION TESTING  %%%%%%%%%%%%%%%%
		// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


		// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		// %%%%%%%% BEGIN BLIND SQL INJECTION TESTING  %%%%%%%%%%%%%%
		// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

		// run blind sqli tests if set (can be request intensive)
		if(assessment->bsqli_testing_enabled)
			BP_WebAssessmentCheckFormForBlindSQLi( assessment, forms );

	}

	// reset forms first pointer and return
	assessment->pageExtraction->forms = formsSavedFirst;

	return ERR_SUCCESS;
}



// Generates a test target based off an form.
char *BP_WebExploitationGetFormRelativeTestTarget(P_BP_WEB_ASSESSMENT assessment, P_BP_HTML_FORM_LIST form, size_t form_buff_len)
{

	if(!form)
		return NULL;

	char * baseTestURL = NULL;

	P_BP_HTML_FORM_PROPERTY_LIST formActionInput = HTMLGetFormPropertyByNameI(form->properties, "action");

	// If the protocol is not 0, then its offsite (change later)
	size_t formProto = HTMLGetAnchorProtocol(formActionInput->content, formActionInput->cLen);

	// retrieve form method
	P_BP_HTML_FORM_PROPERTY_LIST formMethodInput = (P_BP_HTML_FORM_PROPERTY_LIST) HTMLGetFormPropertyByNameI(form->properties, "method");

	// substitute variable at position
	char * formTest = (char *) bpcalloc(form_buff_len, 1);
	memset(formTest, 0x00, form_buff_len);


	// Check to see if we have a http:// or https:// or relative link.
	if
	(
			formProto == BP_ANCHOR_PROTO_HTTP ||
			formProto == BP_ANCHOR_PROTO_HTTPS
	)
	{

		// printf("\n Form is http or https!");
		// create base test url (duplicated)
		baseTestURL      = bpstrdup(form->path);

		// BP_ParseURLToPathPCRE(formActionInput->content);

		// parse script (duplicated)
		char *tmp_script = BP_ParseURLToScript(form->full_url, 1, 1);

		// fix the appending bug
		if(bpstrlen(tmp_script) == 2)
		if(memcmp(tmp_script, "./", 2) == 0)
		{
			bpfree(tmp_script);
			tmp_script = NULL;
		}

		if(bpstrlen(tmp_script) == 1)
		if(tmp_script[1] == '/')
		{
			bpfree(tmp_script);
			tmp_script = NULL;
		}

		if(tmp_script)
		{

			if(tmp_script[0] == '/')
			if(bpstrlen(tmp_script) > 1)
				snprintf(formTest, form_buff_len, "%s%s", baseTestURL, (char *) &tmp_script[0]);
			if(tmp_script[0] != '/')
				snprintf(formTest, form_buff_len, "%s%s", baseTestURL, (char *) tmp_script);

		}
		else
		{
			snprintf(formTest, form_buff_len, "%s", baseTestURL);
		}

		if(tmp_script)
			bpfree(tmp_script);

		// printf("\n Got http/https direct form test: %s", formTest);

	}
	else
	{

		// printf("\n Form is relative!");

		// baseTestURL = HTTPStripScript(assessment->baseAssessmentURL, bpstrlen(assessment->baseAssessmentURL));
		baseTestURL = bpstrdup(form->path); // BP_ParseURLToPathPCRE(assessment->baseAssessmentURL);
		char *tmp_script = BP_ParseRelativeLinkToScript(form->full_url, 1);

		// fix the appending bug
		if(bpstrlen(tmp_script) == 2)
		if(memcmp(tmp_script, "./", 2) == 0)
		{
			bpfree(tmp_script);
			tmp_script = NULL;
		}

		if(bpstrlen(tmp_script) == 1)
		if(tmp_script[1] == '/')
		{
			bpfree(tmp_script);
			tmp_script = NULL;
		}


		if(tmp_script)
		{
			if(tmp_script[0] == '/')
			if(bpstrlen(tmp_script) > 1)
				snprintf(formTest, form_buff_len, "%s%s", baseTestURL, (char *) &tmp_script[0]);
			if(tmp_script[0] != '/')
				snprintf(formTest, form_buff_len, "%s%s", baseTestURL, (char *) tmp_script);
			else
				snprintf(formTest, form_buff_len, "%s", baseTestURL);
		}
		else if(formActionInput->content)
		{

			if(formActionInput->content[0] == '/')
			if(bpstrlen(formActionInput->content) > 1)
				snprintf(formTest, form_buff_len, "%s%s", baseTestURL, (char *) &formActionInput->content[0]);

			// fix the appending bug
			if(bpstrlen(formActionInput->content) == 2)
			{
				if(memcmp(formActionInput->content, "./", 2) == 0)
				{
					snprintf(formTest, form_buff_len, "%s", baseTestURL);
				}
			}
			else
			{
				if(formActionInput->content[0] != '/')
					snprintf(formTest, form_buff_len, "%s%s", baseTestURL, (char *) formActionInput->content);
			}

		}
		else
		{
			snprintf(formTest, form_buff_len, "%s", baseTestURL);
		}

		if(tmp_script)
			bpfree(tmp_script);

	}

	// destroy test url if set then nullify for loop
	if (baseTestURL)
	{
		bpfree(baseTestURL);
		baseTestURL = NULL;
	}


	// return the form test
	return formTest;

}

