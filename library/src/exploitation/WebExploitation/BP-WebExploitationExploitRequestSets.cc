/*
 * BP-WebExploitationExploitRequestSets.cc
 *
 *  Created on: Dec 10, 2011
 *      Author: root
 */

// Include main header
#include "../../../include/BP-Main.h"


// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%% Exploit Request Set Manager %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

P_BP_WEB_EXPLOIT_REQUEST_MGR BP_CreateExploitRequestManager
(
		P_BP_HTTP_SESSION         http_session,
		P_BP_HTML_FULL_EXTRACTION html_extraction,
		char * name_identifier
)
{

	// ensure we have a http session
	if(!http_session)
		return NULL;
	if(!html_extraction)
		return NULL;
	if(!name_identifier)
		return NULL;

	// create exploit request manager
	P_BP_WEB_EXPLOIT_REQUEST_MGR mgr = (P_BP_WEB_EXPLOIT_REQUEST_MGR) bpcalloc
	(
			sizeof(BP_WEB_EXPLOIT_REQUEST_MGR),
			1
	);

	// create a tailqueue for the manager, mark it as
	// thread safe since exploits are managed through
	// threads.
	mgr->tq = BP_CreateLinkL(name_identifier, BP_TRUE);

	// set the name
	mgr->name = tq_strdup(mgr->tq, name_identifier, BPLN);



	// return the manager
	return mgr;

}


// Generate exploit request set from FORM,ANCHOR,COOKIE,HEADER etc.
P_BP_WEB_EXPLOIT_REQUEST_SET BP_GenWebExploitRequestSetFromAny
(
		BP_WEB_EXPLOIT_REQUEST_SET_SUBSTITUTION_TYPE sub_type,
		BP_WEB_EXPLOIT_REQUEST_SET_VAR_LOOKUP        lookup_type,
		char *                                       lookup_name,
		size_t                                       lookup_index,
		char *                                       substitution_value,
		P_BP_HTTP_REQUEST_HEADER                     header,
		P_BP_HTML_ANCHOR_LIST                        anchor,
		P_BP_HTML_FORM_LIST                          form,
		P_BP_HTML_INPUT_LIST                         form_inputs
)
{

	// Switch on the sub type to route to the correct processor.
	switch(sub_type)
	{
		case BP_WEB_EXPLOIT_REQUEST_SET_SUBSTITUTION_NONE:
			break;
		case BP_WEB_EXPLOIT_REQUEST_SET_SUBSTITUTION_ANCHOR:
			break;
		case BP_WEB_EXPLOIT_REQUEST_SET_SUBSTITUTION_FORM:
			break;
		case BP_WEB_EXPLOIT_REQUEST_SET_SUBSTITUTION_HEADER:
			break;
		case BP_WEB_EXPLOIT_REQUEST_SET_SUBSTITUTION_COOKIE:
			break;
		default:
			break;
	}


}


// Simple routine to substitute anchor variables by position.
P_BP_WEB_EXPLOIT_REQUEST_SET BP_GenWebExploitRequestSetBySubstitutingAnchorVar
(
		P_BP_HTML_ANCHOR_LIST                        anchor,
		BP_WEB_EXPLOIT_REQUEST_SET_VAR_LOOKUP        lookup_type,
		char *                                       lookup_name,
		size_t                                       lookup_index,
		char *                                       substitution_value,
		P_BP_LINKL                                   tq
)
{


	// ensure we have a tail queue allocator
	if(!tq)
		return NULL;

	// ensure we have an anchor
	if(!anchor)
		return NULL;

	// ensure we have anchor vars to search through
	if(!anchor->vars)
		return NULL;

	// create the string (always generate without tailqueue, it's destroyed below
	char * generated_string = HTMLGenerateAnchorSubstitutionString
	(
		anchor,
		anchor->vars,
		lookup_name,
		lookup_name,
		substitution_value,
		BP_FALSE,
		NULL
	);

	// exit if we can't generate the string
	if(!generated_string)
		return NULL;

	// generate the request set
	P_BP_WEB_EXPLOIT_REQUEST_SET req_set = NULL;
	if(tq)
	{
		req_set           = (P_BP_WEB_EXPLOIT_REQUEST_SET) tq_calloc(tq, sizeof(BP_WEB_EXPLOIT_REQUEST_SET), 1, BPLN);
		req_set->get_str  = tq_strdup(tq, generated_string, BPLN);
	}
	else
	{
		req_set           = (P_BP_WEB_EXPLOIT_REQUEST_SET) bpcalloc(sizeof(BP_WEB_EXPLOIT_REQUEST_SET), 1);
		req_set->get_str  = bpstrdup(generated_string);
	}

	// return the generated request set
	return req_set;

}





// generates an exploit request set from an anchor
P_BP_WEB_EXPLOIT_REQUEST_SET BP_GenWebExploitRequestSet(char *get_data, char *post_data)
{

	if(!get_data && !post_data)
	{
		printf("\n [+] Error.  Cannot generate request set due to 2 null parameters.  Returning null.");
		return NULL;
	}

	// create the exploit request set
	P_BP_WEB_EXPLOIT_REQUEST_SET ers = (P_BP_WEB_EXPLOIT_REQUEST_SET) bpcalloc(sizeof(BP_WEB_EXPLOIT_REQUEST_SET), 1);
	if(!ers)
		return NULL;

	// duplicate get and post data (bpstrdup ok!)
	if(get_data)
		ers->get_str  = bpstrdup(get_data);
	if(post_data)
		ers->post_str = bpstrdup(post_data);

	// return the exploit request set
	return ers;

}


// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%% Utility Routines %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



// Display exploit request set.
BP_ERROR_T BP_DisplayExploitRequestSet(P_BP_WEB_EXPLOIT_REQUEST_SET ers)
{

	if(!ers)
		return ERR_FAILURE;

	printf("\n [+] Exploit Request Set: %p", ers);
	printf("\n    get data:  %s", ers->get_str);
	printf("\n");
	printf("\n    post data: %s", ers->post_str);
	printf("\n  ");

	// return indicating success
	return ERR_SUCCESS;
}

// Run exploit request set.  Retry count the number of retries to
// retry a request in the case of a failedHTTPRequest.  If proxy subsystem
// is enabled, each retry will use a new proxy.
BP_ERROR_T BP_RunWebExploitRequestSet(P_BP_WEB_ASSESSMENT assessment, P_BP_WEB_EXPLOIT_REQUEST_SET ers, size_t retry_count)
{

	if(!ers)
		return ERR_FAILURE;
	if(!assessment)
		return ERR_FAILURE;
	if(!assessment->session)
		return ERR_FAILURE;


	// ###############################################################
	// ####### Check Assessment Request Blacklist First ##############
	// ###############################################################

	// reset blacklist toggle
	assessment->session->last_request_was_blacklisted = 0;

	// run blacklist check if set
	if(assessment->audit_blacklist)
	if(assessment->audit_blacklist[0])
	{

		// get the length of the blacklist
		size_t blacklist_len = BP_CountNullTerminatedPtrArray(assessment->audit_blacklist);

		// run the blacklist testing algorithm
		size_t blacklist_match_position = BP_StringMatchesBlacklistREGEXP(assessment->audit_blacklist, blacklist_len, ers->get_str);

		printf("\n [+] Request blacklist JIT testing: [p:%u], %s", blacklist_match_position, ers->get_str);

		// if blacklist matched position return err failure
		if(blacklist_match_position)
		{
			printf("\n [+] Request blacklist JIT matched and blocked: [p:%u], %s", blacklist_match_position, ers->get_str );
			assessment->session->last_request_was_blacklisted = 1;
			return ERR_FAILURE;
		}

	}


	// ###############################################################
	// ####### Check Assessment Request Whitelist Second #############
	// ###############################################################

	// reset whitelist toggle
	assessment->session->last_request_was_blacklisted = 0;

	// run blacklist check if set
	if(assessment->audit_whitelist)
	if(assessment->audit_whitelist[0])
	{


		// get the length of the whitelist
		size_t whitelist_len = BP_CountNullTerminatedPtrArray(assessment->audit_whitelist);

		// run the whitelist testing algorithm
		size_t whitelist_match_position = BP_StringMatchesBlacklistREGEXP(assessment->audit_whitelist, whitelist_len, ers->get_str);

		printf("\n [+] Request whitelist JIT testing: [p:%u], %s", whitelist_match_position, ers->get_str);

		// if blacklist matched position return err failure
		if(!whitelist_match_position)
		{
			printf("\n [+] Request whitelist JIT NOT matched and thereby disgarded: [p:%u], %s", whitelist_match_position, ers->get_str );
			assessment->session->last_request_was_blacklisted = 1;
			return ERR_FAILURE;
		}

	}

	// ###############################################################
	// ## Process Database Operations (Request Logging) ##############
	// ###############################################################

	// holds the http status code returned
	size_t http_status = 0;

	// holds an insert id if the record is inserted into the database successfully
	size_t insert_id = 0;

	// log the request if set
	if(assessment->db_log_mysql_session)
	{

		// log the exploit request set
		insert_id = BP_LogWebExploitRequestSetInDB(assessment->db_log_mysql_session, ers, assessment->db_result_id);
		if(insert_id)
		{

			// set the insert id
			assessment->db_http_last_request_made_id = insert_id;

			//  Uncommenting this causes a segfault, we need to find out why.  It causes a statement mismatch.
			/*
			http_status = BP_WebExploitationRequestSetCheckHTTPStatusForDBID(assessment->db_log_mysql_session, insert_id);
			if(http_status != 0)
			{
				printf("\n [!!] Failed to log exploit request set in the database (http_status was zero)");
				return ERR_FAILURE;
			}
			*/

		}
		else
		{
			printf("\n [!!] Failed to log exploit request set in the database (no insert_id was created)");
			return ERR_FAILURE;
		}

	}


	// ###############################################################
	// ####### Set GET/POST and Run Request ##########################
	// ###############################################################


	// set audit retry request iter to zero
	size_t audit_retry_request_iter = 0;

	// This is toggled off if a request fails.  Defaults to 1.
	size_t request_completed_successfully = 1;

	// set post data if it exists
	if(ers->post_str)
		BP_HTTPSetPostVars(assessment->session, ers->post_str);



	// attempt to make request using the session
	while(BP_HTTPRequest(assessment->session, ers->get_str) == ERR_FAILURE)
	{

		// exit if the request was blacklisted
		if(assessment->session->last_request_was_blacklisted)
			return ERR_FAILURE;

		// get the http status code returned from the server
		curl_easy_getinfo(assessment->session->curl, CURLINFO_RESPONSE_CODE, (long *) &ers->http_response_code);

		// if logging is turned on, update the status code if its not 0
		if(ers->http_response_code)
		if(assessment->db_log_mysql_session)
		{
			BP_WebExploitationRequestUpdateHTTPStatus(assessment->db_log_mysql_session, insert_id, ers->http_response_code, 0);
		}

		// check the http response code
		if(ers->http_response_code >= 500 && ers->http_response_code < 600)
		{
			printf("\n [+] Internal server error on exploit set (directly follows):");
			BP_DisplayExploitRequestSet(ers);
			break;
		}
		if(ers->http_response_code >= 300 && ers->http_response_code < 400)
		{
			// printf("\n Got 200 status code.");
			break;
		}
		// check for good pages with 0 lengths
		if(ers->http_response_code >= 200 && ers->http_response_code < 300)
		{
			// printf("\n Got 200 status code.");
			break;
		}

		// increment requests
		audit_retry_request_iter++;

		//  run a check and exit in the case that the request simply will not run
		if(audit_retry_request_iter > retry_count)
		{
			// display error message
			printf("\n [+] Exploit request limit exceeded.  Most likely bad request.");
			return ERR_FAILURE;

		}

	}

	// get the http status code returned from the server
	curl_easy_getinfo(assessment->session->curl, CURLINFO_RESPONSE_CODE, (long *) &ers->http_response_code);

	// if logging is turned on, update the status code if its not 0
	if(ers->http_response_code)
	if(assessment->db_log_mysql_session)
	{
		BP_WebExploitationRequestUpdateHTTPStatus(assessment->db_log_mysql_session, insert_id, ers->http_response_code, 0);
	}

	// check the http response code
	if(ers->http_response_code >= 400 && ers->http_response_code < 500)
	{

		// 400 is valid, we shouldn't exit failure here, as we could find
		// errors in 400 pages.
		// return ERR_FAILURE;

	}

	// check the http response code
	if(ers->http_response_code >= 500 && ers->http_response_code < 600)
	{
		printf("\n [+] Internal server error on exploit set (directly follows):");
		BP_DisplayExploitRequestSet(ers);
	}

	if(ers->http_response_code >= 300 && ers->http_response_code < 400)
	{
		// printf("\n [+] Page relocation (status 300 request NOT FOLLOWED.");
	}

	// check for good pages with 0 lengths
	if(ers->http_response_code >= 200 && ers->http_response_code < 300)
	{
		// printf("\n Got 200 status code.");
	}

	// return indicating success
	return ERR_SUCCESS;

}


// logs an exploit request set
size_t BP_LogWebExploitRequestSetInDB(P_BP_MYSQL_SESSION db_handle, P_BP_WEB_EXPLOIT_REQUEST_SET ers, size_t result_linking_id)
{

	// ensure we have a database handle
	if(!db_handle)
		return 0;

	// enter critical section
	BP_HASH_TABLE_ENTER_CRITICAL_SECTION(db_handle->system_hreg);

	// lock the semaphore before attempting any logging capacity (prevents
	// thread contention issues)
	BP_MySQLSemLock(db_handle);


	// close statement if one already exists
	if(db_handle->stmt)
	{
		db_handle->stmt = NULL;

	}

	// reset last insert id to 0
	MYSQL_STMT * stmt = BP_MySQLPrepareQuery(db_handle, "select last_insert_id(0);");
	if(!stmt)
	{

		// display debugging message
	    printf("\n [+] Failed to prepare MySQL statement in BP_LogWebExploitRequestSetInDB: %s", mysql_error(db_handle->conn));

	    // unlock the handle
	    BP_MySQLSemUnlock(db_handle);

	    // leave the critical section and return
		BP_HASH_TABLE_LEAVE_CRITICAL_SECTION_AND_RETURN_FROM_FUNC(db_handle->system_hreg, ERR_FAILURE);

	}

	// execute query
    if(!BP_MySQLExecuteStatement(stmt, db_handle))
    {

       printf("\n [+] Statement failed to execute in BP_LogWebExploitRequestSetInDB: %p -  %s", stmt,  mysql_error(db_handle->conn));
       BP_MySQLSemUnlock(db_handle);

       // leave the critical section and return
       BP_HASH_TABLE_LEAVE_CRITICAL_SECTION_AND_RETURN_FROM_FUNC(db_handle->system_hreg, ERR_FAILURE);

    }

    // destroy statement
    BP_MySQLCloseStatement(stmt, db_handle);



    // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    // %%% Prepare Insert Query %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	// prepare insert query
	stmt = BP_MySQLPrepareQuery
	(
			db_handle,
			"INSERT IGNORE INTO `http_request_log` "\
			"("\
			"	`request_unique_sha1`, "\
			"	`result_id`, "\
			"	`http_status_code`, "\
			"	`http_get_string`, "\
			"	`http_post_string`, "\
			"	`http_cookie`"\
			") "\
			"VALUES "\
			"("\
			"	?, "\
			"	?, "\
			"	?, "\
			"	?, "\
			"	?, "\
			"	?"\
			");"
	);

	// ensure the statement was prepared
	if(!stmt)
	{
		printf("\n [+] Could not prepare statement in BP_LogWebExploitRequestSetInDB.");
		BP_MySQLSemUnlock(db_handle);

		// leave the critical section and return
		BP_HASH_TABLE_LEAVE_CRITICAL_SECTION_AND_RETURN_FROM_FUNC(db_handle->system_hreg, ERR_FAILURE);

    }

	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	// %%% Attempt to Bind Parameters to Statement %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


	// destroy this at exit
	MYSQL_BIND * params = (MYSQL_BIND *) bpcalloc(sizeof(MYSQL_BIND)*8, 1);

	// set default request variables
	char * request_unique_sha1 = " ";
	size_t result_id           = result_linking_id;
	size_t http_code           = ers->http_response_code;
	char *http_get_string      = " ";
	char *http_post_string     = " ";
	char *http_cookie          = " ";

	// if no sha1 hash
	if(ers->sha1_hash)
		request_unique_sha1 = ers->sha1_hash;
	if(ers->http_response_code)
		http_code = ers->http_response_code;
	if(ers->get_str)
		http_get_string = ers->get_str;
	if(ers->post_str)
		http_post_string = ers->post_str;
	if(ers->cookie_str)
		http_cookie = ers->cookie_str;

	// create argument stack for generating sha1 from strings (hashes are combinations
	// of strings in the array.

	// allocate sha1 stack
	char ** sha1_gen_stack = (char **) bpcalloc(sizeof(char*) * 4, 1);

	// set empty (non-null strings)
	sha1_gen_stack[0] = "";
	sha1_gen_stack[1] = "";
	sha1_gen_stack[2] = "";

	if(ers->get_str)
		sha1_gen_stack[0] = ers->get_str;
	if(ers->post_str)
		sha1_gen_stack[1] = ers->post_str;
	if(ers->cookie_str)
		sha1_gen_stack[2] = ers->cookie_str;

	// generate sha1 from the stack
	char * calculated_hash = BP_GenSHA1FromStringArray(sha1_gen_stack);
	if(sha1_gen_stack)
		bpfree(sha1_gen_stack);

	// name parameter
	params[0].buffer_type= MYSQL_TYPE_STRING;
	params[0].buffer= (char *) calculated_hash;
	params[0].buffer_length = bpstrlen(calculated_hash);

	// add request linking id
	params[1].buffer_type   = MYSQL_TYPE_LONG;
	params[1].buffer        = (char *) &result_id;
	params[1].buffer_length = sizeof(result_id);

	// set request code
	params[2].buffer_type= MYSQL_TYPE_LONG;
	params[2].buffer= (char *) &http_code;
	params[2].buffer_length = sizeof(http_code);

	// set http get data
	params[3].buffer_type= MYSQL_TYPE_STRING;
	params[3].buffer= (char *) http_get_string;
	params[3].buffer_length = bpstrlen(http_get_string);

	// set http post data
	params[4].buffer_type= MYSQL_TYPE_STRING;
	params[4].buffer= (char *) http_post_string;
	params[4].buffer_length = bpstrlen(http_post_string);

	// set http cookie
	params[5].buffer_type= MYSQL_TYPE_STRING;
	params[5].buffer= (char *) http_cookie;
	params[5].buffer_length = bpstrlen(http_cookie);

	// bind parameters
	if(!BP_MySQLBindParameters(stmt, params, db_handle))
	{

		// display message indicating the parameters have vailed to bind
		printf("\n [+] Bind parameters failed in BP_LogWebExploitRequestSetInDB.");

		// leave the critical section and return
		BP_MySQLSemUnlock(db_handle);
		BP_HASH_TABLE_LEAVE_CRITICAL_SECTION_AND_RETURN_FROM_FUNC(db_handle->system_hreg, ERR_FAILURE);

	}

    // execute query
    if(!BP_MySQLExecuteStatement(stmt, db_handle))
    {

       printf("\n [+] Statement failed to execute in BP_LogWebExploitRequestSetInDB.");
       BP_MySQLSemUnlock(db_handle);

       // leave the critical section and return
       BP_HASH_TABLE_LEAVE_CRITICAL_SECTION_AND_RETURN_FROM_FUNC(db_handle->system_hreg, ERR_FAILURE);

    }

    // display last insert id
    int last_insert_id = BP_MySQLLastInsertId(stmt);

    // destroy statement
    BP_MySQLCloseStatement(stmt, db_handle);
    stmt = NULL;

	// destroy the calculated sha1 hash
	bpfree(calculated_hash);

	// destroy mysql parameters structure
	bpfree(params);

	// if the insert id is > 0 we're good to go
	if(last_insert_id > 0)
	{

		// unlock the handle
		BP_MySQLSemUnlock(db_handle);

		// leave the critical section and return
		BP_HASH_TABLE_LEAVE_CRITICAL_SECTION_AND_RETURN_FROM_FUNC(db_handle->system_hreg, last_insert_id);

	}

	// return indicating failure (duplicate)
	BP_MySQLSemUnlock(db_handle);

	// leave the critical section and return failure
	BP_HASH_TABLE_LEAVE_CRITICAL_SECTION_AND_RETURN_FROM_FUNC(db_handle->system_hreg, ERR_FAILURE);


}

// runs a select query against a given id and checks for
// the current http status of the request.
size_t BP_WebExploitationRequestSetCheckHTTPStatusForDBID(P_BP_MYSQL_SESSION db_handle, size_t db_id)
{

	// ensure we have a handle and a registry
	if(!db_handle)
		return ERR_FAILURE;
	if(!db_handle->system_hreg)
		return ERR_FAILURE;

	// enter critical section
	BP_HASH_TABLE_ENTER_CRITICAL_SECTION(db_handle->system_hreg);

	// lock the semaphore before attempting any logging capacity (prevents
	// thread contention issues)
	BP_MySQLSemLock(db_handle);

	// prepare new sql
	MYSQL_STMT * stmt = BP_MySQLPrepareQuery(db_handle, "SELECT http_status_code FROM http_request_log WHERE id = ? LIMIT 0,1;");
	if(!stmt)
	{

		// debug message
		printf("\n [+] Could not prepare statement in BP_WebExploitationRequestSetCheckHTTPStatusForDBID.");

		// unlock table
		BP_MySQLSemUnlock(db_handle);

		// leave the critical section and return
		BP_HASH_TABLE_LEAVE_CRITICAL_SECTION_AND_RETURN_FROM_FUNC(db_handle->system_hreg, ERR_FAILURE);

	}

	// allocate space for parameters
	MYSQL_BIND * params = (MYSQL_BIND *) bpcalloc(sizeof(MYSQL_BIND)*4, 1);

	// set index return parameter
	params[0].buffer_type= MYSQL_TYPE_LONG;
	params[0].buffer = (char *) & db_id;
	params[0].is_null= 0;
	params[0].length = 0;

	// bind parameters
	if(BP_MySQLBindParameters(stmt, params, db_handle) == ERR_FAILURE)
	{

		// display debug message
		printf("\n [+] Bind parameters failed in BP_WebExploitationRequestSetCheckHTTPStatusForDBID.");

		// unlock the handle
		BP_MySQLSemUnlock(db_handle);

		// leave the critical section and return
		BP_HASH_TABLE_LEAVE_CRITICAL_SECTION_AND_RETURN_FROM_FUNC(db_handle->system_hreg, ERR_FAILURE);

	}

	// execute query
	if(BP_MySQLExecuteStatement(stmt, db_handle) == ERR_FAILURE)
	{
		printf("\n [+] Statement failed to execute in BP_WebExploitationRequestSetCheckHTTPStatusForDBID.");
		BP_MySQLSemUnlock(db_handle);
		BP_HASH_TABLE_LEAVE_CRITICAL_SECTION_AND_RETURN_FROM_FUNC(db_handle->system_hreg, ERR_FAILURE);
	}

	// 1 columns
	MYSQL_BIND * result = (MYSQL_BIND *) bpcalloc(sizeof(MYSQL_BIND)*2, 1);

	// set local variables
	size_t index = 0;


	// index
	result[0].buffer_type = MYSQL_TYPE_LONG;
	// result[0].buffer      = (char *)&index;
	// result[0].is_null     = &is_null[0];
	// result[0].length      = (unsigned long *) &length[0];
	// result[0].error       = &error[0];

	// bind results
	if(BP_MySQLBindResult(stmt, result, 1, db_handle) == ERR_FAILURE)
	{
		printf("\n [+] Unable to bind parameters in BP_WebExploitationRequestSetCheckHTTPStatusForDBID");
		BP_MySQLSemUnlock(db_handle);
		BP_HASH_TABLE_LEAVE_CRITICAL_SECTION_AND_RETURN_FROM_FUNC(db_handle->system_hreg, ERR_FAILURE);
	}

	if(BP_MySQLStoreResults(stmt, db_handle) == ERR_FAILURE)
	{
		printf("\n [+] Unable to store result");
		BP_MySQLSemUnlock(db_handle);
		BP_HASH_TABLE_LEAVE_CRITICAL_SECTION_AND_RETURN_FROM_FUNC(db_handle->system_hreg, ERR_FAILURE);
	}


	size_t i;
	size_t *indexr = NULL;

	// attempt to fetch result
	if(!BP_MySQLFetchResult(stmt, db_handle))
		BP_HASH_TABLE_LEAVE_CRITICAL_SECTION_AND_RETURN_FROM_FUNC(db_handle->system_hreg, ERR_FAILURE);

	indexr = (size_t *) result[0].buffer;
	size_t ret_index = *indexr;

	// destroy statement
	BP_MySQLCloseStatement(stmt, db_handle);
	stmt = NULL;

	// destroy if necessary
	if(params)
		bpfree(params);
	if(result)
		bpfree(result);

	// unlock
	BP_MySQLSemUnlock(db_handle);

	// return the found index
	BP_HASH_TABLE_LEAVE_CRITICAL_SECTION_AND_RETURN_FROM_FUNC(db_handle->system_hreg, ret_index);

}


// updates the database with http return/connect status set
size_t BP_WebExploitationRequestUpdateHTTPStatus(P_BP_MYSQL_SESSION db_handle, size_t record_id, size_t http_status, size_t http_connect_status)
{

	// ensure we have a handle
	if(!db_handle)
		return ERR_FAILURE;
	if(!db_handle->system_hreg)
		return ERR_FAILURE;

	// lock the critical section
	BP_HASH_TABLE_ENTER_CRITICAL_SECTION(db_handle->system_hreg);

	// lock mysql semaphore
	BP_MySQLSemLock(db_handle);

	 // prepare new sql
	 MYSQL_STMT * stmt = BP_MySQLPrepareQuery(db_handle, "UPDATE http_request_log SET http_status_code = ?, http_connect_code = ? WHERE id = ?");
	 if(!stmt)
	 {
		 printf("\n [+] Could not prepare statement in BP_WebExploitationRequestUpdateHTTPStatus.");
		 BP_MySQLSemUnlock(db_handle);
		 BP_HASH_TABLE_LEAVE_CRITICAL_SECTION_AND_RETURN_FROM_FUNC(db_handle->system_hreg, ERR_FAILURE);
	 }

	 // allocate space for parameters
	 MYSQL_BIND * params = (MYSQL_BIND *) bpcalloc(sizeof(MYSQL_BIND)*4, 1);

	 // set http status parameter
	 params[0].buffer_type= MYSQL_TYPE_LONG;
	 params[0].buffer = (char *) & http_status;
	 params[0].is_null= 0;
	 params[0].length = 0;

	 params[1].buffer_type= MYSQL_TYPE_LONG;
	 params[1].buffer = (char *) & http_connect_status;
	 params[1].is_null= 0;
	 params[1].length = 0;

	 params[2].buffer_type= MYSQL_TYPE_LONG;
	 params[2].buffer = (char *) & record_id;
	 params[2].is_null= 0;
	 params[2].length = 0;

    // bind parameters
    if(BP_MySQLBindParameters(stmt, params, db_handle) == ERR_FAILURE)
    {
    	printf("\n [+] Bind parameters failed.");
    	BP_MySQLSemUnlock(db_handle);
    	BP_HASH_TABLE_LEAVE_CRITICAL_SECTION_AND_RETURN_FROM_FUNC(db_handle->system_hreg, ERR_FAILURE);
    }

    // execute query
    if(BP_MySQLExecuteStatement(stmt, db_handle) == ERR_FAILURE)
    {
    	printf("\n [+] Statement failed to execute in BP_WebExploitationRequestUpdateHTTPStatus.");
    	BP_MySQLSemUnlock(db_handle);
    	BP_HASH_TABLE_LEAVE_CRITICAL_SECTION_AND_RETURN_FROM_FUNC(db_handle->system_hreg, ERR_FAILURE);
    }

    // destroy statement
	BP_MySQLCloseStatement(stmt, db_handle);

	// destroy parameters if necessary
	if(params)
		bpfree(params);

	// unlock
	BP_MySQLSemUnlock(db_handle);

	// return the found index
	BP_HASH_TABLE_LEAVE_CRITICAL_SECTION_AND_RETURN_FROM_FUNC(db_handle->system_hreg, ERR_SUCCESS);

}


// generates an exploit request set from an anchor
BP_ERROR_T BP_DestroyWebExploitRequestSet(P_BP_WEB_EXPLOIT_REQUEST_SET ers)
{
	if(!ers)
		return ERR_FAILURE;

	if(ers->get_str)
	{
		bpfree(ers->get_str);
		ers->get_str = NULL;
	}
	if(ers->post_str)
	{
		bpfree(ers->post_str);
		ers->post_str = NULL;
	}

	bpfree(ers);


	// return indicating success
	return ERR_SUCCESS;

}
