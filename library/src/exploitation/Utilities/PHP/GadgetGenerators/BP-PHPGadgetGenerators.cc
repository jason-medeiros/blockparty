#include "../../../../../include/BP-Main.h"



// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%% Gadget Library Routines %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

// builds a gadget library from the existing library gadgets
P_BP_PHP_GADGET_LIBRARY BP_PHPOpenGadgetLibrary()
{

	// allocate space for gadget library
	P_BP_PHP_GADGET_LIBRARY gadget_lib_session = (P_BP_PHP_GADGET_LIBRARY) bpcalloc(sizeof(BP_PHP_GADGET_LIBRARY), 1);

	// create new thread safe tail queue allocator for use with or library
	gadget_lib_session->tq = BP_CreateLinkL("PHP Gadget Library Session", BP_TRUE);

	// return the new gadget library
	return gadget_lib_session;

}

// destroys a open PHP gadget library
BP_ERROR_T BP_PHPCloseDestroyGadgetLibrary(P_BP_PHP_GADGET_LIBRARY gadget_lib)
{

	// check to ensure we have a pointer
	if(!gadget_lib)
		return ERR_FAILURE;

	// destroy gadget runtime tailqueue allocators
	size_t n = 0;
	if(gadget_lib->gadget_n)
	{
		for(n=0; n< gadget_lib->gadget_n; n++)
		{

			if(gadget_lib->gadgets[n].runtime_tq)
			{
				BP_DestroyLinkL(gadget_lib->gadgets[n].runtime_tq, BP_TRUE);

			}

		}

	}

	// destroy all dangling chunks in the tail queue allocator
	BP_DestroyLinkL(gadget_lib->tq, BP_TRUE);

	// destroy structure itself
	bpfree(gadget_lib);

	// return indicating success
	return ERR_SUCCESS;

}


// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%% Gadget Related Routines %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

// linear search through php gadgets to search by string.  String searching
// should be pretty fast.
P_BP_PHP_GADGET BP_PHPGadgetSearchByString
(
		P_BP_PHP_GADGET_LIBRARY gadget_lib,
		char *uuid,
		char *name,
		char *description
)
{

	// ensure we have a gadget library containing gadgets
	if(!gadget_lib)
		return NULL;
	if(!gadget_lib->gadget_n)
		return NULL;

	// set uuid max to standard 32bytes + 4 separators
	size_t uuid_max_n = 36;

	// calculate uuid string length
	size_t uuid_len = 0;

	// these are set directly below
	P_BP_PHP_GADGET uuid_match        = NULL;
	P_BP_PHP_GADGET name_match        = NULL;
	P_BP_PHP_GADGET description_match = NULL;

	// linear iterator
	size_t n = 0;

	// =================================================================

	// search for uuid first
	if(uuid)
	{

		// ensure that the uuid supplied is the correct length, if not exit
		// the if logic.
		if(strnlen(uuid, uuid_max_n+1) == uuid_max_n)
		{

			for(n=0; n < gadget_lib->gadget_n; n++)
			{

				// run uuid comparison, return value if we have a match
				if(memcmp(gadget_lib->gadgets[n].uuid, uuid, uuid_max_n) == 0)
				{

					if(!name && !description)
					{
						return &gadget_lib->gadgets[n];
					}
					else
					{
						uuid_match = &gadget_lib->gadgets[n];
						break;
					}

				}

			}

		}
		else
			return NULL;
	}

	// if we did not find a match, and we were supposed to, exit here.
	if(!uuid_match && uuid)
	{
		return NULL;
	}


	// =====================================================

	// name search
	// search for uuid first
	if(name)
	{

		// calculate name length
		size_t name_len = strnlen(name, 512);

		// walk gadgets
		for(n=0; n < gadget_lib->gadget_n; n++)
		{

			// do numeric length check before doing actual compare
			if(bpstrlen(gadget_lib->gadgets[n].name) == name_len)
			{

				printf("\n\n");

				// run compare
				if(memcmp(gadget_lib->gadgets[n].name, name, name_len) == 0)
				{

					// check return conditions and return the gadget if either
					// check succeds.
					if(!description && (&gadget_lib->gadgets[n] == uuid_match))
						return &gadget_lib->gadgets[n];
					else if(!description && !uuid)
						return &gadget_lib->gadgets[n];

					// if the return checks fail, set value and continue on to
					// description matching.
					name_match = &gadget_lib->gadgets[n];

				}

			}

		}

	}

	// Check match pointers and exit if both are set.
	if(uuid_match && name_match)
	if(uuid_match != name_match)
		return NULL;

	// =====================================================

	// description search
	if(description)
	{

		// calculate description length
		size_t description_len = strnlen(description, 1024);

		for(n=0; n < gadget_lib->gadget_n; n++)
		{

			// do numeric length check before doing actual compare
			if(bpstrlen(gadget_lib->gadgets[n].description) == description_len)
			{

				// run comparison
				if(memcmp(gadget_lib->gadgets[n].description, description, description_len) == 0)
				{
					description_match = &gadget_lib->gadgets[n];
					break;
				}

			}

		}

	}

	// see if everything matches up return immediately
	if(description_match && name_match && uuid_match)
	if(description_match == name_match)
	if(name_match == uuid_match)
	{
		return uuid_match;
	}

	// return null if we are unable to find the gadget we searched for
	return NULL;

}

// PHP gadget run time arguments are added during gadget definition.  They
// can be set directly by using this function.
BP_ERROR_T BP_PHPGadgetSetRuntimeArgument
(
	P_BP_PHP_GADGET        gadget,
	char                   *arg_php_symbol,
	unsigned char          *arg,
	size_t                 arg_size
)
{

	// check php gadget
	if(!gadget)
		return ERR_FAILURE;

	// ensure gadget has parameters
	if(!gadget->arguments_n)
		return ERR_FAILURE;

	// check parameters for nulls
	if(	!arg_php_symbol || !arg || !arg_size )
		return ERR_FAILURE;

	// calculate symbol length
	size_t sym_len = strnlen(arg_php_symbol, 512);

	// the gadget should already have a tail queue allocator set, if
	// for whatever reason, it is unset -- set it here.
	if(!gadget->runtime_tq)
	{
		gadget->runtime_tq = BP_CreateLinkL("PHP Gadget Runtime Allocator", BP_TRUE);
	}

	// linear check to see if we can find the argument in the gadget required
	// arguments list.
	size_t n = 0;
	for(; n < gadget->arguments_n; n++)
	{

		// check that the argument has a valid symbol pointer
		if(gadget->arguments[n].arg_php_symbol)
		{

			// calculate symbol length
			size_t arg_sym_len = bpstrlen(gadget->arguments[n].arg_php_symbol);

			// compare length to symbol length and continue if they are
			// not matching.
			if(arg_sym_len != sym_len)
				continue;

			// compare to see if symbol matches up
			if(memcmp(arg_php_symbol, gadget->arguments[n].arg_php_symbol, arg_sym_len) != 0)
				continue;

			// if the argument is already set, free it
			if(gadget->arguments[n].arg)
				tq_free(gadget->runtime_tq, gadget->arguments[n].arg);

			// copy data into argument
			gadget->arguments[n].arg = (unsigned char *) tq_calloc(gadget->runtime_tq, arg_size+1, 1, BPLN);

			// copy data into place
			memcpy(gadget->arguments[n].arg, arg, arg_size);

			// set argument size
			gadget->arguments[n].size = arg_size;

			// set flag indicating that values have been set for this argument
			gadget->arguments[n].arg_has_been_set = BP_TRUE;

			// since the argument has been set, we can now return
			return ERR_SUCCESS;

		}

	}

	// return indicating success
	return ERR_SUCCESS;

}


// Adds arguments to a gadget.  Max php symbol length set to 256 bytes.
BP_ERROR_T BP_PHPGadgetAddRuntimeArgument
(
		P_BP_PHP_GADGET        gadget,
		BP_GADGET_ARG_TYPE     type,
		char                   *arg_php_symbol
)
{

	if(!gadget)
		return ERR_FAILURE;
	if(!type)
		return ERR_FAILURE;
	if(!arg_php_symbol)
		return ERR_FAILURE;

	// create runtime tail queue allocator if unset
	if(!gadget->runtime_tq)
	{
		gadget->runtime_tq = BP_CreateLinkL("PHP Gadget Runtime Allocator", BP_TRUE);
	}

	// set runtime allocator for ease of use
	P_BP_LINKL tq = gadget->runtime_tq;

	// create space for arguments
	gadget->arguments = (P_BP_PHP_GADGET_ARG) tq_realloc(tq, gadget->arguments, sizeof(BP_PHP_GADGET_ARG) * (gadget->arguments_n+1), BPLN);
	if(!gadget->arguments)
		return ERR_FAILURE;

	// initialize memory as 0x00, this is to make valgrind shut up about uninitialized
	// data.
	memset(&gadget->arguments[gadget->arguments_n], 0x00, sizeof(BP_PHP_GADGET_ARG));

	// set php symbol by using strndup
	gadget->arguments[gadget->arguments_n].arg_php_symbol = (char *) tq_strndup(tq, arg_php_symbol, 256, BPLN);

	// mark gadget as required (default)
	gadget->arguments[gadget->arguments_n].arg_required_for_run = BP_TRUE;

	// set gadget data type
	gadget->arguments[gadget->arguments_n].type = type;

	// set flag indicating that the argument has been set
	gadget->arguments[gadget->arguments_n].arg_has_been_set = BP_FALSE;

	// increment the gadget count
	gadget->arguments_n++;

	// return failure if we were unable to build the argument
	return ERR_SUCCESS;

}


// generates a gadget suitable for sending towards stage 2 interpreter for decode/execution
P_BP_PHP_GADGET BP_PHPGenerateGadget(char * gadget_text, char *encryption_key)
{
	return NULL;
}

// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%% Gadget Preprocessor %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

// The gadget preprocessor generates runtime substitutions based on the
// defined argument configuration of the gadget supplied.  This includes
// creating random elements as necessary.
BP_ERROR_T BP_PHPGadgetPreprocessor(P_BP_PHP_GADGET gadget)
{

	// ensure we have a gadget
	if(!gadget)
		return ERR_FAILURE;

	// ensure gadget has a tail queue allocator
	if(!gadget->runtime_tq)
	{
		gadget->runtime_tq = BP_CreateLinkL("PHP Gadget Runtime Allocator", BP_TRUE);
	}

	// find and replace strings
	char ** find_strs     = NULL;
	size_t find_strs_n    = 0;

	// set the replace strings
	char ** replace_strs  = NULL;
	size_t replace_strs_n = 0;

	// create link list
	P_BP_LINKL tmp_tq = BP_CreateLinkL("tmp", BP_TRUE);

	// set encoded argument value
	char * encoded_argument = NULL;

	// types for unsigned values
	uint64_t uint64_data = 0;
	uint32_t uint32_data = 0;
	uint16_t uint16_data = 0;
	uint8_t  uint8_data  = 0;

	// types for signed values
	int64_t int64_data = 0;
	int32_t int32_data = 0;
	int16_t int16_data = 0;
	int8_t  int8_data  = 0;


	// walk the arguments and generate substitution strings
	size_t n = 0;
	for(; n < gadget->arguments_n; n++)
	{

		switch(gadget->arguments[n].type)
		{

			// encode char/uchars the same
			case BP_GADGET_ARG_TYPE_CHAR_STRING:
			case BP_GADGET_ARG_TYPE_UCHAR_STRING:
				encoded_argument = BP_GenPHPGadgetEncodeBufferAsRandomEncode(gadget->arguments[n].arg, gadget->arguments[n].size, NULL);
				break;

			case BP_GADGET_ARG_TYPE_UINT64:

				// ensure the parameter is the correct size
				if(gadget->arguments[n].size != sizeof(uint64_t))
					break;

				// set the uint64 data from the buffer
				uint64_data = (uint64_t) *gadget->arguments[n].arg;
				encoded_argument = BP_UInt64ToASCII(uint64_data, BP_NUMERIC_STRING_CONVERSIONS_RANDOM_STANDARD_OR_0xHEX_CONVERSION);

				break;
			case BP_GADGET_ARG_TYPE_UINT32:
				// set the uint32 data from the buffer
				uint32_data = (uint32_t) *gadget->arguments[n].arg;
				encoded_argument = BP_UInt32ToASCII(uint32_data, BP_NUMERIC_STRING_CONVERSIONS_RANDOM_STANDARD_OR_0xHEX_CONVERSION);
				break;

			case BP_GADGET_ARG_TYPE_UINT16:
				// set the uint32 data from the buffer
				uint16_data = (uint16_t) *gadget->arguments[n].arg;
				encoded_argument = BP_UInt16ToASCII(uint16_data, BP_NUMERIC_STRING_CONVERSIONS_RANDOM_STANDARD_OR_0xHEX_CONVERSION);
				break;

			case BP_GADGET_ARG_TYPE_UINT8:
				// set the uint8 data from the buffer
				uint8_data = (uint8_t) *gadget->arguments[n].arg;
				encoded_argument = BP_UInt8ToASCII(uint8_data, BP_NUMERIC_STRING_CONVERSIONS_RANDOM_STANDARD_OR_0xHEX_CONVERSION);
				break;

			case BP_GADGET_ARG_TYPE_INT64:
				// set the int64 data from the buffer
				int64_data = (int64_t) *gadget->arguments[n].arg;
				encoded_argument = BP_Int64ToASCII(int64_data, BP_NUMERIC_STRING_CONVERSIONS_RANDOM_STANDARD_OR_0xHEX_CONVERSION);
				break;
			case BP_GADGET_ARG_TYPE_INT32:
				// set the int32 data from the buffer
				int64_data = (int32_t) *gadget->arguments[n].arg;
				encoded_argument = BP_Int32ToASCII(int32_data, BP_NUMERIC_STRING_CONVERSIONS_RANDOM_STANDARD_OR_0xHEX_CONVERSION);
				break;
			case BP_GADGET_ARG_TYPE_INT16:
				// set the int32 data from the buffer
				int16_data = (int16_t) *gadget->arguments[n].arg;
				encoded_argument = BP_Int16ToASCII(int16_data, BP_NUMERIC_STRING_CONVERSIONS_RANDOM_STANDARD_OR_0xHEX_CONVERSION);
				break;
			case BP_GADGET_ARG_TYPE_INT8:
				// set the int32 data from the buffer
				int8_data = (int8_t) *gadget->arguments[n].arg;
				encoded_argument = BP_Int8ToASCII(int8_data, BP_NUMERIC_STRING_CONVERSIONS_RANDOM_STANDARD_OR_0xHEX_CONVERSION);
				break;

			// default means we have a bad or unmatched type
			default:
				break;

			// BP_GenHexStringFromBuffer()

		}

		// ensure that we have created an encoded argument
		if(!encoded_argument)
			return ERR_FAILURE;

		// add symbol as find string (updates via reference_
		BP_ArrayPushDupStringTQ(tmp_tq, gadget->arguments[n].arg_php_symbol, &find_strs,  &find_strs_n);

		// add encoded argument as replacement string (updates via reference)
		BP_ArrayPushDupStringTQ(tmp_tq, encoded_argument, &replace_strs,  &replace_strs_n);

		// destroy the argument and nullify on loop
		bpfree(encoded_argument);
		encoded_argument = NULL;

	}

	// run substitutions
	char * sub_template = BP_GenerateSubstitutedTemplate(gadget->gadget_fmt, find_strs, replace_strs);

	printf("\n template: %s", sub_template);

	// set the prepared gadget
	gadget->prepared_gadget = sub_template;

	// link in the substituted template
	tq_link(gadget->runtime_tq, gadget->prepared_gadget, bpstrlen(gadget->prepared_gadget), BPLN);


	// destroy the temporary linkl
	BP_DestroyLinkL(tmp_tq, BP_TRUE);


	// perform substitutions
	// gadget->gadget_fmt

	// return indicating success
	return ERR_SUCCESS;

}

// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%% Display Routines %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

// displays a php gadget library
BP_ERROR_T BP_DisplayPHPGadgetLibrary(P_BP_PHP_GADGET_LIBRARY open_gadget_lib, size_t display_gadgets)
{

	if(!open_gadget_lib)
		return ERR_FAILURE;

	// display the php gadget library
	printf("\n [+] PHP Gadget Library: %p", open_gadget_lib);
	printf("\n Gadgets Pointer:        %p",   open_gadget_lib->gadgets);
	printf("\n Total Gadgets in Lib:   %u", open_gadget_lib->gadget_n);
	printf("\n");

	// display gadgets if set
	if(display_gadgets != BP_FALSE)
	{
		printf("\n [+] PHP Gadgets: %p", open_gadget_lib);
		size_t n = 0;
		for(; n < open_gadget_lib->gadget_n; n++)
		{
			BP_DisplayPHPGadget(&open_gadget_lib->gadgets[n]);
		}
	}

	// return
	return ERR_SUCCESS;
}

// gadget display routine
BP_ERROR_T BP_DisplayPHPGadget(P_BP_PHP_GADGET gadget)
{

	// ensure we have a gadget to display
	if(!gadget)
		return ERR_FAILURE;

	// create a linkl for displaying items
	P_BP_LINKL tq = BP_CreateLinkL("display linkl", BP_TRUE);
	printf("\n");

	// display individual gadget
	printf("\n\t =========================================================");
	printf("\n\t [+] Gadget: (%p) %s", gadget, gadget->name);
	printf("\n");

	// display gadget strings
	printf("\n\t\t uuid:         %s", gadget->uuid);
	printf("\n\t\t name:         %s", gadget->name);
	printf("\n\t\t description:  %s", gadget->description);
	printf("\n\t\t read key:     %s", gadget->read_key ? gadget->read_key : "Key Unset");
	printf("\n\t\t write key:    %s", gadget->write_key ? gadget->write_key : "Key Unset");

	// display type and category
	printf("\n\t\t type:     %s", BP_GetGadgetType(gadget->type, tq));
	printf("\n\t\t category: %s", BP_GetGadgetCategory(gadget->category, tq));

	// common iterator for stacked items
	size_t n = 0;

	// display supported software languages
	if(gadget->langs_n)
	{
		printf("\n");
		printf("\n\t\t [+] Supported Software Languages:");
		for(n=0; n < gadget->langs_n; n++)
		{
			printf("\n\t\t\t [%u]:  %s",n, BP_GetSoftwareLanguage(gadget->langs[n], tq));
		}
	}

	// display supported hardware platforms
	if(gadget->hw_platforms_n)
	{
		printf("\n");
		printf("\n\t\t [+] Supported Hardware Platforms:");
		for(n=0; n < gadget->hw_platforms_n; n++)
		{
			printf("\n\t\t\t [%u]:  %s",n, BP_GetHWPlatform((BP_GADGET_HW_PLATFORM) gadget->hw_platforms[n], tq));
		}
	}

	// display supported os targets
	if(gadget->os_targets_n)
	{
		printf("\n");
		printf("\n\t\t [+] Supported OS Targets:");
		for(n=0; n < gadget->os_targets_n; n++)
		{
			printf("\n\t\t\t [%u]:  %s",n, BP_GetOSTarget((BP_GADGET_OS_TARGET) gadget->os_targets[n], tq));
		}
	}

	// display the actual format string (actual code)
	printf("\n");
	printf("\n\t\t [+] gadget fmt: \n\t\t%s", gadget->gadget_fmt);

	// display the preprocessed gadget if it exists
	printf("\n");
	printf("\n\t\t [+] gadget prepared: \n\t\t%s", gadget->prepared_gadget ? gadget->prepared_gadget  : "unprepared");

	// display the output map
	if(gadget->output_map)
	{

		printf("\n");
		printf("\n\t\t [+] XML Gadget Output Map:");

		for(n = 0; n < gadget->output_map_n; n++)
		{
			printf("\n\t\t\t [%u] %s", n, gadget->output_map[n]);
		}

	}

	// display variable substitution/randomization matrix
	if(gadget->var_randomization_matrix)
	{

		printf("\n");
		printf("\n\t\t [+] Symbol Randomization Matrix:");

		for(n = 0; n < gadget->var_randomization_matrix_n; n++)
		{
			printf("\n\t\t\t [%u] %s", n, gadget->var_randomization_matrix[n]);
		}

	}

	// if the argument stack is set, display argument information
	if(gadget->arguments_n)
	{

		printf("\n");
		printf("\n\t\t [+] PHP Gadget Current Arguments:");
		printf("\n");

		for(n = 0; n < gadget->arguments_n; n++)
		{
			printf("\n\t\t\t [+] Argument %u %s", n, gadget->arguments[n].arg_has_been_set ? "" : "(unset)");
			printf("\n\t\t\t\t symbol:     %s", gadget->arguments[n].arg_php_symbol);
			printf("\n\t\t\t\t type:       %s", BP_GetGadgetArgumentType(gadget->arguments[n].type, tq));
			printf("\n\t\t\t\t value set:  %s", gadget->arguments[n].arg_has_been_set ? "yes" : "no");
			printf("\n\t\t\t\t required:   %s", gadget->arguments[n].arg_required_for_run ? "yes" : "no");
			printf("\n\t\t\t\t argument:   %p", gadget->arguments[n].arg);
			printf("\n\t\t\t\t arg size:   %u", gadget->arguments[n].size);
			printf("\n\t\t\t\t value hex:  %s", BP_GenHexStringFromBuffer(gadget->arguments[n].arg, gadget->arguments[n].size, tq));
			if(gadget->arguments[n].type == BP_GADGET_ARG_TYPE_CHAR_STRING)
			{
				printf("\n\t\t\t\t value str:  %s", gadget->arguments[n].arg);
			}
		}
	}

	// destroy the thread queue allocator
	BP_DestroyLinkL(tq, BP_TRUE);

	// return indicating success
	return ERR_SUCCESS;

}
