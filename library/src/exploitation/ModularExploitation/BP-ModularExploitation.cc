
// Main blockparty include
#include "../../../include/BP-Main.h"

// Create a new modular exploitation session
P_BP_MODULAR_EXPLOITATION_SESSION BP_CreateNewModularExploitationSession
(
		P_BP_MYSQL_CONN_POOL db_pool
)
{

	// attempt to create a new session structure
	P_BP_MODULAR_EXPLOITATION_SESSION session = (P_BP_MODULAR_EXPLOITATION_SESSION) bpcalloc(sizeof(BP_MODULAR_EXPLOITATION_SESSION), 1);

	// ensure the memory was actually allocated
	if(!session)
		return NULL;

	// memory allocator identifier from random
	session->session_id = NEW_RANDOM_ID;

	// create a new tail queue memory allocator
	session->tq = BP_CreateLinkL("BP Modular Exploitation Session Allocator", BP_FALSE);

	// set the database pool
	session->db_pool = db_pool;

	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	// %%%%% Set Session Status to Defaults %%%%%%%%%%%%%%%%%%%%%%%
	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	// set default session status to enabled
	session->enabled_status = BP_MODULAR_EXPLOITATION_SESSION_ENABLED;

	// set default run status to stopped
	session->run_status = BP_MODULAR_EXPLOITATION_SESSION_RUN_STATUS_STOPPED;


	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	// %%%%%% Initialize Session Semaphores %%%%%%%%%%%%%%%%%%%%%%
	// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

	// initialize session lock semaphore
	sem_init(&session->session_lock, 0, 0);

	// initialize module manipulation lock
	sem_init(&session->module_manipulation_lock, 0, 0);

	// initialize target manipulation lock
	sem_init(&session->target_manipulation_lock, 0, 0);

	// return the newly allocated session
	return session;

}

// Destroys ALL memory created within a session.
BP_ERROR_T BP_DestroyModularExploitationSession(P_BP_MODULAR_EXPLOITATION_SESSION session)
{

	// ensure we have a pointer
	if(!session)
		return ERR_FAILURE;

	// destroy any potentially dangling data in the session
	BP_DestroyLinkL(session->tq, BP_TRUE);


	// return indicating success
	return ERR_SUCCESS;
}


// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%% Exploit Module Loader / Unloader %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


// Load an exploit module into the current session
BP_ERROR_T BP_MEInitExploitModule
(
		P_BP_MODULAR_EXPLOITATION_SESSION session,
		P_BP_EXPLOIT_MODULE               module,
		void                              *mod_user_arguments
)
{

	// ensure we have a session
	if(!session)
		return ERR_FAILURE;
	if(!module)
		return ERR_FAILURE;

	// check if we have any modules loaded, create if necessary, if not -- realloc.
	if(!session->modules && !session->module_n)
	{

		// allocate space for 2 pointers
		session->modules = (P_BP_EXPLOIT_MODULE*) tq_calloc(session->tq, sizeof(P_BP_EXPLOIT_MODULE) * 2, 1, BPLN);

		// set initial module count to 1
		session->module_n = 1;

		// set pointer to the module in the pointer set
		session->modules[0] = module;

		// set user arguments before initialization
		module->mod_user_arguments = mod_user_arguments;

		// call module load routine if it exists
		if(module->exploit_init_fn)
		{
			module->exploit_init_fn(NULL);
		}

		// set self referential pointers
		module->current_module     = module;
		module->current_session    = session;

		// set status flag in initialization position
		module->mod_status = BP_EXPLOIT_MODULE_STATUS_INITIALIZED;

		// set run flag as idle
		module->mod_run_status = BP_EXPLOIT_MODULE_RUN_STATUS_IDLE;

		// at this point we can return successfully
		return ERR_SUCCESS;

	}
	else if(session->modules && session->module_n)
	{

		// increment module count
		session->module_n++;

		// reallocate pointer array to fit new module
		session->modules = (P_BP_EXPLOIT_MODULE*) tq_realloc(session->tq, (void *) session->modules,  sizeof(P_BP_EXPLOIT_MODULE) * (session->module_n+1), BPLN);

		// set the module here so the class has reference
		session->modules[session->module_n-1] = module;

		// nullify the ending pointer since realloc doesn't
		session->modules[session->module_n] = NULL;

		// set user arguments before initialization
		module->mod_user_arguments = mod_user_arguments;

		// call module load routine if it exists
		if(module->exploit_init_fn)
		{
			module->exploit_init_fn(NULL);
		}

		// set self referential pointers
		module->current_module  = module;
		module->current_session = session;

		// set status flag in initialization position
		module->mod_status = BP_EXPLOIT_MODULE_STATUS_INITIALIZED;

		// set run flag as idle
		module->mod_run_status = BP_EXPLOIT_MODULE_RUN_STATUS_IDLE;

		// at this point we can return successfully
		return ERR_SUCCESS;

	}
	else /* in the case of bad data, return here */
		return ERR_FAILURE;

	// return indicating failure
	return ERR_FAILURE;

}

// Load an exploit module into the current session
BP_ERROR_T BP_MEUnloadExploitModule
(
		P_BP_MODULAR_EXPLOITATION_SESSION session,
		P_BP_EXPLOIT_MODULE               module
)
{

	// ensure we have a module
	if(!module)
		return ERR_FAILURE;

	// check to see that we have an unload function set
	if(!module->exploit_unload_fn)
		return ERR_FAILURE;

	// unload the module by calling the unload function
	return module->exploit_unload_fn((void *) module);

}


// inits a provided exploit module within the modular exploitation session
BP_ERROR_T BP_MELoadExploitModule
(
		P_BP_MODULAR_EXPLOITATION_SESSION session,
		P_BP_EXPLOIT_MODULE               module
)
{

	// return indicating success
	return ERR_SUCCESS;

}

// Runs one specific module within the session.  Creates the thread responsible for
// running the exploit.
BP_ERROR_T BP_MERunExploitModule
(
		P_BP_MODULAR_EXPLOITATION_SESSION session,
		P_BP_EXPLOIT_MODULE               module
)
{

	// return indicating success
	return ERR_SUCCESS;

}

// inits all modules within a system
BP_ERROR_T BP_MEInitExploitModules
(
		P_BP_MODULAR_EXPLOITATION_SESSION session
)
{

	// return indicating success
	return ERR_SUCCESS;

}

// runs all modules loaded (each module has it's own main thread and splinters)
BP_ERROR_T BP_MERunExploitModules
(
		P_BP_MODULAR_EXPLOITATION_SESSION session
)
{


	// return indicating success
	return ERR_SUCCESS;

}


// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%% Display Routines %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
// %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

// displays the contents of a modular exploitation session
BP_ERROR_T BP_MEDisplaySession(P_BP_MODULAR_EXPLOITATION_SESSION session)
{

	// test to see if we have a session
	if(!session)
		return ERR_FAILURE;

	// get session status for entire session
	char *session_status = "UNKNOWN BAD SESSION STATUS";
	switch(session->enabled_status)
	{
		case BP_MODULAR_EXPLOITATION_SESSION_UNSET:
			session_status = "BP_MODULAR_EXPLOITATION_SESSION_UNSET";
			break;
		case BP_MODULAR_EXPLOITATION_SESSION_ENABLED:
			session_status = "BP_MODULAR_EXPLOITATION_SESSION_ENABLED";
			break;
		case BP_MODULAR_EXPLOITATION_SESSION_DISABLED:
			session_status = "BP_MODULAR_EXPLOITATION_SESSION_DISABLED";
			break;
		default:
			break;
	}

	// string representation of run status
	char *run_status = "UNKNOWN BAD RUN STATUS";

	// switch to determine run status
	switch(session->run_status)
	{

		case BP_MODULAR_EXPLOITATION_SESSION_RUN_STATUS_UNSET:
			run_status = "BP_MODULAR_EXPLOITATION_SESSION_RUN_STATUS_UNSET";
			break;
		case BP_MODULAR_EXPLOITATION_SESSION_RUN_STATUS_RUNNING:
			run_status = "BP_MODULAR_EXPLOITATION_SESSION_RUN_STATUS_RUNNING";
			break;
		case BP_MODULAR_EXPLOITATION_SESSION_RUN_STATUS_PENDING:
			run_status = "BP_MODULAR_EXPLOITATION_SESSION_RUN_STATUS_PENDING";
			break;
		case BP_MODULAR_EXPLOITATION_SESSION_RUN_STATUS_PAUSED:
			run_status = "BP_MODULAR_EXPLOITATION_SESSION_RUN_STATUS_PAUSED";
			break;
		case BP_MODULAR_EXPLOITATION_SESSION_RUN_STATUS_STOPPED:
			run_status = "BP_MODULAR_EXPLOITATION_SESSION_RUN_STATUS_STOPPED";
			break;
		default:
			/* default string is already set during initial initialization */
			break;
	}


	printf("\n [+] Displaying Modular Exploitation System: %p", session);
	printf("\n\t Status:               %s", session_status);
	printf("\n\t Run Status:           %s", run_status);
	printf("\n\t Database Pool:        %p (%u connections in pool)", session->db_pool, session->db_pool ? session->db_pool->entries_total : 0);
	printf("\n\t Session ID:           %u", session->session_id);
	printf("\n\t Tail Queue Allocator: %p", session->tq);
	printf("\n");
	printf("\n\t [-]Loaded Modules:  %p", session->modules);
	printf("\n\t\t Total Modules Loaded: %u", session->module_n);
	printf("\n");
	printf("\n\t [-] Loaded Targets: %p", session->targets);
	printf("\n\t\t Target Count: %u", session->targets_n);
	printf("\n");

	// return indicating print success
	return ERR_SUCCESS;

}


// displays extended module information
BP_ERROR_T BP_MEDisplaySessionExtendedModuleInformation(P_BP_MODULAR_EXPLOITATION_SESSION session)
{

	// ensure we have a session
	if(!session)
		return ERR_FAILURE;

	// walk each module, and print information
	size_t n = 0;
	for(; n < session->module_n; n++)
	{

		// set reference for ease of use
		P_BP_EXPLOIT_MODULE mod = session->modules[n];

		// determines module status status
		char *mod_status = "BAD MODULE STATUS";
		switch(mod->mod_status)
		{
			case BP_EXPLOIT_MODULE_STATUS_UNSET:
				mod_status = "BP_EXPLOIT_MODULE_STATUS_UNSET";
				break;
			case BP_EXPLOIT_MODULE_STATUS_UNINITIALIZED:
				mod_status = "BP_EXPLOIT_MODULE_STATUS_UNINITIALIZED";
				break;
			case BP_EXPLOIT_MODULE_STATUS_INITIALIZED:
				mod_status = "BP_EXPLOIT_MODULE_STATUS_INITIALIZED";
				break;
			default:
				break;
		};

		// enumerator for fast-deteremining module run status
		char *mod_run_status = "BAD MODULE RUN STATUS";
		switch(mod->mod_run_status)
		{
			case BP_EXPLOIT_MODULE_RUN_STATUS_UNSET:
				mod_run_status = "BP_EXPLOIT_MODULE_RUN_STATUS_UNSET";
				break;
			case BP_EXPLOIT_MODULE_RUN_STATUS_IDLE:
				mod_run_status = "BP_EXPLOIT_MODULE_RUN_STATUS_IDLE";
				break;
			case BP_EXPLOIT_MODULE_RUN_STATUS_LOAD:
				mod_run_status = "BP_EXPLOIT_MODULE_RUN_STATUS_LOAD";
				break;
			case BP_EXPLOIT_MODULE_RUN_STATUS_UNLOAD:
				mod_run_status = "BP_EXPLOIT_MODULE_RUN_STATUS_UNLOAD";
				break;
			case BP_EXPLOIT_MODULE_RUN_STATUS_RELOAD:
				mod_run_status = "BP_EXPLOIT_MODULE_RUN_STATUS_RELOAD";
				break;
			case BP_EXPLOIT_MODULE_RUN_STATUS_ASSESSING_TARGET:
				mod_run_status = "BP_EXPLOIT_MODULE_RUN_STATUS_ASSESSING_TARGET";
				break;
			case BP_EXPLOIT_MODULE_RUN_STATUS_FIRING:
				mod_run_status = "BP_EXPLOIT_MODULE_RUN_STATUS_FIRING";
				break;
			case BP_EXPLOIT_MODULE_RUN_STATUS_DB_REPORT:
				mod_run_status = "BP_EXPLOIT_MODULE_RUN_STATUS_DB_REPORT";
				break;
			default:
				break;
		};

		// display main module run information
		printf("\n\t [+] Module Run Information: %p", mod);
		printf("\n\t\t name:            %s", mod->name);
		printf("\n\t\t version:         %u.%u", mod->major_version, mod->minor_version);
		printf("\n\t\t proxy safe?:     %u", mod->exploit_was_designed_for_proxy_safety);
		printf("\n\t\t current module:  %p", mod->current_module);
		printf("\n\t\t current session: %p", mod->current_session);

		// display function pointer information
		printf("\n\t\t [-] Module Run Functions:");
		printf("\n\t\t\t exploit_init_fn:                %p", mod->exploit_init_fn);
		printf("\n\t\t\t exploit_load_fn:                %p", mod->exploit_load_fn);
		printf("\n\t\t\t exploit_unload_fn:              %p", mod->exploit_unload_fn);
		printf("\n\t\t\t exploit_retarget_fn:            %p", mod->exploit_retarget_fn);
		printf("\n\t\t\t exploit_assess_target_fn:       %p", mod->exploit_assess_target_fn);
		printf("\n\t\t\t exploit_fire_fn:                %p", mod->exploit_fire_fn);
		printf("\n\t\t\t exploit_db_report_fn:           %p", mod->exploit_db_report_fn);
		printf("\n\t\t\t exploit_custom_print_report_fn: %p", mod->exploit_custom_print_report_fn);

		// display the current run report if user has specified a run report function
		if(mod->exploit_custom_print_report_fn)
		{
			printf("\n\t [+] Exploit Custom Print Report: ");
			mod->exploit_custom_print_report_fn((void *) mod);
		}

		// display module splintering information
		printf("\n\t\t [-] Module Splinter Information (%u total splinters found):", mod->splinters_n);

		// splinter display logic here
		printf("\n\t\t");


	}


	// return indicating success
	return ERR_SUCCESS;

}


